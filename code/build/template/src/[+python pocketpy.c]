/*
 *  Copyright (c) 2025 blueloveTH
 *  Distributed Under The MIT License
 *  https://github.com/pocketpy/pocketpy
 */
 
#include "pocketpy.h"
// interpreter/modules.h


void pk__add_module_os();
void pk__add_module_sys();
void pk__add_module_io();

void pk__add_module_math();
void pk__add_module_dis();
void pk__add_module_random();
void pk__add_module_json();
void pk__add_module_gc();
void pk__add_module_time();
void pk__add_module_easing();
void pk__add_module_traceback();
void pk__add_module_enum();
void pk__add_module_inspect();
void pk__add_module_pickle();
void pk__add_module_base64();
void pk__add_module_importlib();

void pk__add_module_linalg();
void pk__add_module_array2d();
void pk__add_module_colorcvt();

void pk__add_module_conio();
void pk__add_module_lz4();
void pk__add_module_pkpy();

#ifdef PK_BUILD_MODULE_LIBHV
void pk__add_module_libhv();
#else
#define pk__add_module_libhv()
#endif
// objects/base.h


typedef struct PyObject PyObject;
typedef struct VM VM;
extern VM* pk_current_vm;

typedef struct py_TValue {
    py_Type type;
    bool is_ptr;
    int extra;

    union {
        int64_t _i64;
        double _f64;
        bool _bool;
        py_CFunction _cfunc;
        PyObject* _obj;
        c11_vec2 _vec2;
        c11_vec2i _vec2i;
        void* _ptr;
    };
} py_TValue;

// common/_generated.h

// generated by prebuild.py

const char* load_kPythonLib(const char* name);

extern const char kPythonLibs_bisect[];
extern const char kPythonLibs_builtins[];
extern const char kPythonLibs_cmath[];
extern const char kPythonLibs_collections[];
extern const char kPythonLibs_dataclasses[];
extern const char kPythonLibs_datetime[];
extern const char kPythonLibs_functools[];
extern const char kPythonLibs_heapq[];
extern const char kPythonLibs_operator[];
extern const char kPythonLibs_typing[];

// common/algorithm.h


#include <stdbool.h>

#define c11__less(a, b) ((a) < (b))

#define c11__lower_bound(T, ptr, count, key, less, out_index)                                      \
    do {                                                                                           \
        T* __first = ptr;                                                                          \
        int __len = count;                                                                         \
        while(__len >= 8) {                                                                        \
            int __l2 = __len >> 1;                                                                 \
            T* __m = __first + __l2;                                                               \
            if(less((*__m), (key))) {                                                              \
                __first = ++__m;                                                                   \
                __len -= __l2 + 1;                                                                 \
            } else {                                                                               \
                __len = __l2;                                                                      \
            }                                                                                      \
        }                                                                                          \
        switch(__len) {                                                                            \
            case 7:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 6:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 5:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 4:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 3:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 2:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 1:                                                                                \
                if(less(*__first, (key))) __first++;                                               \
            case 0: break;                                                                         \
            default: c11__unreachable();                                                           \
        }                                                                                          \
        *(out_index) = __first - (T*)(ptr);                                                        \
    } while(0)

/**
 * @brief Sorts an array of elements of the same type, using the given comparison function.
 * @param ptr Pointer to the first element of the array.
 * @param count Number of elements in the array.
 * @param elem_size Size of each element in the array.
 * @param cmp Comparison function that takes two elements and returns an integer similar to
 * `strcmp`.
 */
bool c11__stable_sort(void* ptr,
                      int length,
                      int elem_size,
                      int (*f_lt)(const void* a, const void* b, void* extra),
                      void* extra);

// common/memorypool.h


typedef struct FixedMemoryPool {
    int BlockSize;
    int BlockCount;

    char* data;
    char* data_end;
    int exceeded_bytes;

    char** _free_list;
    int _free_list_length;
} FixedMemoryPool;

void FixedMemoryPool__ctor(FixedMemoryPool* self, int BlockSize, int BlockCount);
void FixedMemoryPool__dtor(FixedMemoryPool* self);
void* FixedMemoryPool__alloc(FixedMemoryPool* self);
void FixedMemoryPool__dealloc(FixedMemoryPool* self, void* p);
// common/utils.h


#include <stdio.h>

#define PK_REGION(name) 1

#define PK_SLICE_LOOP(i, start, stop, step)                                                        \
    for(int i = start; step > 0 ? i < stop : i > stop; i += step)

// global constants
#define PK_HEX_TABLE "0123456789abcdef"

#ifdef _MSC_VER
#define c11__unreachable() __assume(0)
#else
#define c11__unreachable() __builtin_unreachable()
#endif

#define c11__abort(...)                                                                            \
    do {                                                                                           \
        fprintf(stderr, __VA_ARGS__);                                                              \
        putchar('\n');                                                                             \
        abort();                                                                                   \
    } while(0)

#define c11__min(a, b) ((a) < (b) ? (a) : (b))
#define c11__max(a, b) ((a) > (b) ? (a) : (b))

#define c11__count_array(a) (sizeof(a) / sizeof(a[0]))

// ref counting
typedef struct RefCounted {
    int count;
    void (*dtor)(void*);
} RefCounted;

#define PK_INCREF(obj) (obj)->rc.count++
#define PK_DECREF(obj)                                                                             \
    do {                                                                                           \
        if(--(obj)->rc.count == 0) {                                                               \
            (obj)->rc.dtor(obj);                                                                   \
            PK_FREE(obj);                                                                          \
        }                                                                                          \
    } while(0)


// common/vector.h


#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdbool.h>

typedef struct c11_vector {
    void* data;
    int length;
    int capacity;
    int elem_size;
} c11_vector;

void c11_vector__ctor(c11_vector* self, int elem_size);
void c11_vector__dtor(c11_vector* self);
c11_vector c11_vector__copy(const c11_vector* self);
void c11_vector__reserve(c11_vector* self, int capacity);
void c11_vector__clear(c11_vector* self);
void* c11_vector__emplace(c11_vector* self);
bool c11_vector__contains(const c11_vector* self, void* elem);
void* c11_vector__submit(c11_vector* self, int* length);
void c11_vector__swap(c11_vector* self, c11_vector* other);

#define c11__getitem(T, self, index) (((T*)(self)->data)[index])
#define c11__setitem(T, self, index, value) ((T*)(self)->data)[index] = value;
#define c11__at(T, self, index) ((T*)(self)->data + index)

#define c11_vector__push(T, self, elem)                                                            \
    do {                                                                                           \
        if((self)->length == (self)->capacity) c11_vector__reserve((self), (self)->capacity * 2);  \
        ((T*)(self)->data)[(self)->length] = (elem);                                               \
        (self)->length++;                                                                          \
    } while(0)

#define c11_vector__pop(self) (--(self)->length)

#define c11_vector__back(T, self) (((T*)(self)->data)[(self)->length - 1])

#define c11_vector__extend(T, self, p, size)                                                       \
    do {                                                                                           \
        int min_capacity = (self)->length + (size);                                                \
        if((self)->capacity < min_capacity)                                                        \
            c11_vector__reserve((self), c11__max((self)->capacity * 2, min_capacity));             \
        memcpy((T*)(self)->data + (self)->length, (p), (size) * sizeof(T));                        \
        (self)->length += (size);                                                                  \
    } while(0)

#define c11_vector__insert(T, self, index, elem)                                                   \
    do {                                                                                           \
        if((self)->length == (self)->capacity) c11_vector__reserve((self), (self)->capacity * 2);  \
        T* p = (T*)(self)->data + (index);                                                         \
        memmove(p + 1, p, ((self)->length - (index)) * sizeof(T));                                 \
        *p = (elem);                                                                               \
        (self)->length++;                                                                          \
    } while(0)

#define c11_vector__erase(T, self, index)                                                          \
    do {                                                                                           \
        T* p = (T*)(self)->data + (index);                                                         \
        memmove(p, p + 1, ((self)->length - (index)-1) * sizeof(T));                               \
        (self)->length--;                                                                          \
    } while(0)

#define c11__reverse(T, self)                                                                      \
    do {                                                                                           \
        if(!self->data) break;                                                                     \
        T* p = (T*)(self)->data;                                                                   \
        T* q = (T*)(self)->data + (self)->length - 1;                                              \
        while(p < q) {                                                                             \
            T tmp = *p;                                                                            \
            *p = *q;                                                                               \
            *q = tmp;                                                                              \
            p++;                                                                                   \
            q--;                                                                                   \
        }                                                                                          \
    } while(0)

// NOTE: here we do an extra NULL check for it to avoid UB
#define c11__foreach(T, self, it)                                                                  \
    for(T* it = (self)->data; it && it != (T*)(self)->data + (self)->length; it++)

// interpreter/types.h


#define PK_DICT_MAX_COLLISION 4

typedef struct {
    uint64_t hash;
    py_TValue key;
    py_TValue val;
} DictEntry;

typedef struct {
    int _[PK_DICT_MAX_COLLISION];
} DictIndex;

typedef struct {
    int length;
    uint32_t capacity;
    DictIndex* indices;
    c11_vector /*T=DictEntry*/ entries;
} Dict;

typedef c11_vector List;

void c11_chunked_array2d__mark(void* ud);
void function__gc_mark(void* ud);
// common/str.h


#include <stdarg.h>

/* string */
typedef struct c11_string {
    // int size | char[] | '\0'
    int size;
    char data[];  // flexible array member
} c11_string;

/* bytes */
typedef struct c11_bytes {
    int size;
    unsigned char data[];  // flexible array member
} c11_bytes;

bool c11_bytes__eq(c11_bytes* self, c11_bytes* other);

int c11_sv__cmp(c11_sv self, c11_sv other);
int c11_sv__cmp2(c11_sv self, const char* other);

bool c11__streq(const char* a, const char* b);
bool c11__sveq(c11_sv a, c11_sv b);
bool c11__sveq2(c11_sv a, const char* b);

c11_string* c11_string__new(const char* data);
c11_string* c11_string__new2(const char* data, int size);
c11_string* c11_string__new3(const char* fmt, ...);
void c11_string__ctor(c11_string* self, const char* data);
void c11_string__ctor2(c11_string* self, const char* data, int size);
void c11_string__ctor3(c11_string* self, int size);
c11_string* c11_string__copy(c11_string* self);
void c11_string__delete(c11_string* self);
c11_sv c11_string__sv(c11_string* self);

int c11_sv__u8_length(c11_sv self);
c11_sv c11_sv__u8_getitem(c11_sv self, int i);
c11_string* c11_sv__u8_slice(c11_sv self, int start, int stop, int step);

// general string operations
c11_sv c11_sv__slice(c11_sv sv, int start);
c11_sv c11_sv__slice2(c11_sv sv, int start, int stop);
c11_sv c11_sv__strip(c11_sv sv, c11_sv chars, bool left, bool right);
int c11_sv__index(c11_sv self, char c);
int c11_sv__rindex(c11_sv self, char c);
int c11_sv__index2(c11_sv self, c11_sv sub, int start);
int c11_sv__count(c11_sv self, c11_sv sub);
bool c11_sv__startswith(c11_sv self, c11_sv prefix);
bool c11_sv__endswith(c11_sv self, c11_sv suffix);

c11_string* c11_sv__replace(c11_sv self, char old, char new_);
c11_string* c11_sv__replace2(c11_sv self, c11_sv old, c11_sv new_);

c11_vector /* T=c11_sv */ c11_sv__split(c11_sv self, char sep);
c11_vector /* T=c11_sv */ c11_sv__split2(c11_sv self, c11_sv sep);

// misc
int c11__unicode_index_to_byte(const char* data, int i);
int c11__byte_index_to_unicode(const char* data, int n);

bool c11__is_unicode_Lo_char(int c);
int c11__u8_header(unsigned char c, bool suppress);
int c11__u8_value(int u8bytes, const char* data);
int c11__u32_to_u8(uint32_t utf32_char, char utf8_output[4]);

typedef enum IntParsingResult {
    IntParsing_SUCCESS,
    IntParsing_FAILURE,
    IntParsing_OVERFLOW,
} IntParsingResult;

IntParsingResult c11__parse_uint(c11_sv text, int64_t* out, int base);

// interpreter/objectpool.h


#define kPoolArenaSize (120 * 1024)
#define kMultiPoolCount 5
#define kPoolMaxBlockSize (32*kMultiPoolCount)

typedef struct PoolArena {
    int block_size;
    int block_count;
    int unused_length;
    int* unused;
    char data[kPoolArenaSize];
} PoolArena;

typedef struct Pool {
    c11_vector /* PoolArena* */ arenas;
    c11_vector /* PoolArena* */ no_free_arenas;
    int block_size;
} Pool;

typedef struct MultiPool {
    Pool pools[kMultiPoolCount];
} MultiPool;

void* MultiPool__alloc(MultiPool* self, int size);
int MultiPool__sweep_dealloc(MultiPool* self);
void MultiPool__ctor(MultiPool* self);
void MultiPool__dtor(MultiPool* self);
c11_string* MultiPool__summary(MultiPool* self);
// objects/namedict.h


#include <stdint.h>

#define SMALLMAP_T__HEADER
#define K uint16_t
#define V py_TValue
#define NAME NameDict
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__HEADER

/* A simple binary tree for storing modules. */
typedef struct ModuleDict {
    const char* path;
    py_TValue module;
    struct ModuleDict* left;
    struct ModuleDict* right;
} ModuleDict;

void ModuleDict__ctor(ModuleDict* self, const char* path, py_TValue module);
void ModuleDict__dtor(ModuleDict* self);
void ModuleDict__set(ModuleDict* self, const char* key, py_TValue val);
py_TValue* ModuleDict__try_get(ModuleDict* self, const char* path);
bool ModuleDict__contains(ModuleDict* self, const char* path);
void ModuleDict__apply_mark(ModuleDict* self);

// objects/object.h


typedef struct PyObject {
    py_Type type;  // we have a duplicated type here for convenience
    // bool _;
    bool gc_marked;
    int slots;  // number of slots in the object
    char flex[];
} PyObject;

// slots >= 0, allocate N slots
// slots == -1, allocate a dict

// | HEADER | <N slots> | <userdata>
// | HEADER | <dict>    | <userdata>

py_TValue* PyObject__slots(PyObject* self);
NameDict* PyObject__dict(PyObject* self);
void* PyObject__userdata(PyObject* self);

#define PK_OBJ_SLOTS_SIZE(slots) ((slots) >= 0 ? sizeof(py_TValue) * (slots) : sizeof(NameDict))

void PyObject__dtor(PyObject* self);
void PyObject__mark(PyObject* self);

// interpreter/heap.h


typedef struct ManagedHeap {
    MultiPool small_objects;
    c11_vector /* PyObject* */ large_objects;

    int freed_ma[3];
    int gc_threshold;  // threshold for gc_counter
    int gc_counter;    // objects created since last gc
    bool gc_enabled;
} ManagedHeap;

void ManagedHeap__ctor(ManagedHeap* self);
void ManagedHeap__dtor(ManagedHeap* self);

void ManagedHeap__collect_if_needed(ManagedHeap* self);
int ManagedHeap__collect(ManagedHeap* self);
int ManagedHeap__sweep(ManagedHeap* self);

#define ManagedHeap__new(self, type, slots, udsize)                                                \
    ManagedHeap__gcnew((self), (type), (slots), (udsize))
PyObject* ManagedHeap__gcnew(ManagedHeap* self, py_Type type, int slots, int udsize);

// external implementation
void ManagedHeap__mark(ManagedHeap* self);

// interpreter/typeinfo.h


#define PK_MAGIC_SLOTS_COMMON_LENGTH (__missing__ - __xor__)
#define PK_MAGIC_SLOTS_UNCOMMON_LENGTH (__xor__ + 1)
#define PK_MAX_CHUNK_LENGTH 256

typedef struct py_TypeInfo {
    py_Name name;
    py_Type base;
    struct py_TypeInfo* base_ti;

    py_TValue self;
    py_TValue module;  // the module where the type is defined

    bool is_python;  // is it a python class? (not derived from c object)
    bool is_sealed;  // can it be subclassed?

    void (*dtor)(void*);

    py_TValue annotations;  // type annotations

    void (*on_end_subclass)(struct py_TypeInfo*);  // backdoor for enum module

    /* Magic Slots */
    py_TValue magic_0[PK_MAGIC_SLOTS_COMMON_LENGTH];  // common magic slots
    py_TValue* magic_1;                               // uncommon magic slots
} py_TypeInfo;

typedef struct TypeList {
    int length;
    py_TypeInfo* chunks[PK_MAX_CHUNK_LENGTH];
} TypeList;

void TypeList__ctor(TypeList* self);
void TypeList__dtor(TypeList* self);
py_TypeInfo* TypeList__get(TypeList* self, py_Type index);
py_TypeInfo* TypeList__emplace(TypeList* self);
void TypeList__apply(TypeList* self, void (*f)(py_TypeInfo*, void*), void* ctx);
py_TValue* TypeList__magic(py_TypeInfo* self, unsigned index);
py_TValue* TypeList__magic_readonly(py_TypeInfo* self, unsigned index);

#define TypeList__magic_common(ti, index) ((ti)->magic_0 + ((index)-PK_MAGIC_SLOTS_UNCOMMON_LENGTH))

// common/smallmap.h


#include <stdint.h>

#define SMALLMAP_T__HEADER
#define K uint16_t
#define V int
#define NAME c11_smallmap_n2i
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__HEADER


#define SMALLMAP_T__HEADER
#define K c11_sv
#define V uint16_t
#define NAME c11_smallmap_s2n
#define less(a, b)      (c11_sv__cmp((a), (b)) <  0)
#define equal(a, b)     (c11_sv__cmp((a), (b)) == 0)
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__HEADER


#define SMALLMAP_T__HEADER
#define K void*
#define V int
#define NAME c11_smallmap_p2i
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__HEADER

// interpreter/array2d.h


typedef struct c11_array2d_like {
    int n_cols;
    int n_rows;
    int numel;
    py_Ref (*f_get)(struct c11_array2d_like* self, int col, int row);
    bool (*f_set)(struct c11_array2d_like* self, int col, int row, py_Ref value);
} c11_array2d_like;

typedef struct c11_array2d_like_iterator {
    c11_array2d_like* array;
    int j;
    int i;
} c11_array2d_like_iterator;

typedef struct c11_array2d {
    c11_array2d_like header;
    py_TValue* data;  // slots
} c11_array2d;

typedef struct c11_array2d_view {
    c11_array2d_like header;
    void* ctx;
    py_Ref (*f_get)(void* ctx, int col, int row);
    bool (*f_set)(void* ctx, int col, int row, py_Ref value);
    c11_vec2i origin;
} c11_array2d_view;

c11_array2d* py_newarray2d(py_OutRef out, int n_cols, int n_rows);

/* chunked_array2d */
#define SMALLMAP_T__HEADER
#define K c11_vec2i
#define V py_TValue*
#define NAME c11_chunked_array2d_chunks
#define less(a, b) (a._i64 < b._i64)
#define equal(a, b) (a._i64 == b._i64)
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__HEADER

typedef struct c11_chunked_array2d {
    c11_chunked_array2d_chunks chunks;
    int chunk_size;
    int chunk_size_log2;
    int chunk_size_mask;
    c11_chunked_array2d_chunks_KV last_visited;

    py_TValue default_T;
    py_TValue context_builder;
} c11_chunked_array2d;

py_Ref c11_chunked_array2d__get(c11_chunked_array2d* self, int col, int row);
bool c11_chunked_array2d__set(c11_chunked_array2d* self, int col, int row, py_Ref value);

// interpreter/name.h


typedef struct {
    char* data;     // null-terminated data
    int size;       // size of the data excluding the null-terminator
    py_TValue obj;  // cached `str` object (lazy initialized)
} RInternedEntry;

typedef struct {
    c11_smallmap_s2n interned;
    c11_vector /* T=RInternedEntry */ r_interned;
} InternedNames;

void InternedNames__ctor(InternedNames* self);
void InternedNames__dtor(InternedNames* self);

// common/sstream.h


#include <stdint.h>

typedef struct c11_sbuf {
    c11_vector data;
} c11_sbuf;

void c11_sbuf__ctor(c11_sbuf* self);
void c11_sbuf__dtor(c11_sbuf* self);

void c11_sbuf__write_int(c11_sbuf* self, int);
void c11_sbuf__write_i64(c11_sbuf* self, int64_t);
void c11_sbuf__write_f64(c11_sbuf* self, double, int precision);
void c11_sbuf__write_char(c11_sbuf* self, char);
void c11_sbuf__write_pad(c11_sbuf* self, int count, char pad);
void c11_sbuf__write_sv(c11_sbuf* self, c11_sv);
void c11_sbuf__write_cstr(c11_sbuf* self, const char*);
void c11_sbuf__write_cstrn(c11_sbuf* self, const char*, int);
void c11_sbuf__write_quoted(c11_sbuf* self, c11_sv, char quote);
void c11_sbuf__write_hex(c11_sbuf* self, unsigned char, bool non_zero);
void c11_sbuf__write_ptr(c11_sbuf* self, void*);
// Submit the stream and return the final string. The stream becomes invalid after this call
c11_string* c11_sbuf__submit(c11_sbuf* self);
void c11_sbuf__py_submit(c11_sbuf* self, py_Ref out);

void pk_vsprintf(c11_sbuf* ss, const char* fmt, va_list args);
void pk_sprintf(c11_sbuf* ss, const char* fmt, ...);

// objects/sourcedata.h


#include <stdbool.h>
struct SourceData {
    RefCounted rc;
    enum py_CompileMode mode;
    bool is_dynamic;  // for exec() and eval()

    c11_string* filename;
    c11_string* source;

    c11_vector /*T=const char* */ line_starts;
};

typedef struct SourceData* SourceData_;

SourceData_ SourceData__rcnew(const char* source,
                                    const char* filename,
                                    enum py_CompileMode mode,
                                    bool is_dynamic);
bool SourceData__get_line(const struct SourceData* self,
                             int lineno,
                             const char** st,
                             const char** ed);
void SourceData__snapshot(const struct SourceData* self,
                             c11_sbuf* ss,
                             int lineno,
                             const char* cursor,
                             const char* name);

// objects/codeobject.h


#include <stdbool.h>
#include <stdint.h>

#define BC_NOARG 0
#define BC_KEEPLINE -1

typedef enum FuncType {
    FuncType_UNSET,
    FuncType_NORMAL,
    FuncType_SIMPLE,
    FuncType_GENERATOR,
} FuncType;

typedef enum NameScope {
    NAME_LOCAL,
    NAME_GLOBAL,
} NameScope;

typedef enum CodeBlockType {
    CodeBlockType_NO_BLOCK,
    CodeBlockType_WHILE_LOOP,
    CodeBlockType_TRY,
    /* context blocks (stack-based) */
    CodeBlockType_FOR_LOOP,
    CodeBlockType_WITH,
    /* context blocks (flag-based) */
    CodeBlockType_EXCEPT,
    CodeBlockType_FINALLY,
} CodeBlockType;

typedef enum Opcode {

#define OPCODE(name) OP_##name,
#ifdef OPCODE

/**************************/
OPCODE(NO_OP)
/**************************/
OPCODE(POP_TOP)
OPCODE(DUP_TOP)
OPCODE(DUP_TOP_TWO)
OPCODE(ROT_TWO)
OPCODE(ROT_THREE)
OPCODE(PRINT_EXPR)
/**************************/
OPCODE(LOAD_CONST)
OPCODE(LOAD_NONE)
OPCODE(LOAD_TRUE)
OPCODE(LOAD_FALSE)
/**************************/
OPCODE(LOAD_SMALL_INT)
/**************************/
OPCODE(LOAD_ELLIPSIS)
OPCODE(LOAD_FUNCTION)
OPCODE(LOAD_NULL)
/**************************/
OPCODE(LOAD_FAST)
OPCODE(LOAD_NAME)
OPCODE(LOAD_NONLOCAL)
OPCODE(LOAD_GLOBAL)
OPCODE(LOAD_ATTR)
OPCODE(LOAD_CLASS_GLOBAL)
OPCODE(LOAD_METHOD)
OPCODE(LOAD_SUBSCR)

OPCODE(STORE_FAST)
OPCODE(STORE_NAME)
OPCODE(STORE_GLOBAL)
OPCODE(STORE_ATTR)
OPCODE(STORE_SUBSCR)

OPCODE(DELETE_FAST)
OPCODE(DELETE_NAME)
OPCODE(DELETE_GLOBAL)
OPCODE(DELETE_ATTR)
OPCODE(DELETE_SUBSCR)
/**************************/
OPCODE(BUILD_IMAG)
OPCODE(BUILD_BYTES)
OPCODE(BUILD_TUPLE)
OPCODE(BUILD_LIST)
OPCODE(BUILD_DICT)
OPCODE(BUILD_SET)
OPCODE(BUILD_SLICE)
OPCODE(BUILD_STRING)
/**************************/
OPCODE(BINARY_OP)
OPCODE(IS_OP)
OPCODE(CONTAINS_OP)
/**************************/
OPCODE(JUMP_FORWARD)
OPCODE(POP_JUMP_IF_FALSE)
OPCODE(POP_JUMP_IF_TRUE)
OPCODE(JUMP_IF_TRUE_OR_POP)
OPCODE(JUMP_IF_FALSE_OR_POP)
OPCODE(SHORTCUT_IF_FALSE_OR_POP)
OPCODE(LOOP_CONTINUE)
OPCODE(LOOP_BREAK)
/**************************/
OPCODE(CALL)
OPCODE(CALL_VARGS)
/**************************/
OPCODE(RETURN_VALUE)
OPCODE(YIELD_VALUE)
OPCODE(FOR_ITER_YIELD_VALUE)
/**************************/
OPCODE(LIST_APPEND)
OPCODE(DICT_ADD)
OPCODE(SET_ADD)
/**************************/
OPCODE(UNARY_NEGATIVE)
OPCODE(UNARY_NOT)
OPCODE(UNARY_STAR)
OPCODE(UNARY_INVERT)
/**************************/
OPCODE(GET_ITER)
OPCODE(FOR_ITER)
/**************************/
OPCODE(IMPORT_PATH)
OPCODE(POP_IMPORT_STAR)
/**************************/
OPCODE(UNPACK_SEQUENCE)
OPCODE(UNPACK_EX)
/**************************/
OPCODE(BEGIN_CLASS)
OPCODE(END_CLASS)
OPCODE(STORE_CLASS_ATTR)
OPCODE(ADD_CLASS_ANNOTATION)
/**************************/
OPCODE(WITH_ENTER)
OPCODE(WITH_EXIT)
/**************************/
OPCODE(TRY_ENTER)
OPCODE(EXCEPTION_MATCH)
OPCODE(RAISE)
OPCODE(RAISE_ASSERT)
OPCODE(RE_RAISE)
OPCODE(PUSH_EXCEPTION)
OPCODE(BEGIN_EXC_HANDLING)
OPCODE(END_EXC_HANDLING)
OPCODE(BEGIN_FINALLY)
OPCODE(END_FINALLY)
/**************************/
OPCODE(FORMAT_STRING)
/**************************/
#endif

#undef OPCODE
} Opcode;

typedef struct Bytecode {
    uint8_t op;
    uint16_t arg;
} Bytecode;

void Bytecode__set_signed_arg(Bytecode* self, int arg);
bool Bytecode__is_forward_jump(const Bytecode* self);

typedef struct CodeBlock {
    CodeBlockType type;
    int parent;  // parent index in blocks
    int start;   // start index of this block in codes, inclusive
    int end;     // end index of this block in codes, exclusive
    int end2;    // ...
} CodeBlock;

typedef struct BytecodeEx {
    int lineno;       // line number for each bytecode
    bool is_virtual;  // whether this bytecode is virtual (not in source code)
    int iblock;       // block index
} BytecodeEx;

typedef struct CodeObject {
    SourceData_ src;
    c11_string* name;

    c11_vector /*T=Bytecode*/ codes;
    c11_vector /*T=CodeObjectByteCodeEx*/ codes_ex;

    c11_vector /*T=py_TValue*/ consts;  // constants
    c11_vector /*T=py_Name*/ varnames;  // local variables
    int nlocals;                        // cached varnames.size()

    c11_smallmap_n2i varnames_inv;

    c11_vector /*T=CodeBlock*/ blocks;
    c11_vector /*T=FuncDecl_*/ func_decls;

    int start_line;
    int end_line;
} CodeObject;

void CodeObject__ctor(CodeObject* self, SourceData_ src, c11_sv name);
void CodeObject__dtor(CodeObject* self);
int CodeObject__add_varname(CodeObject* self, py_Name name);
void CodeObject__gc_mark(const CodeObject* self);

typedef struct FuncDeclKwArg {
    int index;        // index in co->varnames
    uint16_t key;     // name of this argument
    py_TValue value;  // default value
} FuncDeclKwArg;

typedef struct FuncDecl {
    RefCounted rc;
    CodeObject code;  // strong ref

    c11_vector /*T=int*/ args;      // indices in co->varnames
    c11_vector /*T=KwArg*/ kwargs;  // indices in co->varnames

    int starred_arg;    // index in co->varnames, -1 if no *arg
    int starred_kwarg;  // index in co->varnames, -1 if no **kwarg
    bool nested;        // whether this function is nested

    const char* docstring;  // docstring of this function (weak ref)

    FuncType type;
    c11_smallmap_n2i kw_to_index;
} FuncDecl;

typedef FuncDecl* FuncDecl_;

FuncDecl_ FuncDecl__rcnew(SourceData_ src, c11_sv name);
bool FuncDecl__is_duplicated_arg(const FuncDecl* self, py_Name name);
void FuncDecl__add_arg(FuncDecl* self, py_Name name);
void FuncDecl__add_kwarg(FuncDecl* self, py_Name name, const py_TValue* value);
void FuncDecl__add_starred_arg(FuncDecl* self, py_Name name);
void FuncDecl__add_starred_kwarg(FuncDecl* self, py_Name name);
void FuncDecl__gc_mark(const FuncDecl* self);

// runtime function
typedef struct Function {
    FuncDecl_ decl;
    py_GlobalRef module;    // maybe NULL, weak ref
    py_Ref globals;         // maybe NULL, strong ref
    NameDict* closure;      // maybe NULL, strong ref
    PyObject* clazz;        // weak ref; for super()
    py_CFunction cfunc;     // wrapped C function; for decl-based binding
} Function;

void Function__ctor(Function* self, FuncDecl_ decl, py_GlobalRef module, py_Ref globals);
void Function__dtor(Function* self);

// interpreter/frame.h


void FastLocals__to_dict(py_TValue* locals, const CodeObject* co) PY_RETURN;
NameDict* FastLocals__to_namedict(py_TValue* locals, const CodeObject* co);

typedef struct ValueStack {
    py_TValue* sp;
    py_TValue* end;
    // We allocate extra places to keep `_sp` valid to detect stack overflow
    py_TValue begin[PK_VM_STACK_SIZE + PK_MAX_CO_VARNAMES * 2];
} ValueStack;

void ValueStack__ctor(ValueStack* self);
void ValueStack__dtor(ValueStack* self);

typedef struct UnwindTarget {
    struct UnwindTarget* next;
    int iblock;
    int offset;
} UnwindTarget;

UnwindTarget* UnwindTarget__new(UnwindTarget* next, int iblock, int offset);
void UnwindTarget__delete(UnwindTarget* self);

typedef struct py_Frame {
    struct py_Frame* f_back;
    const CodeObject* co;
    py_StackRef p0;  // unwinding base
    py_GlobalRef module;
    py_Ref globals;  // a module object or a dict object
    py_Ref locals;
    bool is_locals_special;
    int ip;
    UnwindTarget* uw_list;
} py_Frame;

typedef struct SourceLocation {
    SourceData_ src;
    int lineno;
} SourceLocation;

py_Frame* Frame__new(const CodeObject* co,
                  py_StackRef p0,
                  py_GlobalRef module,
                  py_Ref globals,
                  py_Ref locals,
                  bool is_locals_special);
void Frame__delete(py_Frame* self);

int Frame__lineno(const py_Frame* self);
int Frame__iblock(const py_Frame* self);

int Frame__getglobal(py_Frame* self, py_Name name) PY_RAISE PY_RETURN;
bool Frame__setglobal(py_Frame* self, py_Name name, py_TValue* val) PY_RAISE;
int Frame__delglobal(py_Frame* self, py_Name name) PY_RAISE;

py_Ref Frame__getclosure(py_Frame* self, py_Name name);
py_StackRef Frame__getlocal_noproxy(py_Frame* self, py_Name name);

int Frame__prepare_jump_exception_handler(py_Frame* self, ValueStack*);

UnwindTarget* Frame__find_unwind_target(py_Frame* self, int iblock);
void Frame__set_unwind_target(py_Frame* self, py_TValue* sp);

void Frame__gc_mark(py_Frame* self);
SourceLocation Frame__source_location(py_Frame* self);
// interpreter/generator.h


typedef struct Generator{
    py_Frame* frame;
    int state;
} Generator;

void pk_newgenerator(py_Ref out, py_Frame* frame, py_TValue* begin, py_TValue* end);

void Generator__dtor(Generator* ud);
// interpreter/vm.h


// TODO:
// 1. __eq__ and __ne__ fallbacks
// 2. un-cleared exception detection
// 3. super()
// 4. stack balance guanrantee
// 5. stack effect of each opcode
// 6. py_TypeInfo

typedef struct TraceInfo {
    SourceLocation prev_loc;
    py_TraceFunc func;
} TraceInfo;

typedef struct VM {
    py_Frame* top_frame;

    ModuleDict modules;
    TypeList types;

    py_TValue builtins;  // builtins module
    py_TValue main;      // __main__ module

    py_Callbacks callbacks;

    py_TValue ascii_literals[128+1];

    py_TValue last_retval;
    py_TValue curr_exception;

    int recursion_depth;
    int max_recursion_depth;
    
    bool is_curr_exc_handled;  // handled by try-except block but not cleared yet

    py_TValue reg[8];  // users' registers
    void* ctx;         // user-defined context

    py_StackRef curr_class;
    py_StackRef curr_decl_based_function;
    TraceInfo trace_info;
    py_TValue vectorcall_buffer[PK_MAX_CO_VARNAMES];

    InternedNames names;
    FixedMemoryPool pool_frame;
    ManagedHeap heap;
    ValueStack stack;  // put `stack` at the end for better cache locality
} VM;

void VM__ctor(VM* self);
void VM__dtor(VM* self);

void VM__push_frame(VM* self, py_Frame* frame);
void VM__pop_frame(VM* self);

bool pk__parse_int_slice(py_Ref slice, int length, int* restrict start, int* restrict stop, int* restrict step);
bool pk__normalize_index(int* index, int length);

#define pk__mark_value(val) if((val)->is_ptr && !(val)->_obj->gc_marked) PyObject__mark((val)->_obj)

bool pk__object_new(int argc, py_Ref argv);
py_TypeInfo* pk__type_info(py_Type type);

bool pk_wrapper__self(int argc, py_Ref argv);

const char* pk_op2str(py_Name op);

typedef enum FrameResult {
    RES_ERROR = 0,
    RES_RETURN = 1,
    RES_CALL = 2,
    RES_YIELD = 3,
} FrameResult;

FrameResult VM__run_top_frame(VM* self);

py_Type pk_newtype(const char* name,
                   py_Type base,
                   const py_GlobalRef module,
                   void (*dtor)(void*),
                   bool is_python,
                   bool is_sealed);

FrameResult VM__vectorcall(VM* self, uint16_t argc, uint16_t kwargc, bool opcall);

const char* pk_opname(Opcode op);

int pk_arrayview(py_Ref self, py_TValue** p);
bool pk_wrapper__arrayequal(py_Type type, int argc, py_Ref argv);
bool pk_arrayiter(py_Ref val);
bool pk_arraycontains(py_Ref self, py_Ref val);

bool pk_loadmethod(py_StackRef self, py_Name name);
bool pk_callmagic(py_Name name, int argc, py_Ref argv);

bool pk_exec(CodeObject* co, py_Ref module);
bool pk_execdyn(CodeObject* co, py_Ref module, py_Ref globals, py_Ref locals);

/// Assumes [a, b] are on the stack, performs a binary op.
/// The result is stored in `self->last_retval`.
/// The stack remains unchanged.
bool pk_stack_binaryop(VM* self, py_Name op, py_Name rop);

void pk_print_stack(VM* self, py_Frame* frame, Bytecode byte);

// type registration
void pk_object__register();
void pk_number__register();
py_Type pk_str__register();
py_Type pk_str_iterator__register();
py_Type pk_bytes__register();
py_Type pk_dict__register();
py_Type pk_dict_items__register();
py_Type pk_list__register();
py_Type pk_tuple__register();
py_Type pk_array_iterator__register();
py_Type pk_slice__register();
py_Type pk_function__register();
py_Type pk_nativefunc__register();
py_Type pk_boundmethod__register();
py_Type pk_range__register();
py_Type pk_range_iterator__register();
py_Type pk_BaseException__register();
py_Type pk_Exception__register();
py_Type pk_StopIteration__register();
py_Type pk_super__register();
py_Type pk_property__register();
py_Type pk_staticmethod__register();
py_Type pk_classmethod__register();
py_Type pk_generator__register();
py_Type pk_namedict__register();
py_Type pk_code__register();

py_TValue pk_builtins__register();

/* mappingproxy */
void pk_mappingproxy__namedict(py_Ref out, py_Ref object);
// objects/error.h


typedef struct{
    SourceData_ src;
    int lineno;
    char msg[100];
} Error;

void py_BaseException__stpush(py_Ref, SourceData_ src, int lineno, const char* func_name);

// compiler/lexer.h


#include <stdint.h>

extern const char* TokenSymbols[];

typedef enum TokenIndex{
    TK_EOF, TK_EOL, TK_SOF,
    TK_ID, TK_NUM, TK_STR, TK_FSTR_BEGIN, TK_FSTR_CPNT, TK_FSTR_SPEC, TK_FSTR_END, TK_BYTES, TK_IMAG,
    TK_INDENT, TK_DEDENT,
    /***************/
    TK_IS_NOT, TK_NOT_IN, TK_YIELD_FROM,
    /***************/
    TK_ADD, TK_IADD, TK_SUB, TK_ISUB,
    TK_MUL, TK_IMUL, TK_DIV, TK_IDIV, TK_FLOORDIV, TK_IFLOORDIV, TK_MOD, TK_IMOD,
    TK_AND, TK_IAND, TK_OR, TK_IOR, TK_XOR, TK_IXOR,
    TK_LSHIFT, TK_ILSHIFT, TK_RSHIFT, TK_IRSHIFT,
    /***************/
    TK_LPAREN, TK_RPAREN, TK_LBRACKET, TK_RBRACKET, TK_LBRACE, TK_RBRACE,
    TK_DOT, TK_DOTDOT, TK_DOTDOTDOT, TK_COMMA, TK_COLON, TK_SEMICOLON,
    TK_POW, TK_ARROW, TK_HASH, TK_DECORATOR,
    TK_GT, TK_LT, TK_ASSIGN, TK_EQ, TK_NE, TK_GE, TK_LE, TK_INVERT,
    /***************/
    TK_FALSE, TK_NONE, TK_TRUE, TK_AND_KW, TK_AS, TK_ASSERT, TK_BREAK, TK_CLASS, TK_CONTINUE,
    TK_DEF, TK_DEL, TK_ELIF, TK_ELSE, TK_EXCEPT, TK_FINALLY, TK_FOR, TK_FROM, TK_GLOBAL,
    TK_IF, TK_IMPORT, TK_IN, TK_IS, TK_LAMBDA, TK_NOT_KW, TK_OR_KW, TK_PASS, TK_RAISE, TK_RETURN,
    TK_TRY, TK_WHILE, TK_WITH, TK_YIELD,
    /***************/
    TK__COUNT__
} TokenIndex;

enum TokenValueIndex{
    TokenValue_EMPTY = 0,
    TokenValue_I64 = 1,
    TokenValue_F64 = 2,
    TokenValue_STR = 3,
};

typedef struct TokenValue {
    enum TokenValueIndex index;  // 0: empty
    union {
        int64_t _i64;       // 1
        double _f64;        // 2
        c11_string* _str;   // 3
    };
} TokenValue;

typedef struct Token {
    TokenIndex type;
    const char* start;
    int length;
    int line;
    int brackets_level;
    TokenValue value;
} Token;

// https://docs.python.org/3/reference/expressions.html#operator-precedence
enum Precedence {
    PREC_LOWEST = 0,
    PREC_LAMBDA,       // lambda
    PREC_TERNARY,      // ?:
    PREC_LOGICAL_OR,   // or
    PREC_LOGICAL_AND,  // and
    PREC_LOGICAL_NOT,  // not
    /* https://docs.python.org/3/reference/expressions.html#comparisons
     * Unlike C, all comparison operations in Python have the same priority,
     * which is lower than that of any arithmetic, shifting or bitwise operation.
     * Also unlike C, expressions like a < b < c have the interpretation that is conventional in mathematics.
     */
    PREC_COMPARISION,    // < > <= >= != ==, in / is / is not / not in
    PREC_BITWISE_OR,     // |
    PREC_BITWISE_XOR,    // ^
    PREC_BITWISE_AND,    // &
    PREC_BITWISE_SHIFT,  // << >>
    PREC_TERM,           // + -
    PREC_FACTOR,         // * / % // @
    PREC_UNARY,          // - not ~
    PREC_EXPONENT,       // **
    PREC_PRIMARY,        // f() x[] a.b 1:2
    PREC_HIGHEST,
};

Error* Lexer__process(SourceData_ src, Token** out_tokens, int* out_length);

#define Token__sv(self) (c11_sv){(self)->start, (self)->length}

// compiler/compiler.h


Error* pk_compile(SourceData_ src, CodeObject* out);

// src/interpreter/objectpool.c
#include <assert.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

static PoolArena* PoolArena__new(int block_size) {
    assert(kPoolArenaSize % block_size == 0);
    int block_count = kPoolArenaSize / block_size;
    PoolArena* self = PK_MALLOC(sizeof(PoolArena) + sizeof(int) * block_count);
    self->block_size = block_size;
    self->block_count = block_count;
    self->unused_length = block_count;
    self->unused = PK_MALLOC(sizeof(int) * block_count);
    for(int i = 0; i < block_count; i++) {
        self->unused[i] = i;
    }
    memset(self->data, 0, kPoolArenaSize);
    return self;
}

static void PoolArena__delete(PoolArena* self) {
    for(int i = 0; i < self->block_count; i++) {
        PyObject* obj = (PyObject*)(self->data + i * self->block_size);
        if(obj->type != 0) PyObject__dtor(obj);
    }
    PK_FREE(self->unused);
    PK_FREE(self);
}

static void* PoolArena__alloc(PoolArena* self) {
    assert(self->unused_length > 0);
    int index = self->unused[self->unused_length - 1];
    self->unused_length--;
    return self->data + index * self->block_size;
}

static int PoolArena__sweep_dealloc(PoolArena* self) {
    int freed = 0;
    self->unused_length = 0;
    for(int i = 0; i < self->block_count; i++) {
        PyObject* obj = (PyObject*)(self->data + i * self->block_size);
        if(obj->type == 0) {
            // free slot
            self->unused[self->unused_length] = i;
            self->unused_length++;
        } else {
            if(!obj->gc_marked) {
                // not marked, need to free
                PyObject__dtor(obj);
                obj->type = 0;
                freed++;
                self->unused[self->unused_length] = i;
                self->unused_length++;
            } else {
                // marked, clear mark
                obj->gc_marked = false;
            }
        }
    }
    return freed;
}

static void Pool__ctor(Pool* self, int block_size) {
    c11_vector__ctor(&self->arenas, sizeof(PoolArena*));
    c11_vector__ctor(&self->no_free_arenas, sizeof(PoolArena*));
    self->block_size = block_size;
}

static void Pool__dtor(Pool* self) {
    c11__foreach(PoolArena*, &self->arenas, arena) PoolArena__delete(*arena);
    c11__foreach(PoolArena*, &self->no_free_arenas, arena) PoolArena__delete(*arena);
    c11_vector__dtor(&self->arenas);
    c11_vector__dtor(&self->no_free_arenas);
}

static void* Pool__alloc(Pool* self) {
    PoolArena* arena;
    if(self->arenas.length == 0) {
        arena = PoolArena__new(self->block_size);
        c11_vector__push(PoolArena*, &self->arenas, arena);
    } else {
        arena = c11_vector__back(PoolArena*, &self->arenas);
    }
    void* ptr = PoolArena__alloc(arena);
    if(arena->unused_length == 0) {
        c11_vector__pop(&self->arenas);
        c11_vector__push(PoolArena*, &self->no_free_arenas, arena);
    }
    return ptr;
}

static int Pool__sweep_dealloc(Pool* self, c11_vector* arenas, c11_vector* no_free_arenas) {
    c11_vector__clear(arenas);
    c11_vector__clear(no_free_arenas);

    int freed = 0;
    for(int i = 0; i < self->arenas.length; i++) {
        PoolArena* item = c11__getitem(PoolArena*, &self->arenas, i);
        assert(item->unused_length > 0);
        freed += PoolArena__sweep_dealloc(item);
        if(item->unused_length == item->block_count) {
            // all free
            if(arenas->length > 0) {
                // at least one arena
                PoolArena__delete(item);
            } else {
                // no arena
                c11_vector__push(PoolArena*, arenas, item);
            }
        } else {
            // some free
            c11_vector__push(PoolArena*, arenas, item);
        }
    }
    for(int i = 0; i < self->no_free_arenas.length; i++) {
        PoolArena* item = c11__getitem(PoolArena*, &self->no_free_arenas, i);
        freed += PoolArena__sweep_dealloc(item);
        if(item->unused_length == 0) {
            // still no free
            c11_vector__push(PoolArena*, no_free_arenas, item);
        } else {
            if(item->unused_length == item->block_count) {
                // all free
                PoolArena__delete(item);
            } else {
                // some free
                c11_vector__push(PoolArena*, arenas, item);
            }
        }
    }

    c11_vector__swap(&self->arenas, arenas);
    c11_vector__swap(&self->no_free_arenas, no_free_arenas);
    return freed;
}

void* MultiPool__alloc(MultiPool* self, int size) {
    if(size == 0) return NULL;
    int index = (size - 1) >> 5;
    if(index < kMultiPoolCount) {
        Pool* pool = &self->pools[index];
        return Pool__alloc(pool);
    }
    return NULL;
}

int MultiPool__sweep_dealloc(MultiPool* self) {
    c11_vector arenas;
    c11_vector no_free_arenas;
    c11_vector__ctor(&arenas, sizeof(PoolArena*));
    c11_vector__ctor(&no_free_arenas, sizeof(PoolArena*));
    int freed = 0;
    for(int i = 0; i < kMultiPoolCount; i++) {
        Pool* item = &self->pools[i];
        freed += Pool__sweep_dealloc(item, &arenas, &no_free_arenas);
    }
    c11_vector__dtor(&arenas);
    c11_vector__dtor(&no_free_arenas);
    return freed;
}

void MultiPool__ctor(MultiPool* self) {
    for(int i = 0; i < kMultiPoolCount; i++) {
        Pool__ctor(&self->pools[i], 32 * (i + 1));
    }
}

void MultiPool__dtor(MultiPool* self) {
    for(int i = 0; i < kMultiPoolCount; i++) {
        Pool__dtor(&self->pools[i]);
    }
}

c11_string* MultiPool__summary(MultiPool* self) {
    c11_sbuf sbuf;
    c11_sbuf__ctor(&sbuf);
    for(int i = 0; i < kMultiPoolCount; i++) {
        Pool* item = &self->pools[i];
        int total_bytes = (item->arenas.length + item->no_free_arenas.length) * kPoolArenaSize;
        int used_bytes = 0;
        for(int j = 0; j < item->arenas.length; j++) {
            PoolArena* arena = c11__getitem(PoolArena*, &item->arenas, j);
            used_bytes += (arena->block_count - arena->unused_length) * arena->block_size;
        }
        used_bytes += item->no_free_arenas.length * kPoolArenaSize;
        float used_pct = (float)used_bytes / total_bytes * 100;
        char buf[256];
        snprintf(buf,
                 sizeof(buf),
                 "Pool<%d>: len(arenas)=%d, len(no_free_arenas)=%d, %d/%d (%.1f%% used)",
                 item->block_size,
                 item->arenas.length,
                 item->no_free_arenas.length,
                 used_bytes,
                 total_bytes,
                 used_pct);
        c11_sbuf__write_cstr(&sbuf, buf);
        c11_sbuf__write_char(&sbuf, '\n');
    }
    return c11_sbuf__submit(&sbuf);
}

// src/interpreter/heap.c
void ManagedHeap__ctor(ManagedHeap* self) {
    MultiPool__ctor(&self->small_objects);
    c11_vector__ctor(&self->large_objects, sizeof(PyObject*));

    for(int i = 0; i < c11__count_array(self->freed_ma); i++) {
        self->freed_ma[i] = PK_GC_MIN_THRESHOLD;
    }
    self->gc_threshold = PK_GC_MIN_THRESHOLD;
    self->gc_counter = 0;
    self->gc_enabled = true;
}

void ManagedHeap__dtor(ManagedHeap* self) {
    // small_objects
    MultiPool__dtor(&self->small_objects);
    // large_objects
    for(int i = 0; i < self->large_objects.length; i++) {
        PyObject* obj = c11__getitem(PyObject*, &self->large_objects, i);
        PyObject__dtor(obj);
        PK_FREE(obj);
    }
    c11_vector__dtor(&self->large_objects);
}

void ManagedHeap__collect_if_needed(ManagedHeap* self) {
    if(!self->gc_enabled) return;
    if(self->gc_counter < self->gc_threshold) return;
    self->gc_counter = 0;
    int freed = ManagedHeap__collect(self);
    // adjust `gc_threshold` based on `freed_ma`
    self->freed_ma[0] = self->freed_ma[1];
    self->freed_ma[1] = self->freed_ma[2];
    self->freed_ma[2] = freed;
    int avg_freed = (self->freed_ma[0] + self->freed_ma[1] + self->freed_ma[2]) / 3;
    const int upper = PK_GC_MIN_THRESHOLD * 2;
    const int lower = PK_GC_MIN_THRESHOLD / 2;
    float free_ratio = (float)avg_freed / PK_GC_MIN_THRESHOLD;
    int new_threshold = self->gc_threshold * (1 / free_ratio);
    // printf("gc_threshold=%d, avg_freed=%d, new_threshold=%d\n", self->gc_threshold, avg_freed, new_threshold);
    self->gc_threshold = c11__min(c11__max(new_threshold, lower), upper);
}

int ManagedHeap__collect(ManagedHeap* self) {
    ManagedHeap__mark(self);
    int freed = ManagedHeap__sweep(self);
    return freed;
}

int ManagedHeap__sweep(ManagedHeap* self) {
    // small_objects
    int small_freed = MultiPool__sweep_dealloc(&self->small_objects);
    // large_objects
    int large_living_count = 0;
    for(int i = 0; i < self->large_objects.length; i++) {
        PyObject* obj = c11__getitem(PyObject*, &self->large_objects, i);
        if(obj->gc_marked) {
            obj->gc_marked = false;
            c11__setitem(PyObject*, &self->large_objects, large_living_count, obj);
            large_living_count++;
        } else {
            PyObject__dtor(obj);
            PK_FREE(obj);
        }
    }
    // shrink `self->large_objects`
    int large_freed = self->large_objects.length - large_living_count;
    self->large_objects.length = large_living_count;
    // printf("large_freed=%d\n", large_freed);
    // printf("small_freed=%d\n", small_freed);
    return small_freed + large_freed;
}

PyObject* ManagedHeap__gcnew(ManagedHeap* self, py_Type type, int slots, int udsize) {
    assert(slots >= 0 || slots == -1);
    PyObject* obj;
    // header + slots + udsize
    int size = sizeof(PyObject) + PK_OBJ_SLOTS_SIZE(slots) + udsize;
    if(!PK_LOW_MEMORY_MODE && size <= kPoolMaxBlockSize) {
        obj = MultiPool__alloc(&self->small_objects, size);
        assert(obj != NULL);
    } else {
        obj = PK_MALLOC(size);
        c11_vector__push(PyObject*, &self->large_objects, obj);
    }
    obj->type = type;
    obj->gc_marked = false;
    obj->slots = slots;

    // initialize slots or dict
    if(slots >= 0) {
        memset(obj->flex, 0, slots * sizeof(py_TValue));
    } else {
        NameDict__ctor((void*)obj->flex);
    }

    self->gc_counter++;
    return obj;
}
// src/interpreter/vm.c
#include <stdbool.h>

static char* pk_default_importfile(const char* path) {
#if PK_ENABLE_OS
    FILE* f = fopen(path, "rb");
    if(f == NULL) return NULL;
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    char* buffer = PK_MALLOC(size + 1);
    size = fread(buffer, 1, size, f);
    buffer[size] = 0;
    fclose(f);
    return buffer;
#else
    return NULL;
#endif
}

static void pk_default_print(const char* data) { printf("%s", data); }

static void py_TypeInfo__ctor(py_TypeInfo* self,
                              py_Name name,
                              py_Type index,
                              py_Type base,
                              py_TypeInfo* base_ti,
                              py_TValue module) {
    memset(self, 0, sizeof(py_TypeInfo));

    self->name = name;
    self->base = base;
    self->base_ti = base_ti;

    // create type object with __dict__
    ManagedHeap* heap = &pk_current_vm->heap;
    PyObject* typeobj = ManagedHeap__new(heap, tp_type, -1, sizeof(py_Type));
    *(py_Type*)PyObject__userdata(typeobj) = index;
    self->self = (py_TValue){
        .type = typeobj->type,
        .is_ptr = true,
        ._obj = typeobj,
    };

    self->module = module;
    self->annotations = *py_NIL();
}

void VM__ctor(VM* self) {
    self->top_frame = NULL;
    InternedNames__ctor(&self->names);

    ModuleDict__ctor(&self->modules, NULL, *py_NIL());
    TypeList__ctor(&self->types);

    self->builtins = *py_NIL();
    self->main = *py_NIL();

    self->callbacks.importfile = pk_default_importfile;
    self->callbacks.print = pk_default_print;
    self->callbacks.getchar = getchar;

    self->last_retval = *py_NIL();
    self->curr_exception = *py_NIL();

    self->recursion_depth = 0;
    self->max_recursion_depth = 1000;

    self->is_curr_exc_handled = false;

    self->ctx = NULL;
    self->curr_class = NULL;
    self->curr_decl_based_function = NULL;
    memset(&self->trace_info, 0, sizeof(TraceInfo));

    FixedMemoryPool__ctor(&self->pool_frame, sizeof(py_Frame), 32);

    ManagedHeap__ctor(&self->heap);
    ValueStack__ctor(&self->stack);

    /* Init Builtin Types */
    for(int i = 0; i < 128; i++) {
        char* p = py_newstrn(&self->ascii_literals[i], 1);
        *p = i;
    }
    py_newstrn(&self->ascii_literals[128], 0);  // empty string

    // 0: unused
    void* placeholder = TypeList__emplace(&self->types);
    memset(placeholder, 0, sizeof(py_TypeInfo));

#define validate(t, expr)                                                                          \
    if(t != (expr)) abort()

    validate(tp_object, pk_newtype("object", 0, NULL, NULL, true, false));
    validate(tp_type, pk_newtype("type", 1, NULL, NULL, false, true));
    pk_object__register();

    validate(tp_int, pk_newtype("int", tp_object, NULL, NULL, false, true));
    validate(tp_float, pk_newtype("float", tp_object, NULL, NULL, false, true));
    validate(tp_bool, pk_newtype("bool", tp_object, NULL, NULL, false, true));
    pk_number__register();

    validate(tp_str, pk_str__register());
    validate(tp_str_iterator, pk_str_iterator__register());

    validate(tp_list, pk_list__register());
    validate(tp_tuple, pk_tuple__register());
    validate(tp_array_iterator, pk_array_iterator__register());

    validate(tp_slice, pk_slice__register());
    validate(tp_range, pk_range__register());
    validate(tp_range_iterator, pk_range_iterator__register());
    validate(tp_module, pk_newtype("module", tp_object, NULL, NULL, false, true));

    validate(tp_function, pk_function__register());
    validate(tp_nativefunc, pk_nativefunc__register());
    validate(tp_boundmethod, pk_boundmethod__register());

    validate(tp_super, pk_super__register());
    validate(tp_BaseException, pk_BaseException__register());
    validate(tp_Exception, pk_Exception__register());
    validate(tp_bytes, pk_bytes__register());
    validate(tp_namedict, pk_namedict__register());
    validate(tp_locals, pk_newtype("locals", tp_object, NULL, NULL, false, true));
    validate(tp_code, pk_code__register());

    validate(tp_dict, pk_dict__register());
    validate(tp_dict_items, pk_dict_items__register());

    validate(tp_property, pk_property__register());
    validate(tp_star_wrapper, pk_newtype("star_wrapper", tp_object, NULL, NULL, false, true));

    validate(tp_staticmethod, pk_staticmethod__register());
    validate(tp_classmethod, pk_classmethod__register());

    validate(tp_NoneType, pk_newtype("NoneType", tp_object, NULL, NULL, false, true));
    validate(tp_NotImplementedType,
             pk_newtype("NotImplementedType", tp_object, NULL, NULL, false, true));
    validate(tp_ellipsis, pk_newtype("ellipsis", tp_object, NULL, NULL, false, true));
    validate(tp_generator, pk_generator__register());

    self->builtins = pk_builtins__register();

    // inject some builtin exceptions
#define INJECT_BUILTIN_EXC(name, TBase)                                                            \
    do {                                                                                           \
        py_Type type = pk_newtype(#name, TBase, &self->builtins, NULL, false, true);               \
        py_setdict(&self->builtins, py_name(#name), py_tpobject(type));                            \
        validate(tp_##name, type);                                                                 \
    } while(0)

    INJECT_BUILTIN_EXC(SystemExit, tp_BaseException);
    INJECT_BUILTIN_EXC(KeyboardInterrupt, tp_BaseException);

    validate(tp_StopIteration, pk_StopIteration__register());
    py_setdict(&self->builtins, py_name("StopIteration"), py_tpobject(tp_StopIteration));

    INJECT_BUILTIN_EXC(SyntaxError, tp_Exception);
    INJECT_BUILTIN_EXC(RecursionError, tp_Exception);
    INJECT_BUILTIN_EXC(OSError, tp_Exception);
    INJECT_BUILTIN_EXC(NotImplementedError, tp_Exception);
    INJECT_BUILTIN_EXC(TypeError, tp_Exception);
    INJECT_BUILTIN_EXC(IndexError, tp_Exception);
    INJECT_BUILTIN_EXC(ValueError, tp_Exception);
    INJECT_BUILTIN_EXC(RuntimeError, tp_Exception);
    INJECT_BUILTIN_EXC(ZeroDivisionError, tp_Exception);
    INJECT_BUILTIN_EXC(NameError, tp_Exception);
    INJECT_BUILTIN_EXC(UnboundLocalError, tp_Exception);
    INJECT_BUILTIN_EXC(AttributeError, tp_Exception);
    INJECT_BUILTIN_EXC(ImportError, tp_Exception);
    INJECT_BUILTIN_EXC(AssertionError, tp_Exception);
    INJECT_BUILTIN_EXC(KeyError, tp_Exception);

#undef INJECT_BUILTIN_EXC
#undef validate

    /* Setup Public Builtin Types */
    py_Type public_types[] = {
        tp_object,
        tp_type,
        tp_int,
        tp_float,
        tp_bool,
        tp_str,
        tp_list,
        tp_tuple,
        tp_slice,
        tp_range,
        tp_bytes,
        tp_dict,
        tp_property,
        tp_staticmethod,
        tp_classmethod,
        tp_super,
        tp_BaseException,
        tp_Exception,
    };

    for(int i = 0; i < c11__count_array(public_types); i++) {
        py_TypeInfo* ti = pk__type_info(public_types[i]);
        py_setdict(&self->builtins, ti->name, &ti->self);
    }

    py_newnotimplemented(py_emplacedict(&self->builtins, py_name("NotImplemented")));

    pk__add_module_linalg();
    pk__add_module_array2d();
    pk__add_module_colorcvt();

    // add modules
    pk__add_module_os();
    pk__add_module_sys();
    pk__add_module_io();
    pk__add_module_math();
    pk__add_module_dis();
    pk__add_module_random();
    pk__add_module_json();
    pk__add_module_gc();
    pk__add_module_time();
    pk__add_module_easing();
    pk__add_module_traceback();
    pk__add_module_enum();
    pk__add_module_inspect();
    pk__add_module_pickle();
    pk__add_module_base64();
    pk__add_module_importlib();

    pk__add_module_conio();
    pk__add_module_lz4();    // optional
    pk__add_module_libhv();  // optional
    pk__add_module_pkpy();

    // add python builtins
    do {
        bool ok;
        ok = py_exec(kPythonLibs_builtins, "<builtins>", EXEC_MODE, &self->builtins);
        if(!ok) goto __ABORT;
        break;
    __ABORT:
        py_printexc();
        c11__abort("failed to load python builtins!");
    } while(0);

    self->main = *py_newmodule("__main__");
}

void VM__dtor(VM* self) {
    // destroy all objects
    ManagedHeap__dtor(&self->heap);
    // clear frames
    while(self->top_frame)
        VM__pop_frame(self);
    ModuleDict__dtor(&self->modules);
    TypeList__dtor(&self->types);
    FixedMemoryPool__dtor(&self->pool_frame);
    ValueStack__dtor(&self->stack);
    InternedNames__dtor(&self->names);
}

void VM__push_frame(VM* self, py_Frame* frame) {
    frame->f_back = self->top_frame;
    self->top_frame = frame;
    self->recursion_depth++;
    if(self->trace_info.func) self->trace_info.func(frame, TRACE_EVENT_PUSH);
}

void VM__pop_frame(VM* self) {
    assert(self->top_frame);
    py_Frame* frame = self->top_frame;
    if(self->trace_info.func) self->trace_info.func(frame, TRACE_EVENT_POP);
    // reset stack pointer
    self->stack.sp = frame->p0;
    // pop frame and delete
    self->top_frame = frame->f_back;
    Frame__delete(frame);
    self->recursion_depth--;
}

static void _clip_int(int* value, int min, int max) {
    if(*value < min) *value = min;
    if(*value > max) *value = max;
}

bool pk__parse_int_slice(py_Ref slice,
                         int length,
                         int* restrict start,
                         int* restrict stop,
                         int* restrict step) {
    if(py_isint(slice)) {
        int index = py_toint(slice);
        bool ok = pk__normalize_index(&index, length);
        if(!ok) return false;
        *start = index;
        *stop = index + 1;
        *step = 1;
        return true;
    }

    if(!py_istype(slice, tp_slice)) c11__abort("pk__parse_int_slice(): not a slice object");

    py_Ref s_start = py_getslot(slice, 0);
    py_Ref s_stop = py_getslot(slice, 1);
    py_Ref s_step = py_getslot(slice, 2);

    if(py_isnone(s_step))
        *step = 1;
    else {
        if(!py_checkint(s_step)) return false;
        *step = py_toint(s_step);
    }
    if(*step == 0) return ValueError("slice step cannot be zero");

    if(*step > 0) {
        if(py_isnone(s_start))
            *start = 0;
        else {
            if(!py_checkint(s_start)) return false;
            *start = py_toint(s_start);
            if(*start < 0) *start += length;
            _clip_int(start, 0, length);
        }
        if(py_isnone(s_stop))
            *stop = length;
        else {
            if(!py_checkint(s_stop)) return false;
            *stop = py_toint(s_stop);
            if(*stop < 0) *stop += length;
            _clip_int(stop, 0, length);
        }
    } else {
        if(py_isnone(s_start))
            *start = length - 1;
        else {
            if(!py_checkint(s_start)) return false;
            *start = py_toint(s_start);
            if(*start < 0) *start += length;
            _clip_int(start, -1, length - 1);
        }
        if(py_isnone(s_stop))
            *stop = -1;
        else {
            if(!py_checkint(s_stop)) return false;
            *stop = py_toint(s_stop);
            if(*stop < 0) *stop += length;
            _clip_int(stop, -1, length - 1);
        }
    }
    return true;
}

bool pk__normalize_index(int* index, int length) {
    if(*index < 0) *index += length;
    if(*index < 0 || *index >= length) return IndexError("%d not in [0, %d)", *index, length);
    return true;
}

py_Type pk_newtype(const char* name,
                   py_Type base,
                   const py_GlobalRef module,
                   void (*dtor)(void*),
                   bool is_python,
                   bool is_sealed) {
    py_Type index = pk_current_vm->types.length;
    py_TypeInfo* ti = TypeList__emplace(&pk_current_vm->types);
    py_TypeInfo* base_ti = base ? pk__type_info(base) : NULL;
    if(base_ti && base_ti->is_sealed) {
        c11__abort("type '%s' is not an acceptable base type", py_name2str(base_ti->name));
    }
    py_TypeInfo__ctor(ti, py_name(name), index, base, base_ti, module ? *module : *py_NIL());
    if(!dtor && base) dtor = base_ti->dtor;
    ti->dtor = dtor;
    ti->is_python = is_python;
    ti->is_sealed = is_sealed;
    return index;
}

py_Type py_newtype(const char* name, py_Type base, const py_GlobalRef module, void (*dtor)(void*)) {
    py_Type type = pk_newtype(name, base, module, dtor, false, false);
    if(module) py_setdict(module, py_name(name), py_tpobject(type));
    return type;
}

static bool
    prepare_py_call(py_TValue* buffer, py_Ref argv, py_Ref p1, int kwargc, const FuncDecl* decl) {
    const CodeObject* co = &decl->code;
    int decl_argc = decl->args.length;

    if(p1 - argv < decl_argc) {
        return TypeError("%s() takes %d positional arguments but %d were given",
                         co->name->data,
                         decl_argc,
                         (int)(p1 - argv));
    }

    py_TValue* t = argv;
    // prepare args
    memset(buffer, 0, co->nlocals * sizeof(py_TValue));
    c11__foreach(int, &decl->args, index) buffer[*index] = *t++;
    // prepare kwdefaults
    c11__foreach(FuncDeclKwArg, &decl->kwargs, kv) buffer[kv->index] = kv->value;

    // handle *args
    if(decl->starred_arg != -1) {
        int exceed_argc = p1 - t;
        py_Ref vargs = &buffer[decl->starred_arg];
        py_Ref data = py_newtuple(vargs, exceed_argc);
        for(int j = 0; j < exceed_argc; j++) {
            data[j] = *t++;
        }
    } else {
        // kwdefaults override
        // def f(a, b, c=None)
        // f(1, 2, 3) -> c=3
        c11__foreach(FuncDeclKwArg, &decl->kwargs, kv) {
            if(t >= p1) break;
            buffer[kv->index] = *t++;
        }
        // not able to consume all args
        if(t < p1) return TypeError("too many arguments (%s)", co->name->data);
    }

    if(decl->starred_kwarg != -1) py_newdict(&buffer[decl->starred_kwarg]);

    for(int j = 0; j < kwargc; j++) {
        py_Name key = py_toint(&p1[2 * j]);
        int index = c11_smallmap_n2i__get(&decl->kw_to_index, key, -1);
        // if key is an explicit key, set as local variable
        if(index >= 0) {
            buffer[index] = p1[2 * j + 1];
        } else {
            // otherwise, set as **kwargs if possible
            if(decl->starred_kwarg == -1) {
                return TypeError("'%n' is an invalid keyword argument for %s()",
                                 key,
                                 co->name->data);
            } else {
                // add to **kwargs
                bool ok =
                    py_dict_setitem(&buffer[decl->starred_kwarg], py_name2ref(key), &p1[2 * j + 1]);
                if(!ok) return false;
            }
        }
    }
    return true;
}

FrameResult VM__vectorcall(VM* self, uint16_t argc, uint16_t kwargc, bool opcall) {
#ifndef NDEBUG
    pk_print_stack(self, self->top_frame, (Bytecode){0});
#endif

    py_Ref p1 = self->stack.sp - kwargc * 2;
    py_Ref p0 = p1 - argc - 2;
    // [callable, <self>, args..., kwargs...]
    //      ^p0                    ^p1      ^_sp

    // handle boundmethod, do a patch
    if(p0->type == tp_boundmethod) {
        assert(py_isnil(p0 + 1));  // self must be NULL
        py_TValue* slots = PyObject__slots(p0->_obj);
        p0[0] = slots[1];  // callable
        p0[1] = slots[0];  // self
        // [unbound, self, args..., kwargs...]
    }

    py_Ref argv = p0 + 1 + (int)py_isnil(p0 + 1);

    if(p0->type == tp_function) {
        Function* fn = py_touserdata(p0);
        const CodeObject* co = &fn->decl->code;

        switch(fn->decl->type) {
            case FuncType_NORMAL: {
                bool ok = prepare_py_call(self->vectorcall_buffer, argv, p1, kwargc, fn->decl);
                if(!ok) return RES_ERROR;
                // copy buffer back to stack
                self->stack.sp = argv + co->nlocals;
                memcpy(argv, self->vectorcall_buffer, co->nlocals * sizeof(py_TValue));
                // submit the call
                if(!fn->cfunc) {
                    // python function
                    VM__push_frame(self, Frame__new(co, p0, fn->module, fn->globals, argv, false));
                    return opcall ? RES_CALL : VM__run_top_frame(self);
                } else {
                    // decl-based binding
                    self->curr_decl_based_function = p0;
                    bool ok = py_callcfunc(fn->cfunc, co->nlocals, argv);
                    self->stack.sp = p0;
                    self->curr_decl_based_function = NULL;
                    return ok ? RES_RETURN : RES_ERROR;
                }
            }
            case FuncType_SIMPLE:
                if(p1 - argv != fn->decl->args.length) {
                    const char* fmt = "%s() takes %d positional arguments but %d were given";
                    TypeError(fmt, co->name->data, fn->decl->args.length, (int)(p1 - argv));
                    return RES_ERROR;
                }
                if(kwargc) {
                    TypeError("%s() takes no keyword arguments", co->name->data);
                    return RES_ERROR;
                }
                // [callable, <self>, args..., local_vars...]
                //      ^p0                    ^p1      ^_sp
                self->stack.sp = argv + co->nlocals;
                // initialize local variables to py_NIL
                memset(p1, 0, (char*)self->stack.sp - (char*)p1);
                // submit the call
                if(!fn->cfunc) {
                    // python function
                    VM__push_frame(self, Frame__new(co, p0, fn->module, fn->globals, argv, false));
                    return opcall ? RES_CALL : VM__run_top_frame(self);
                } else {
                    // decl-based binding
                    self->curr_decl_based_function = p0;
                    bool ok = py_callcfunc(fn->cfunc, co->nlocals, argv);
                    self->stack.sp = p0;
                    self->curr_decl_based_function = NULL;
                    return ok ? RES_RETURN : RES_ERROR;
                }
            case FuncType_GENERATOR: {
                bool ok = prepare_py_call(self->vectorcall_buffer, argv, p1, kwargc, fn->decl);
                if(!ok) return RES_ERROR;
                // copy buffer back to stack
                self->stack.sp = argv + co->nlocals;
                memcpy(argv, self->vectorcall_buffer, co->nlocals * sizeof(py_TValue));
                py_Frame* frame = Frame__new(co, p0, fn->module, fn->globals, argv, false);
                pk_newgenerator(py_retval(), frame, p0, self->stack.sp);
                self->stack.sp = p0;  // reset the stack
                return RES_RETURN;
            }
            default: c11__unreachable();
        };

        c11__unreachable();
        /*****************_py_call*****************/
    }

    if(p0->type == tp_nativefunc) {
        if(kwargc && p0->_cfunc != pk__object_new) {
            TypeError("nativefunc does not accept keyword arguments");
            return RES_ERROR;
        }
        bool ok = py_callcfunc(p0->_cfunc, p1 - argv, argv);
        self->stack.sp = p0;
        return ok ? RES_RETURN : RES_ERROR;
    }

    if(p0->type == tp_type) {
        // [cls, NULL, args..., kwargs...]
        py_Ref new_f = py_tpfindmagic(py_totype(p0), __new__);
        assert(new_f && py_isnil(p0 + 1));

        // prepare a copy of args and kwargs
        int span = self->stack.sp - argv;
        *self->stack.sp++ = *new_f;  // push __new__
        *self->stack.sp++ = *p0;     // push cls
        memcpy(self->stack.sp, argv, span * sizeof(py_TValue));
        self->stack.sp += span;
        // [new_f, cls, args..., kwargs...]
        if(VM__vectorcall(self, argc, kwargc, false) == RES_ERROR) return RES_ERROR;
        // by recursively using vectorcall, args and kwargs are consumed

        // try __init__
        // NOTE: previously we use `get_unbound_method` but here we just use `tpfindmagic`
        // >> [cls, NULL, args..., kwargs...]
        // >> py_retval() is the new instance
        py_Ref init_f = py_tpfindmagic(py_totype(p0), __init__);
        if(init_f) {
            // do an inplace patch
            *p0 = *init_f;              // __init__
            p0[1] = self->last_retval;  // self
            // [__init__, self, args..., kwargs...]
            if(VM__vectorcall(self, argc, kwargc, false) == RES_ERROR) return RES_ERROR;
            *py_retval() = p0[1];  // restore the new instance
        }
        // reset the stack
        self->stack.sp = p0;
        return RES_RETURN;
    }

    // handle `__call__` overload
    if(pk_loadmethod(p0, __call__)) {
        // [__call__, self, args..., kwargs...]
        return VM__vectorcall(self, argc, kwargc, opcall);
    }

    TypeError("'%t' object is not callable", p0->type);
    return RES_ERROR;
}

/****************************************/
void PyObject__dtor(PyObject* self) {
    py_TypeInfo* ti = pk__type_info(self->type);
    if(ti->dtor) ti->dtor(PyObject__userdata(self));
    if(self->slots == -1) NameDict__dtor(PyObject__dict(self));
}

void PyObject__mark(PyObject* obj) {
    assert(!obj->gc_marked);

    obj->gc_marked = true;

    if(obj->slots > 0) {
        py_TValue* p = PyObject__slots(obj);
        for(int i = 0; i < obj->slots; i++)
            pk__mark_value(p + i);
    } else if(obj->slots == -1) {
        NameDict* namedict = PyObject__dict(obj);
        for(int i = 0; i < namedict->length; i++) {
            NameDict_KV* kv = c11__at(NameDict_KV, namedict, i);
            pk__mark_value(&kv->value);
        }
    }

    void* ud = PyObject__userdata(obj);
    switch(obj->type) {
        case tp_list: {
            List* self = ud;
            for(int i = 0; i < self->length; i++) {
                pk__mark_value(c11__at(py_TValue, self, i));
            }
            break;
        }
        case tp_dict: {
            Dict* self = ud;
            for(int i = 0; i < self->entries.length; i++) {
                DictEntry* entry = c11__at(DictEntry, &self->entries, i);
                if(py_isnil(&entry->key)) continue;
                pk__mark_value(&entry->key);
                pk__mark_value(&entry->val);
            }
            break;
        }
        case tp_generator: {
            Generator* self = ud;
            if(self->frame) Frame__gc_mark(self->frame);
            break;
        }
        case tp_function: {
            function__gc_mark(ud);
            break;
        }
        case tp_code: {
            CodeObject* self = ud;
            CodeObject__gc_mark(self);
            break;
        }
        case tp_chunked_array2d: {
            c11_chunked_array2d__mark(ud);
        }
        default: return;
    }
}

void FuncDecl__gc_mark(const FuncDecl* self) {
    CodeObject__gc_mark(&self->code);
    for(int j = 0; j < self->kwargs.length; j++) {
        FuncDeclKwArg* kw = c11__at(FuncDeclKwArg, &self->kwargs, j);
        pk__mark_value(&kw->value);
    }
}

void CodeObject__gc_mark(const CodeObject* self) {
    for(int i = 0; i < self->consts.length; i++) {
        py_TValue* p = c11__at(py_TValue, &self->consts, i);
        pk__mark_value(p);
    }
    for(int i = 0; i < self->func_decls.length; i++) {
        FuncDecl_ decl = c11__getitem(FuncDecl_, &self->func_decls, i);
        FuncDecl__gc_mark(decl);
    }
}

void ManagedHeap__mark(ManagedHeap* self) {
    VM* vm = pk_current_vm;
    // mark value stack
    for(py_TValue* p = vm->stack.begin; p != vm->stack.end; p++) {
        pk__mark_value(p);
    }
    // mark ascii literals
    for(int i = 0; i < c11__count_array(vm->ascii_literals); i++) {
        pk__mark_value(&vm->ascii_literals[i]);
    }
    // mark modules
    ModuleDict__apply_mark(&vm->modules);
    // mark types
    int types_length = vm->types.length;
    // 0-th type is placeholder
    for(py_Type i = 1; i < types_length; i++) {
        py_TypeInfo* ti = TypeList__get(&vm->types, i);
        // mark type object
        pk__mark_value(&ti->self);
        // mark common magic slots
        for(int j = 0; j < PK_MAGIC_SLOTS_COMMON_LENGTH; j++) {
            py_TValue* slot = ti->magic_0 + j;
            if(py_isnil(slot)) continue;
            pk__mark_value(slot);
        }
        // mark uncommon magic slots
        if(ti->magic_1) {
            for(int j = 0; j < PK_MAGIC_SLOTS_UNCOMMON_LENGTH; j++) {
                py_TValue* slot = ti->magic_1 + j;
                if(py_isnil(slot)) continue;
                pk__mark_value(slot);
            }
        }
        // mark type annotations
        pk__mark_value(&ti->annotations);
    }
    // mark frame
    for(py_Frame* frame = vm->top_frame; frame; frame = frame->f_back) {
        Frame__gc_mark(frame);
    }
    // mark vm's registers
    pk__mark_value(&vm->last_retval);
    pk__mark_value(&vm->curr_exception);
    for(int i = 0; i < c11__count_array(vm->reg); i++) {
        pk__mark_value(&vm->reg[i]);
    }
    // mark interned names
    for(int i = 0; i < vm->names.r_interned.length; i++) {
        RInternedEntry* entry = c11__at(RInternedEntry, &vm->names.r_interned, i);
        pk__mark_value(&entry->obj);
    }
}

void pk_print_stack(VM* self, py_Frame* frame, Bytecode byte) {
    return;
    if(frame == NULL || py_isnil(&self->main)) return;

    py_TValue* sp = self->stack.sp;
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    for(py_Ref p = self->stack.begin; p != sp; p++) {
        switch(p->type) {
            case tp_nil: c11_sbuf__write_cstr(&buf, "nil"); break;
            case tp_int: c11_sbuf__write_i64(&buf, p->_i64); break;
            case tp_float: c11_sbuf__write_f64(&buf, p->_f64, -1); break;
            case tp_bool: c11_sbuf__write_cstr(&buf, p->_bool ? "True" : "False"); break;
            case tp_NoneType: c11_sbuf__write_cstr(&buf, "None"); break;
            case tp_list: {
                pk_sprintf(&buf, "list(%d)", py_list_len(p));
                break;
            }
            case tp_tuple: {
                pk_sprintf(&buf, "tuple(%d)", py_tuple_len(p));
                break;
            }
            case tp_function: {
                Function* ud = py_touserdata(p);
                c11_sbuf__write_cstr(&buf, ud->decl->code.name->data);
                c11_sbuf__write_cstr(&buf, "()");
                break;
            }
            case tp_type: {
                pk_sprintf(&buf, "<class '%t'>", py_totype(p));
                break;
            }
            case tp_str: {
                pk_sprintf(&buf, "%q", py_tosv(p));
                break;
            }
            case tp_module: {
                py_Ref path = py_getdict(p, __path__);
                pk_sprintf(&buf, "<module '%v'>", py_tosv(path));
                break;
            }
            default: {
                pk_sprintf(&buf, "(%t)", p->type);
                break;
            }
        }
        if(p != &sp[-1]) c11_sbuf__write_cstr(&buf, ", ");
    }
    c11_string* stack_str = c11_sbuf__submit(&buf);

    printf("%s:%-3d: %-25s %-6d [%s]\n",
           frame->co->src->filename->data,
           Frame__lineno(frame),
           pk_opname(byte.op),
           byte.arg,
           stack_str->data);
    c11_string__delete(stack_str);
}

bool pk_wrapper__self(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_assign(py_retval(), argv);
    return true;
}

py_TypeInfo* pk__type_info(py_Type type) { return TypeList__get(&pk_current_vm->types, type); }

int py_replinput(char* buf, int max_size) {
    buf[0] = '\0';  // reset first char because we check '@' at the beginning

    int size = 0;
    bool multiline = false;
    printf(">>> ");

    while(true) {
        int c = pk_current_vm->callbacks.getchar();
        if(c == EOF) return -1;

        if(c == '\n') {
            char last = '\0';
            if(size > 0) last = buf[size - 1];
            if(multiline) {
                if(last == '\n') {
                    break;  // 2 consecutive newlines to end multiline input
                } else {
                    printf("... ");
                }
            } else {
                if(last == ':' || last == '(' || last == '[' || last == '{' || buf[0] == '@') {
                    printf("... ");
                    multiline = true;
                } else {
                    break;
                }
            }
        }

        if(size == max_size - 1) {
            buf[size] = '\0';
            return size;
        }

        buf[size++] = c;
    }

    buf[size] = '\0';
    return size;
}
// src/interpreter/typeinfo.c
#define CHUNK_SIZE 128
#define LOG2_CHUNK_SIZE 7

void TypeList__ctor(TypeList* self) {
    self->length = 0;
    memset(self->chunks, 0, sizeof(self->chunks));
}

void TypeList__dtor(TypeList* self) {
    for(py_Type t = 0; t < self->length; t++) {
        py_TypeInfo* info = TypeList__get(self, t);
        if(info->magic_1) PK_FREE(info->magic_1);
    }
    for(int i = 0; i < PK_MAX_CHUNK_LENGTH; i++) {
        if(self->chunks[i]) PK_FREE(self->chunks[i]);
    }
}

py_TypeInfo* TypeList__get(TypeList* self, py_Type index) {
    assert(index < self->length);
    int chunk = index >> LOG2_CHUNK_SIZE;
    int offset = index & (CHUNK_SIZE - 1);
    return self->chunks[chunk] + offset;
}

py_TypeInfo* TypeList__emplace(TypeList* self) {
    int chunk = self->length >> LOG2_CHUNK_SIZE;
    int offset = self->length & (CHUNK_SIZE - 1);
    if(self->chunks[chunk] == NULL) {
        if(chunk >= PK_MAX_CHUNK_LENGTH) {
            c11__abort("TypeList__emplace(): max chunk length exceeded");
        }
        self->chunks[chunk] = PK_MALLOC(sizeof(py_TypeInfo) * CHUNK_SIZE);
        memset(self->chunks[chunk], 0, sizeof(py_TypeInfo) * CHUNK_SIZE);
    }
    self->length++;
    return self->chunks[chunk] + offset;
}

void TypeList__apply(TypeList* self, void (*f)(py_TypeInfo*, void*), void* ctx) {
    for(int i = 0; i < self->length; i++) {
        py_TypeInfo* info = TypeList__get(self, i);
        f(info, ctx);
    }
}

py_TValue* TypeList__magic(py_TypeInfo* self, unsigned index) {
    if(index > __xor__) {
        // common magic slots
        return TypeList__magic_common(self, index);
    }
    // uncommon magic slots
    if(self->magic_1 == NULL) {
        self->magic_1 = PK_MALLOC(sizeof(py_TValue) * PK_MAGIC_SLOTS_UNCOMMON_LENGTH);
        memset(self->magic_1, 0, sizeof(py_TValue) * PK_MAGIC_SLOTS_UNCOMMON_LENGTH);
    }
    return self->magic_1 + index;
}

py_TValue* TypeList__magic_readonly(py_TypeInfo* self, unsigned index) {
    if(index > __xor__) {
        // common magic slots
        return TypeList__magic_common(self, index);
    }
    // uncommon magic slots
    if(self->magic_1 == NULL) return py_NIL();
    return self->magic_1 + index;
}

#undef CHUNK_SIZE
#undef LOG2_CHUNK_SIZE
// src/interpreter/generator.c
#include <stdbool.h>

void pk_newgenerator(py_Ref out, py_Frame* frame, py_TValue* begin, py_TValue* end) {
    Generator* ud = py_newobject(out, tp_generator, 1, sizeof(Generator));
    ud->frame = frame;
    ud->state = 0;
    py_Ref tmp = py_getslot(out, 0);
    py_newlist(tmp);
    for(py_TValue* p = begin; p != end; p++) {
        py_list_append(tmp, p);
    }
}

void Generator__dtor(Generator* ud) {
    if(ud->frame) Frame__delete(ud->frame);
}

static bool generator__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Generator* ud = py_touserdata(argv);
    py_StackRef p0 = py_peek(0);
    VM* vm = pk_current_vm;
    if(ud->state == 2) return StopIteration();

    // reset frame->p0
    assert(!ud->frame->is_locals_special);
    int locals_offset = ud->frame->locals - ud->frame->p0;
    ud->frame->p0 = py_peek(0);
    ud->frame->locals = ud->frame->p0 + locals_offset;
    
    // restore the context
    py_Ref backup = py_getslot(argv, 0);
    int length = py_list_len(backup);
    py_TValue* p = py_list_data(backup);
    for(int i = 0; i < length; i++)
        py_push(&p[i]);
    py_list_clear(backup);

    // push frame
    VM__push_frame(vm, ud->frame);
    ud->frame = NULL;

    FrameResult res = VM__run_top_frame(vm);

    if(res == RES_ERROR) {
        ud->state = 2;  // end this generator immediately on error
        if(py_matchexc(tp_StopIteration)) {
            py_clearexc(p0);
            return true;
        }
        return false;
    }

    if(res == RES_YIELD) {
        // backup the context
        ud->frame = vm->top_frame;
        for(py_StackRef p = ud->frame->p0; p != vm->stack.sp; p++) {
            py_list_append(backup, p);
        }
        vm->stack.sp = ud->frame->p0;
        vm->top_frame = vm->top_frame->f_back;
        vm->recursion_depth--;
        ud->state = 1;
        return true;
    } else {
        assert(res == RES_RETURN);
        ud->state = 2;
        // raise StopIteration(<retval>)
        bool ok = py_tpcall(tp_StopIteration, 1, py_retval());
        if(!ok) return false;
        return py_raise(py_retval());
    }
}

py_Type pk_generator__register() {
    py_Type type = pk_newtype("generator", tp_object, NULL, (py_Dtor)Generator__dtor, false, true);
    py_bindmagic(type, __iter__, pk_wrapper__self);
    py_bindmagic(type, __next__, generator__next__);
    return type;
}

// src/interpreter/ceval.c
#include <stdbool.h>

static bool stack_format_object(VM* self, c11_sv spec);

#define CHECK_RETURN_FROM_EXCEPT_OR_FINALLY()                                                      \
    if(self->is_curr_exc_handled) py_clearexc(NULL)

#define DISPATCH()                                                                                 \
    do {                                                                                           \
        frame->ip++;                                                                               \
        goto __NEXT_STEP;                                                                          \
    } while(0)
#define DISPATCH_JUMP(__offset)                                                                    \
    do {                                                                                           \
        frame->ip += __offset;                                                                     \
        goto __NEXT_STEP;                                                                          \
    } while(0)
#define DISPATCH_JUMP_ABSOLUTE(__target)                                                           \
    do {                                                                                           \
        frame->ip = __target;                                                                      \
        goto __NEXT_STEP;                                                                          \
    } while(0)

/* Stack manipulation macros */
// https://github.com/python/cpython/blob/3.9/Python/ceval.c#L1123
#define TOP() (self->stack.sp - 1)
#define SECOND() (self->stack.sp - 2)
#define THIRD() (self->stack.sp - 3)
#define FOURTH() (self->stack.sp - 4)
#define STACK_SHRINK(n) (self->stack.sp -= n)
#define STACK_GROW(n) (self->stack.sp += n)
#define PUSH(v)                                                                                    \
    do {                                                                                           \
        *self->stack.sp = *(v);                                                                    \
        self->stack.sp++;                                                                          \
    } while(0)
#define POP() (--self->stack.sp)
#define POPX() (*--self->stack.sp)
#define SP() (self->stack.sp)

// [a, b] -> [?, a, b]
#define INSERT_THIRD()                                                                             \
    do {                                                                                           \
        PUSH(TOP());                                                                               \
        *SECOND() = *THIRD();                                                                      \
    } while(0)

// Must use a DISPATCH() after vectorcall_opcall() immediately!
#define vectorcall_opcall(argc, kwargc)                                                            \
    do {                                                                                           \
        FrameResult res = VM__vectorcall(self, (argc), (kwargc), true);                            \
        switch(res) {                                                                              \
            case RES_RETURN: PUSH(&self->last_retval); break;                                      \
            case RES_CALL: frame = self->top_frame; goto __NEXT_FRAME;                             \
            case RES_ERROR: goto __ERROR;                                                          \
            default: c11__unreachable();                                                           \
        }                                                                                          \
    } while(0)

static bool unpack_dict_to_buffer(py_Ref key, py_Ref val, void* ctx) {
    py_TValue** p = ctx;
    if(py_isstr(key)) {
        py_Name name = py_namev(py_tosv(key));
        py_newint(*p, name);
        py_assign(*p + 1, val);
        (*p) += 2;
        return true;
    }
    return TypeError("keywords must be strings, not '%t'", key->type);
}

FrameResult VM__run_top_frame(VM* self) {
    py_Frame* frame = self->top_frame;
    Bytecode* codes;

    const py_Frame* base_frame = frame;

    while(true) {
        Bytecode byte;
    __NEXT_FRAME:
        if(self->recursion_depth >= self->max_recursion_depth) {
            py_exception(tp_RecursionError, "maximum recursion depth exceeded");
            goto __ERROR;
        }
        codes = frame->co->codes.data;
        frame->ip++;

    __NEXT_STEP:
        byte = codes[frame->ip];

        if(self->trace_info.func) {
            SourceLocation loc = Frame__source_location(frame);
            SourceLocation prev_loc = self->trace_info.prev_loc;
            if(loc.lineno != prev_loc.lineno || loc.src != prev_loc.src) {
                if(prev_loc.src) PK_DECREF(prev_loc.src);
                PK_INCREF(loc.src);
                self->trace_info.prev_loc = loc;
                self->trace_info.func(frame, TRACE_EVENT_LINE);
            }
        }

#ifndef NDEBUG
        pk_print_stack(self, frame, byte);
#endif

        switch((Opcode)byte.op) {
            case OP_NO_OP: DISPATCH();
            /*****************************************/
            case OP_POP_TOP: POP(); DISPATCH();
            case OP_DUP_TOP: PUSH(TOP()); DISPATCH();
            case OP_DUP_TOP_TWO:
                // [a, b]
                PUSH(SECOND());  // [a, b, a]
                PUSH(SECOND());  // [a, b, a, b]
                DISPATCH();
            case OP_ROT_TWO: {
                py_TValue tmp = *TOP();
                *TOP() = *SECOND();
                *SECOND() = tmp;
                DISPATCH();
            }
            case OP_ROT_THREE: {
                // [a, b, c] -> [c, a, b]
                py_TValue tmp = *TOP();
                *TOP() = *SECOND();
                *SECOND() = *THIRD();
                *THIRD() = tmp;
                DISPATCH();
            }
            case OP_PRINT_EXPR:
                if(TOP()->type != tp_NoneType) {
                    bool ok = py_repr(TOP());
                    if(!ok) goto __ERROR;
                    self->callbacks.print(py_tostr(&self->last_retval));
                    self->callbacks.print("\n");
                }
                POP();
                DISPATCH();
            /*****************************************/
            case OP_LOAD_CONST: {
                PUSH(c11__at(py_TValue, &frame->co->consts, byte.arg));
                DISPATCH();
            }
            case OP_LOAD_NONE: {
                py_newnone(SP()++);
                DISPATCH();
            }
            case OP_LOAD_TRUE: {
                py_newbool(SP()++, true);
                DISPATCH();
            }
            case OP_LOAD_FALSE: {
                py_newbool(SP()++, false);
                DISPATCH();
            }
            /*****************************************/
            case OP_LOAD_SMALL_INT: {
                py_newint(SP()++, (int16_t)byte.arg);
                DISPATCH();
            }
            /*****************************************/
            case OP_LOAD_ELLIPSIS: {
                py_newellipsis(SP()++);
                DISPATCH();
            }
            case OP_LOAD_FUNCTION: {
                FuncDecl_ decl = c11__getitem(FuncDecl_, &frame->co->func_decls, byte.arg);
                Function* ud = py_newobject(SP(), tp_function, 0, sizeof(Function));
                Function__ctor(ud, decl, frame->module, frame->globals);
                if(decl->nested) {
                    if(frame->is_locals_special) {
                        RuntimeError("cannot create closure from special locals");
                        goto __ERROR;
                    }
                    ud->closure = FastLocals__to_namedict(frame->locals, frame->co);
                    py_Name name = py_name(decl->code.name->data);
                    // capture itself to allow recursion
                    NameDict__set(ud->closure, name, *SP());
                }
                SP()++;
                DISPATCH();
            }
            case OP_LOAD_NULL:
                py_newnil(SP()++);
                DISPATCH();
                /*****************************************/
            case OP_LOAD_FAST: {
                assert(!frame->is_locals_special);
                py_Ref val = &frame->locals[byte.arg];
                if(!py_isnil(val)) {
                    PUSH(val);
                    DISPATCH();
                }
                py_Name name = c11__getitem(uint16_t, &frame->co->varnames, byte.arg);
                UnboundLocalError(name);
                goto __ERROR;
            }
            case OP_LOAD_NAME: {
                assert(frame->is_locals_special);
                py_Name name = byte.arg;
                // locals
                switch(frame->locals->type) {
                    case tp_locals: {
                        py_Frame* noproxy = frame->locals->_ptr;
                        py_Ref slot = Frame__getlocal_noproxy(noproxy, name);
                        if(slot == NULL) break;
                        if(py_isnil(slot)) {
                            UnboundLocalError(name);
                            goto __ERROR;
                        }
                        PUSH(slot);
                        DISPATCH();
                    }
                    case tp_dict: {
                        int res = py_dict_getitem(frame->locals, py_name2ref(name));
                        if(res == 1) {
                            PUSH(&self->last_retval);
                            DISPATCH();
                        }
                        if(res == 0) break;
                        assert(res == -1);
                        goto __ERROR;
                    }
                    case tp_nil: break;
                    default: c11__unreachable();
                }
                // globals
                int res = Frame__getglobal(frame, name);
                if(res == 1) {
                    PUSH(&self->last_retval);
                    DISPATCH();
                }
                if(res == -1) goto __ERROR;
                // builtins
                py_Ref tmp = py_getdict(&self->builtins, name);
                if(tmp != NULL) {
                    PUSH(tmp);
                    DISPATCH();
                }
                NameError(name);
                goto __ERROR;
            }
            case OP_LOAD_NONLOCAL: {
                py_Name name = byte.arg;
                py_Ref tmp = Frame__getclosure(frame, name);
                if(tmp != NULL) {
                    PUSH(tmp);
                    DISPATCH();
                }
                int res = Frame__getglobal(frame, name);
                if(res == 1) {
                    PUSH(&self->last_retval);
                    DISPATCH();
                }
                if(res == -1) goto __ERROR;

                tmp = py_getdict(&self->builtins, name);
                if(tmp != NULL) {
                    PUSH(tmp);
                    DISPATCH();
                }
                NameError(name);
                goto __ERROR;
            }
            case OP_LOAD_GLOBAL: {
                py_Name name = byte.arg;
                int res = Frame__getglobal(frame, name);
                if(res == 1) {
                    PUSH(&self->last_retval);
                    DISPATCH();
                }
                if(res == -1) goto __ERROR;
                py_Ref tmp = py_getdict(&self->builtins, name);
                if(tmp != NULL) {
                    PUSH(tmp);
                    DISPATCH();
                }
                NameError(name);
                goto __ERROR;
            }
            case OP_LOAD_ATTR: {
                if(py_getattr(TOP(), byte.arg)) {
                    py_assign(TOP(), py_retval());
                } else {
                    goto __ERROR;
                }
                DISPATCH();
            }
            case OP_LOAD_CLASS_GLOBAL: {
                assert(self->curr_class);
                py_Name name = byte.arg;
                py_Ref tmp = py_getdict(self->curr_class, name);
                if(tmp) {
                    PUSH(tmp);
                    DISPATCH();
                }
                // load global if attribute not found
                int res = Frame__getglobal(frame, name);
                if(res == 1) {
                    PUSH(&self->last_retval);
                    DISPATCH();
                }
                if(res == -1) goto __ERROR;
                tmp = py_getdict(&self->builtins, name);
                if(tmp) {
                    PUSH(tmp);
                    DISPATCH();
                }
                NameError(name);
                goto __ERROR;
            }
            case OP_LOAD_METHOD: {
                // [self] -> [unbound, self]
                bool ok = py_pushmethod(byte.arg);
                if(!ok) {
                    // fallback to getattr
                    if(py_getattr(TOP(), byte.arg)) {
                        py_assign(TOP(), py_retval());
                        py_newnil(SP()++);
                    } else {
                        goto __ERROR;
                    }
                }
                DISPATCH();
            }
            case OP_LOAD_SUBSCR: {
                // [a, b] -> a[b]
                py_Ref magic = py_tpfindmagic(SECOND()->type, __getitem__);
                if(magic) {
                    if(magic->type == tp_nativefunc) {
                        if(!py_callcfunc(magic->_cfunc, 2, SECOND())) goto __ERROR;
                        POP();
                        py_assign(TOP(), py_retval());
                    } else {
                        INSERT_THIRD();     // [?, a, b]
                        *THIRD() = *magic;  // [__getitem__, a, b]
                        vectorcall_opcall(1, 0);
                    }
                    DISPATCH();
                }
                TypeError("'%t' object is not subscriptable", SECOND()->type);
                goto __ERROR;
            }
            case OP_STORE_FAST: {
                assert(!frame->is_locals_special);
                frame->locals[byte.arg] = POPX();
                DISPATCH();
            }
            case OP_STORE_NAME: {
                assert(frame->is_locals_special);
                py_Name name = byte.arg;
                switch(frame->locals->type) {
                    case tp_locals: {
                        py_Frame* noproxy = frame->locals->_ptr;
                        py_Ref slot = Frame__getlocal_noproxy(noproxy, name);
                        if(slot == NULL) {
                            UnboundLocalError(name);
                            goto __ERROR;
                        }
                        *slot = POPX();
                        DISPATCH();
                    }
                    case tp_dict: {
                        if(!py_dict_setitem(frame->locals, py_name2ref(name), TOP())) goto __ERROR;
                        POP();
                        DISPATCH();
                    }
                    case tp_nil: {
                        // globals
                        if(!Frame__setglobal(frame, name, TOP())) goto __ERROR;
                        POP();
                        DISPATCH();
                    }
                    default: c11__unreachable();
                }
            }
            case OP_STORE_GLOBAL: {
                if(!Frame__setglobal(frame, byte.arg, TOP())) goto __ERROR;
                POP();
                DISPATCH();
            }
            case OP_STORE_ATTR: {
                // [val, a] -> a.b = val
                if(!py_setattr(TOP(), byte.arg, SECOND())) goto __ERROR;
                STACK_SHRINK(2);
                DISPATCH();
            }
            case OP_STORE_SUBSCR: {
                // [val, a, b] -> a[b] = val
                py_Ref magic = py_tpfindmagic(SECOND()->type, __setitem__);
                if(magic) {
                    PUSH(THIRD());  // [val, a, b, val]
                    if(magic->type == tp_nativefunc) {
                        if(!py_callcfunc(magic->_cfunc, 3, THIRD())) goto __ERROR;
                        STACK_SHRINK(4);
                    } else {
                        *FOURTH() = *magic;  // [__setitem__, a, b, val]
                        if(!py_vectorcall(2, 0)) goto __ERROR;
                    }
                    DISPATCH();
                }
                TypeError("'%t' object does not support item assignment", SECOND()->type);
                goto __ERROR;
            }
            case OP_DELETE_FAST: {
                assert(!frame->is_locals_special);
                py_Ref tmp = &frame->locals[byte.arg];
                if(py_isnil(tmp)) {
                    py_Name name = c11__getitem(py_Name, &frame->co->varnames, byte.arg);
                    UnboundLocalError(name);
                    goto __ERROR;
                }
                py_newnil(tmp);
                DISPATCH();
            }
            case OP_DELETE_NAME: {
                assert(frame->is_locals_special);
                py_Name name = byte.arg;
                switch(frame->locals->type) {
                    case tp_locals: {
                        py_Frame* noproxy = frame->locals->_ptr;
                        py_Ref slot = Frame__getlocal_noproxy(noproxy, name);
                        if(slot == NULL || py_isnil(slot)) {
                            UnboundLocalError(name);
                            goto __ERROR;
                        }
                        py_newnil(slot);
                        DISPATCH();
                    }
                    case tp_dict: {
                        int res = py_dict_delitem(frame->locals, py_name2ref(name));
                        if(res == 1) DISPATCH();
                        if(res == 0) UnboundLocalError(name);
                        goto __ERROR;
                    }
                    case tp_nil: {
                        // globals
                        int res = Frame__delglobal(frame, name);
                        if(res == 1) DISPATCH();
                        if(res == 0) NameError(name);
                        goto __ERROR;
                    }
                    default: c11__unreachable();
                }
            }
            case OP_DELETE_GLOBAL: {
                py_Name name = byte.arg;
                int res = Frame__delglobal(frame, name);
                if(res == 1) DISPATCH();
                if(res == -1) goto __ERROR;
                NameError(name);
                goto __ERROR;
            }

            case OP_DELETE_ATTR: {
                if(!py_delattr(TOP(), byte.arg)) goto __ERROR;
                DISPATCH();
            }

            case OP_DELETE_SUBSCR: {
                // [a, b] -> del a[b]
                py_Ref magic = py_tpfindmagic(SECOND()->type, __delitem__);
                if(magic) {
                    if(magic->type == tp_nativefunc) {
                        if(!py_callcfunc(magic->_cfunc, 2, SECOND())) goto __ERROR;
                        STACK_SHRINK(2);
                    } else {
                        INSERT_THIRD();     // [?, a, b]
                        *THIRD() = *magic;  // [__delitem__, a, b]
                        if(!py_vectorcall(1, 0)) goto __ERROR;
                    }
                    DISPATCH();
                }
                TypeError("'%t' object does not support item deletion", SECOND()->type);
                goto __ERROR;
            }
            /*****************************************/
            case OP_BUILD_IMAG: {
                // [x]
                py_Ref f = py_getdict(&self->builtins, py_name("complex"));
                assert(f != NULL);
                py_TValue tmp = *TOP();
                *TOP() = *f;           // [complex]
                py_newnil(SP()++);     // [complex, NULL]
                py_newint(SP()++, 0);  // [complex, NULL, 0]
                *SP()++ = tmp;         // [complex, NULL, 0, x]
                vectorcall_opcall(2, 0);
                DISPATCH();
            }
            case OP_BUILD_BYTES: {
                int size;
                py_Ref string = c11__at(py_TValue, &frame->co->consts, byte.arg);
                const char* data = py_tostrn(string, &size);
                unsigned char* p = py_newbytes(SP()++, size);
                memcpy(p, data, size);
                DISPATCH();
            }
            case OP_BUILD_TUPLE: {
                py_TValue tmp;
                py_Ref p = py_newtuple(&tmp, byte.arg);
                py_TValue* begin = SP() - byte.arg;
                for(int i = 0; i < byte.arg; i++)
                    p[i] = begin[i];
                SP() = begin;
                PUSH(&tmp);
                DISPATCH();
            }
            case OP_BUILD_LIST: {
                py_TValue tmp;
                py_newlistn(&tmp, byte.arg);
                py_TValue* begin = SP() - byte.arg;
                for(int i = 0; i < byte.arg; i++) {
                    py_list_setitem(&tmp, i, begin + i);
                }
                SP() = begin;
                PUSH(&tmp);
                DISPATCH();
            }
            case OP_BUILD_DICT: {
                py_TValue* begin = SP() - byte.arg * 2;
                py_Ref tmp = py_pushtmp();
                py_newdict(tmp);
                for(int i = 0; i < byte.arg * 2; i += 2) {
                    bool ok = py_dict_setitem(tmp, begin + i, begin + i + 1);
                    if(!ok) goto __ERROR;
                }
                SP() = begin;
                PUSH(tmp);
                DISPATCH();
            }
            case OP_BUILD_SET: {
                py_TValue* begin = SP() - byte.arg;
                py_Ref typeobject_set = py_getdict(&self->builtins, py_name("set"));
                assert(typeobject_set != NULL);
                py_push(typeobject_set);
                py_pushnil();
                if(!py_vectorcall(0, 0)) goto __ERROR;
                py_push(py_retval());  // empty set
                py_Name id_add = py_name("add");
                for(int i = 0; i < byte.arg; i++) {
                    py_push(TOP());
                    if(!py_pushmethod(id_add)) {
                        c11__abort("OP_BUILD_SET: failed to load method 'add'");
                    }
                    py_push(begin + i);
                    if(!py_vectorcall(1, 0)) goto __ERROR;
                }
                py_TValue tmp = *TOP();
                SP() = begin;
                PUSH(&tmp);
                DISPATCH();
            }
            case OP_BUILD_SLICE: {
                // [start, stop, step]
                py_TValue tmp;
                py_newslice(&tmp);
                py_setslot(&tmp, 0, THIRD());
                py_setslot(&tmp, 1, SECOND());
                py_setslot(&tmp, 2, TOP());
                STACK_SHRINK(3);
                PUSH(&tmp);
                DISPATCH();
            }
            case OP_BUILD_STRING: {
                py_TValue* begin = SP() - byte.arg;
                c11_sbuf ss;
                c11_sbuf__ctor(&ss);
                for(int i = 0; i < byte.arg; i++) {
                    if(!py_str(begin + i)) goto __ERROR;
                    c11_sbuf__write_sv(&ss, py_tosv(&self->last_retval));
                }
                SP() = begin;
                c11_sbuf__py_submit(&ss, SP()++);
                DISPATCH();
            }
            /*****************************/
            case OP_BINARY_OP: {
                py_Name op = byte.arg & 0xFF;
                py_Name rop = byte.arg >> 8;
                if(!pk_stack_binaryop(self, op, rop)) goto __ERROR;
                POP();
                *TOP() = self->last_retval;
                DISPATCH();
            }
            case OP_IS_OP: {
                bool res = py_isidentical(SECOND(), TOP());
                POP();
                if(byte.arg) res = !res;
                py_newbool(TOP(), res);
                DISPATCH();
            }
            case OP_CONTAINS_OP: {
                // [b, a] -> b __contains__ a (a in b) -> [retval]
                py_Ref magic = py_tpfindmagic(SECOND()->type, __contains__);
                if(magic) {
                    if(magic->type == tp_nativefunc) {
                        if(!py_callcfunc(magic->_cfunc, 2, SECOND())) goto __ERROR;
                        STACK_SHRINK(2);
                    } else {
                        INSERT_THIRD();     // [?, b, a]
                        *THIRD() = *magic;  // [__contains__, a, b]
                        if(!py_vectorcall(1, 0)) goto __ERROR;
                    }
                    bool res = py_tobool(py_retval());
                    if(byte.arg) res = !res;
                    py_newbool(SP()++, res);
                    DISPATCH();
                }
                TypeError("'%t' type does not support '__contains__'", SECOND()->type);
                goto __ERROR;
            }
                /*****************************************/
            case OP_JUMP_FORWARD: DISPATCH_JUMP((int16_t)byte.arg);
            case OP_POP_JUMP_IF_FALSE: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                POP();
                if(!res) DISPATCH_JUMP((int16_t)byte.arg);
                DISPATCH();
            }
            case OP_POP_JUMP_IF_TRUE: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                POP();
                if(res) DISPATCH_JUMP((int16_t)byte.arg);
                DISPATCH();
            }
            case OP_JUMP_IF_TRUE_OR_POP: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                if(res) {
                    DISPATCH_JUMP((int16_t)byte.arg);
                } else {
                    POP();
                    DISPATCH();
                }
            }
            case OP_JUMP_IF_FALSE_OR_POP: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                if(!res) {
                    DISPATCH_JUMP((int16_t)byte.arg);
                } else {
                    POP();
                    DISPATCH();
                }
            }
            case OP_SHORTCUT_IF_FALSE_OR_POP: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                if(!res) {                      // [b, False]
                    STACK_SHRINK(2);            // []
                    py_newbool(SP()++, false);  // [False]
                    DISPATCH_JUMP((int16_t)byte.arg);
                } else {
                    POP();  // [b]
                    DISPATCH();
                }
            }
            case OP_LOOP_CONTINUE: {
                DISPATCH_JUMP((int16_t)byte.arg);
            }
            case OP_LOOP_BREAK: {
                DISPATCH_JUMP((int16_t)byte.arg);
            }
            /*****************************************/
            case OP_CALL: {
                ManagedHeap__collect_if_needed(&self->heap);
                vectorcall_opcall(byte.arg & 0xFF, byte.arg >> 8);
                DISPATCH();
            }
            case OP_CALL_VARGS: {
                // [_0, _1, _2 | k1, v1, k2, v2]
                uint16_t argc = byte.arg & 0xFF;
                uint16_t kwargc = byte.arg >> 8;

                int n = 0;
                py_TValue* sp = SP();
                py_TValue* p1 = sp - kwargc * 2;
                py_TValue* base = p1 - argc;
                py_TValue* buf = self->vectorcall_buffer;

                for(py_TValue* curr = base; curr != p1; curr++) {
                    if(curr->type != tp_star_wrapper) {
                        buf[n++] = *curr;
                    } else {
                        py_TValue* args = py_getslot(curr, 0);
                        py_TValue* p;
                        int length = pk_arrayview(args, &p);
                        if(length != -1) {
                            for(int j = 0; j < length; j++) {
                                buf[n++] = p[j];
                            }
                            argc += length - 1;
                        } else {
                            TypeError("*args must be a list or tuple, got '%t'", args->type);
                            goto __ERROR;
                        }
                    }
                }

                for(py_TValue* curr = p1; curr != sp; curr += 2) {
                    if(curr[1].type != tp_star_wrapper) {
                        buf[n++] = curr[0];
                        buf[n++] = curr[1];
                    } else {
                        assert(py_toint(&curr[0]) == 0);
                        py_TValue* kwargs = py_getslot(&curr[1], 0);
                        if(kwargs->type == tp_dict) {
                            py_TValue* p = buf + n;
                            if(!py_dict_apply(kwargs, unpack_dict_to_buffer, &p)) goto __ERROR;
                            n = p - buf;
                            kwargc += py_dict_len(kwargs) - 1;
                        } else {
                            TypeError("**kwargs must be a dict, got '%t'", kwargs->type);
                            goto __ERROR;
                        }
                    }
                }

                memcpy(base, buf, n * sizeof(py_TValue));
                SP() = base + n;

                vectorcall_opcall(argc, kwargc);
                DISPATCH();
            }
            case OP_RETURN_VALUE: {
                CHECK_RETURN_FROM_EXCEPT_OR_FINALLY();
                if(byte.arg == BC_NOARG) {
                    self->last_retval = POPX();
                } else {
                    py_newnone(&self->last_retval);
                }
                VM__pop_frame(self);
                if(frame == base_frame) {  // [ frameBase<- ]
                    return RES_RETURN;
                } else {
                    frame = self->top_frame;
                    PUSH(&self->last_retval);
                    goto __NEXT_FRAME;
                }
                DISPATCH();
            }
            case OP_YIELD_VALUE: {
                CHECK_RETURN_FROM_EXCEPT_OR_FINALLY();
                if(byte.arg == 1) {
                    py_newnone(py_retval());
                } else {
                    py_assign(py_retval(), TOP());
                    POP();
                }
                return RES_YIELD;
            }
            case OP_FOR_ITER_YIELD_VALUE: {
                CHECK_RETURN_FROM_EXCEPT_OR_FINALLY();
                int res = py_next(TOP());
                if(res == -1) goto __ERROR;
                if(res) {
                    return RES_YIELD;
                } else {
                    assert(self->last_retval.type == tp_StopIteration);
                    py_ObjectRef value = py_getslot(&self->last_retval, 0);
                    if(py_isnil(value)) value = py_None();
                    *TOP() = *value;  // [iter] -> [retval]
                    DISPATCH_JUMP((int16_t)byte.arg);
                }
            }
            /////////
            case OP_LIST_APPEND: {
                // [list, iter, value]
                py_list_append(THIRD(), TOP());
                POP();
                DISPATCH();
            }
            case OP_DICT_ADD: {
                // [dict, iter, key, value]
                bool ok = py_dict_setitem(FOURTH(), SECOND(), TOP());
                if(!ok) goto __ERROR;
                STACK_SHRINK(2);
                DISPATCH();
            }
            case OP_SET_ADD: {
                // [set, iter, value]
                py_push(THIRD());  // [| set]
                if(!py_pushmethod(py_name("add"))) {
                    c11__abort("OP_SET_ADD: failed to load method 'add'");
                }  // [|add() set]
                py_push(THIRD());
                if(!py_vectorcall(1, 0)) goto __ERROR;
                POP();
                DISPATCH();
            }
            /////////
            case OP_UNARY_NEGATIVE: {
                if(!pk_callmagic(__neg__, 1, TOP())) goto __ERROR;
                *TOP() = self->last_retval;
                DISPATCH();
            }
            case OP_UNARY_NOT: {
                int res = py_bool(TOP());
                if(res < 0) goto __ERROR;
                py_newbool(TOP(), !res);
                DISPATCH();
            }
            case OP_UNARY_STAR: {
                py_TValue value = POPX();
                int* level = py_newobject(SP()++, tp_star_wrapper, 1, sizeof(int));
                *level = byte.arg;
                py_setslot(TOP(), 0, &value);
                DISPATCH();
            }
            case OP_UNARY_INVERT: {
                if(!pk_callmagic(__invert__, 1, TOP())) goto __ERROR;
                *TOP() = self->last_retval;
                DISPATCH();
            }
            ////////////////
            case OP_GET_ITER: {
                if(!py_iter(TOP())) goto __ERROR;
                *TOP() = *py_retval();
                DISPATCH();
            }
            case OP_FOR_ITER: {
                int res = py_next(TOP());
                if(res == -1) goto __ERROR;
                if(res) {
                    PUSH(py_retval());
                    DISPATCH();
                } else {
                    assert(self->last_retval.type == tp_StopIteration);
                    POP();  // [iter] -> []
                    DISPATCH_JUMP((int16_t)byte.arg);
                }
            }
            ////////
            case OP_IMPORT_PATH: {
                py_Ref path_object = c11__at(py_TValue, &frame->co->consts, byte.arg);
                const char* path = py_tostr(path_object);
                int res = py_import(path);
                if(res == -1) goto __ERROR;
                if(res == 0) {
                    ImportError("No module named '%s'", path);
                    goto __ERROR;
                }
                PUSH(py_retval());
                DISPATCH();
            }
            case OP_POP_IMPORT_STAR: {
                // [module]
                NameDict* dict = PyObject__dict(TOP()->_obj);
                py_Ref all = NameDict__try_get(dict, __all__);
                if(all) {
                    py_TValue* p;
                    int length = pk_arrayview(all, &p);
                    if(length == -1) {
                        TypeError("'__all__' must be a list or tuple, got '%t'", all->type);
                        goto __ERROR;
                    }
                    for(int i = 0; i < length; i++) {
                        py_Name name = py_namev(py_tosv(p + i));
                        py_Ref value = NameDict__try_get(dict, name);
                        if(value == NULL) {
                            ImportError("cannot import name '%n'", name);
                            goto __ERROR;
                        } else {
                            if(!Frame__setglobal(frame, name, value)) goto __ERROR;
                        }
                    }
                } else {
                    for(int i = 0; i < dict->length; i++) {
                        NameDict_KV* kv = c11__at(NameDict_KV, dict, i);
                        if(!kv->key) continue;
                        c11_sv name = py_name2sv(kv->key);
                        if(name.size == 0 || name.data[0] == '_') continue;
                        if(!Frame__setglobal(frame, kv->key, &kv->value)) goto __ERROR;
                    }
                }
                POP();
                DISPATCH();
            }
            ////////
            case OP_UNPACK_SEQUENCE: {
                py_TValue* p;
                int length;

                switch(TOP()->type) {
                    case tp_tuple: {
                        length = py_tuple_len(TOP());
                        p = py_tuple_data(TOP());
                        break;
                    }
                    case tp_list: {
                        length = py_list_len(TOP());
                        p = py_list_data(TOP());
                        break;
                    }
                    case tp_vec2i: {
                        length = 2;
                        if(byte.arg != length) break;
                        c11_vec2i val = py_tovec2i(TOP());
                        POP();
                        py_newint(SP()++, val.x);
                        py_newint(SP()++, val.y);
                        DISPATCH();
                    }
                    case tp_vec2: {
                        length = 2;
                        if(byte.arg != length) break;
                        c11_vec2 val = py_tovec2(TOP());
                        POP();
                        py_newfloat(SP()++, val.x);
                        py_newfloat(SP()++, val.y);
                        DISPATCH();
                    }
                    case tp_vec3i: {
                        length = 3;
                        if(byte.arg != length) break;
                        c11_vec3i val = py_tovec3i(TOP());
                        POP();
                        py_newint(SP()++, val.x);
                        py_newint(SP()++, val.y);
                        py_newint(SP()++, val.z);
                        DISPATCH();
                    }
                    case tp_vec3: {
                        length = 3;
                        if(byte.arg != length) break;
                        c11_vec3 val = py_tovec3(TOP());
                        POP();
                        py_newfloat(SP()++, val.x);
                        py_newfloat(SP()++, val.y);
                        py_newfloat(SP()++, val.z);
                        DISPATCH();
                    }
                    default: {
                        TypeError("expected list or tuple to unpack, got %t", TOP()->type);
                        goto __ERROR;
                    }
                }
                if(length != byte.arg) {
                    ValueError("expected %d values to unpack, got %d", byte.arg, length);
                    goto __ERROR;
                }
                POP();
                for(int i = 0; i < length; i++) {
                    PUSH(p + i);
                }
                DISPATCH();
            }
            case OP_UNPACK_EX: {
                py_TValue* p;
                int length = pk_arrayview(TOP(), &p);
                if(length == -1) {
                    TypeError("expected list or tuple to unpack, got %t", TOP()->type);
                    goto __ERROR;
                }
                int exceed = length - byte.arg;
                if(exceed < 0) {
                    ValueError("not enough values to unpack");
                    goto __ERROR;
                }
                POP();
                for(int i = 0; i < byte.arg; i++) {
                    PUSH(p + i);
                }
                py_newlistn(SP()++, exceed);
                for(int i = 0; i < exceed; i++) {
                    py_list_setitem(TOP(), i, p + byte.arg + i);
                }
                DISPATCH();
            }
            ///////////
            case OP_BEGIN_CLASS: {
                // [base]
                py_Name name = byte.arg;
                py_Type base;
                if(py_isnone(TOP())) {
                    base = tp_object;
                } else {
                    if(!py_checktype(TOP(), tp_type)) goto __ERROR;
                    base = py_totype(TOP());
                }
                POP();

                py_TypeInfo* base_ti = TypeList__get(&self->types, base);
                if(base_ti->is_sealed) {
                    TypeError("type '%t' is not an acceptable base type", base);
                    goto __ERROR;
                }

                py_Type type = pk_newtype(py_name2str(name),
                                          base,
                                          frame->module,
                                          NULL,
                                          base_ti->is_python,
                                          false);
                PUSH(py_tpobject(type));
                self->curr_class = TOP();
                DISPATCH();
            }
            case OP_END_CLASS: {
                // [cls or decorated]
                py_Name name = byte.arg;
                if(!Frame__setglobal(frame, name, TOP())) goto __ERROR;

                if(py_istype(TOP(), tp_type)) {
                    // call on_end_subclass
                    py_TypeInfo* ti = TypeList__get(&self->types, py_totype(TOP()));
                    if(ti->base != tp_object) {
                        py_TypeInfo* base_ti = ti->base_ti;
                        if(base_ti->on_end_subclass) base_ti->on_end_subclass(ti);
                    }
                    py_TValue* slot_eq = TypeList__magic_common(ti, __eq__);
                    py_TValue* slot_ne = TypeList__magic_common(ti, __ne__);
                    if(!py_isnil(slot_eq) && py_isnil(slot_ne)) {
                        TypeError("'%n' implements '__eq__' but not '__ne__'", ti->name);
                        goto __ERROR;
                    }
                }
                // class with decorator is unsafe currently
                // it skips the above check
                POP();
                self->curr_class = NULL;
                DISPATCH();
            }
            case OP_STORE_CLASS_ATTR: {
                assert(self->curr_class);
                py_Name name = byte.arg;
                // TOP() can be a function, classmethod or custom decorator
                py_Ref actual_func = TOP();
                if(actual_func->type == tp_classmethod) {
                    actual_func = py_getslot(actual_func, 0);
                }
                if(actual_func->type == tp_function) {
                    Function* ud = py_touserdata(actual_func);
                    ud->clazz = self->curr_class->_obj;
                }
                py_setdict(self->curr_class, name, TOP());
                POP();
                DISPATCH();
            }
            case OP_ADD_CLASS_ANNOTATION: {
                assert(self->curr_class);
                // [type_hint string]
                py_Type type = py_totype(self->curr_class);
                py_TypeInfo* ti = TypeList__get(&self->types, type);
                if(py_isnil(&ti->annotations)) py_newdict(&ti->annotations);
                bool ok = py_dict_setitem_by_str(&ti->annotations, py_name2str(byte.arg), TOP());
                if(!ok) goto __ERROR;
                POP();
                DISPATCH();
            }
            ///////////
            case OP_WITH_ENTER: {
                // [expr]
                py_push(TOP());
                if(!py_pushmethod(__enter__)) {
                    TypeError("'%t' object does not support the context manager protocol",
                              TOP()->type);
                    goto __ERROR;
                }
                vectorcall_opcall(0, 0);
                DISPATCH();
            }
            case OP_WITH_EXIT: {
                // [expr]
                py_push(TOP());
                if(!py_pushmethod(__exit__)) {
                    TypeError("'%t' object does not support the context manager protocol",
                              TOP()->type);
                    goto __ERROR;
                }
                if(!py_vectorcall(0, 0)) goto __ERROR;
                POP();
                DISPATCH();
            }
            ///////////
            case OP_TRY_ENTER: {
                Frame__set_unwind_target(frame, SP());
                DISPATCH();
            }
            case OP_EXCEPTION_MATCH: {
                if(!py_checktype(TOP(), tp_type)) goto __ERROR;
                bool ok = py_isinstance(&self->curr_exception, py_totype(TOP()));
                py_newbool(TOP(), ok);
                DISPATCH();
            }
            case OP_RAISE: {
                // [exception]
                if(py_istype(TOP(), tp_type)) {
                    if(!py_tpcall(py_totype(TOP()), 0, NULL)) goto __ERROR;
                    py_assign(TOP(), py_retval());
                }
                if(!py_isinstance(TOP(), tp_BaseException)) {
                    TypeError("exceptions must derive from BaseException");
                    goto __ERROR;
                }
                py_raise(TOP());
                goto __ERROR;
            }
            case OP_RAISE_ASSERT: {
                if(byte.arg) {
                    if(!py_str(TOP())) goto __ERROR;
                    POP();
                    py_exception(tp_AssertionError, "%s", py_tostr(py_retval()));
                } else {
                    py_exception(tp_AssertionError, "");
                }
                goto __ERROR;
            }
            case OP_RE_RAISE: {
                if(self->curr_exception.type) {
                    assert(!self->is_curr_exc_handled);
                    goto __ERROR_RE_RAISE;
                }
                DISPATCH();
            }
            case OP_PUSH_EXCEPTION: {
                assert(self->curr_exception.type);
                PUSH(&self->curr_exception);
                DISPATCH();
            }
            case OP_BEGIN_EXC_HANDLING: {
                assert(self->curr_exception.type);
                self->is_curr_exc_handled = true;
                DISPATCH();
            }
            case OP_END_EXC_HANDLING: {
                assert(self->curr_exception.type);
                py_clearexc(NULL);
                DISPATCH();
            }
            case OP_BEGIN_FINALLY: {
                if(self->curr_exception.type) {
                    assert(!self->is_curr_exc_handled);
                    // temporarily handle the exception if any
                    self->is_curr_exc_handled = true;
                }
                DISPATCH();
            }
            case OP_END_FINALLY: {
                if(byte.arg == BC_NOARG) {
                    if(self->curr_exception.type) {
                        assert(self->is_curr_exc_handled);
                        // revert the exception handling if needed
                        self->is_curr_exc_handled = false;
                    }
                } else {
                    // break or continue inside finally block
                    py_clearexc(NULL);
                }
                DISPATCH();
            }
            //////////////////
            case OP_FORMAT_STRING: {
                py_Ref spec = c11__at(py_TValue, &frame->co->consts, byte.arg);
                bool ok = stack_format_object(self, py_tosv(spec));
                if(!ok) goto __ERROR;
                DISPATCH();
            }
            default: c11__unreachable();
        }

        c11__unreachable();

    __ERROR:
        py_BaseException__stpush(&self->curr_exception,
                                 frame->co->src,
                                 Frame__lineno(frame),
                                 !frame->is_locals_special ? frame->co->name->data : NULL);
    __ERROR_RE_RAISE:
        do {
        } while(0);
        int target = Frame__prepare_jump_exception_handler(frame, &self->stack);
        if(target >= 0) {
            // 1. Exception can be handled inside the current frame
            DISPATCH_JUMP_ABSOLUTE(target);
        } else {
            // 2. Exception need to be propagated to the upper frame
            bool is_base_frame_to_be_popped = frame == base_frame;
            VM__pop_frame(self);
            if(self->top_frame == NULL || is_base_frame_to_be_popped) {
                // propagate to the top level
                return RES_ERROR;
            }
            frame = self->top_frame;
            codes = frame->co->codes.data;
            goto __ERROR;
        }
    }

    return RES_RETURN;
}

const char* pk_op2str(py_Name op) {
    switch(op) {
        case __eq__: return "==";
        case __ne__: return "!=";
        case __lt__: return "<";
        case __le__: return "<=";
        case __gt__: return ">";
        case __ge__: return ">=";
        case __add__: return "+";
        case __sub__: return "-";
        case __mul__: return "*";
        case __truediv__: return "/";
        case __floordiv__: return "//";
        case __mod__: return "%";
        case __pow__: return "**";
        case __lshift__: return "<<";
        case __rshift__: return ">>";
        case __and__: return "&";
        case __or__: return "|";
        case __xor__: return "^";
        case __neg__: return "-";
        case __invert__: return "~";
        case __matmul__: return "@";
        default: return py_name2str(op);
    }
}

bool pk_stack_binaryop(VM* self, py_Name op, py_Name rop) {
    // [a, b]
    py_Ref magic = py_tpfindmagic(SECOND()->type, op);
    if(magic) {
        bool ok = py_call(magic, 2, SECOND());
        if(!ok) return false;
        if(self->last_retval.type != tp_NotImplementedType) return true;
    }
    // try reverse operation
    if(rop) {
        // [a, b] -> [b, a]
        py_TValue tmp = *TOP();
        *TOP() = *SECOND();
        *SECOND() = tmp;
        magic = py_tpfindmagic(SECOND()->type, rop);
        if(magic) {
            bool ok = py_call(magic, 2, SECOND());
            if(!ok) return false;
            if(self->last_retval.type != tp_NotImplementedType) return true;
        }
    }
    // eq/ne op never fails
    bool res = py_isidentical(SECOND(), TOP());
    if(op == __eq__) {
        py_newbool(py_retval(), res);
        return true;
    }
    if(op == __ne__) {
        py_newbool(py_retval(), !res);
        return true;
    }
    return TypeError("unsupported operand type(s) for '%s'", pk_op2str(op));
}

bool py_binaryop(py_Ref lhs, py_Ref rhs, py_Name op, py_Name rop) {
    VM* self = pk_current_vm;
    PUSH(lhs);
    PUSH(rhs);
    bool ok = pk_stack_binaryop(self, op, rop);
    STACK_SHRINK(2);
    return ok;
}

static bool stack_format_object(VM* self, c11_sv spec) {
    // format TOS via `spec` inplace
    // spec: '!r:.2f', '.2f'
    py_StackRef val = TOP();
    if(spec.size == 0) return py_str(val);

    if(spec.data[0] == '!') {
        if(c11_sv__startswith(spec, (c11_sv){"!r", 2})) {
            spec.data += 2;
            spec.size -= 2;
            if(!py_repr(val)) return false;
            py_assign(val, py_retval());
            if(spec.size == 0) return true;
        } else {
            return ValueError("invalid conversion specifier (only !r is supported)");
        }
    }

    assert(spec.size > 0);

    if(spec.data[0] == ':') {
        spec.data++;
        spec.size--;
    }

    char type;
    switch(spec.data[spec.size - 1]) {
        case 'f':
        case 'd':
        case 's':
            type = spec.data[spec.size - 1];
            spec.size--;  // remove last char
            break;
        default: type = ' '; break;
    }

    char pad_c = ' ';
    if(strchr("0-=*#@!~", spec.data[0])) {
        pad_c = spec.data[0];
        spec = c11_sv__slice(spec, 1);
    }

    char align;
    if(spec.data[0] == '^') {
        align = '^';
        spec = c11_sv__slice(spec, 1);
    } else if(spec.data[0] == '>') {
        align = '>';
        spec = c11_sv__slice(spec, 1);
    } else if(spec.data[0] == '<') {
        align = '<';
        spec = c11_sv__slice(spec, 1);
    } else {
        align = (py_isint(val) || py_isfloat(val)) ? '>' : '<';
    }

    int dot = c11_sv__index(spec, '.');
    py_i64 width, precision;

    if(dot >= 0) {
        if(dot == 0) {
            // {.2f}
            width = -1;
        } else {
            // {10.2f}
            IntParsingResult res = c11__parse_uint(c11_sv__slice2(spec, 0, dot), &width, 10);
            if(res != IntParsing_SUCCESS) return ValueError("invalid format specifier");
        }
        IntParsingResult res = c11__parse_uint(c11_sv__slice(spec, dot + 1), &precision, 10);
        if(res != IntParsing_SUCCESS) return ValueError("invalid format specifier");
    } else {
        // {10s}
        IntParsingResult res = c11__parse_uint(spec, &width, 10);
        if(res != IntParsing_SUCCESS) return ValueError("invalid format specifier");
        precision = -1;
    }

    if(type != 'f' && dot >= 0) {
        return ValueError("precision not allowed in the format specifier");
    }

    c11_sbuf buf;
    c11_sbuf__ctor(&buf);

    if(type == 'f') {
        py_f64 x;
        if(!py_castfloat(val, &x)) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        if(precision < 0) precision = 6;
        c11_sbuf__write_f64(&buf, x, precision);
    } else if(type == 'd') {
        if(!py_checkint(val)) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_i64(&buf, py_toint(val));
    } else if(type == 's') {
        if(!py_checkstr(val)) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(val));
    } else {
        if(!py_str(val)) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
    }

    c11_string* body = c11_sbuf__submit(&buf);
    int length = c11_sv__u8_length(c11_string__sv(body));
    c11_sbuf__ctor(&buf);  // reinit sbuf

    if(width != -1 && width > length) {
        switch(align) {
            case '>': {
                c11_sbuf__write_pad(&buf, width - length, pad_c);
                c11_sbuf__write_sv(&buf, c11_string__sv(body));
                break;
            }
            case '<': {
                c11_sbuf__write_sv(&buf, c11_string__sv(body));
                c11_sbuf__write_pad(&buf, width - length, pad_c);
                break;
            }
            case '^': {
                int pad_left = (width - length) / 2;
                int pad_right = (width - length) - pad_left;
                c11_sbuf__write_pad(&buf, pad_left, pad_c);
                c11_sbuf__write_sv(&buf, c11_string__sv(body));
                c11_sbuf__write_pad(&buf, pad_right, pad_c);
                break;
            }
            default: c11__unreachable();
        }
    } else {
        c11_sbuf__write_sv(&buf, c11_string__sv(body));
    }

    c11_string__delete(body);
    // inplace update
    c11_sbuf__py_submit(&buf, val);
    return true;
}

#undef CHECK_RETURN_FROM_EXCEPT_OR_FINALLY
#undef DISPATCH
#undef DISPATCH_JUMP
#undef DISPATCH_JUMP_ABSOLUTE
#undef TOP
#undef SECOND
#undef THIRD
#undef FOURTH
#undef STACK_SHRINK
#undef STACK_GROW
#undef PUSH
#undef POP
#undef POPX
#undef SP
#undef INSERT_THIRD
#undef vectorcall_opcall

void py_sys_settrace(py_TraceFunc func) {
    TraceInfo* info = &pk_current_vm->trace_info;
    info->func = func;
    if(info->prev_loc.src) {
        PK_DECREF(info->prev_loc.src);
        info->prev_loc.src = NULL;
    }
    info->prev_loc.lineno = -1;
}
// src/interpreter/name.c
void InternedNames__ctor(InternedNames* self) {
    c11_smallmap_s2n__ctor(&self->interned);
    c11_vector__ctor(&self->r_interned, sizeof(RInternedEntry));

    // initialize all magic names
#define MAGIC_METHOD(x)                                                                            \
    if(x != py_name(#x)) abort();
#ifdef MAGIC_METHOD

// math operators
MAGIC_METHOD(__lt__)
MAGIC_METHOD(__le__)
MAGIC_METHOD(__gt__)
MAGIC_METHOD(__ge__)
/////////////////////////////
MAGIC_METHOD(__neg__)
MAGIC_METHOD(__abs__)
MAGIC_METHOD(__round__)
MAGIC_METHOD(__divmod__)
/////////////////////////////
MAGIC_METHOD(__add__)
MAGIC_METHOD(__radd__)
MAGIC_METHOD(__sub__)
MAGIC_METHOD(__rsub__)
MAGIC_METHOD(__mul__)
MAGIC_METHOD(__rmul__)
MAGIC_METHOD(__truediv__)
MAGIC_METHOD(__rtruediv__)
MAGIC_METHOD(__floordiv__)
MAGIC_METHOD(__rfloordiv__)
MAGIC_METHOD(__mod__)
MAGIC_METHOD(__rmod__)
MAGIC_METHOD(__pow__)
MAGIC_METHOD(__rpow__)
MAGIC_METHOD(__matmul__)
MAGIC_METHOD(__lshift__)
MAGIC_METHOD(__rshift__)
MAGIC_METHOD(__and__)
MAGIC_METHOD(__or__)
MAGIC_METHOD(__xor__)
/////////////////////////////
MAGIC_METHOD(__repr__)
MAGIC_METHOD(__str__)
MAGIC_METHOD(__hash__)
MAGIC_METHOD(__len__)
MAGIC_METHOD(__iter__)
MAGIC_METHOD(__next__)
MAGIC_METHOD(__contains__)
MAGIC_METHOD(__bool__)
MAGIC_METHOD(__invert__)
/////////////////////////////
MAGIC_METHOD(__eq__)
MAGIC_METHOD(__ne__)
// indexer
MAGIC_METHOD(__getitem__)
MAGIC_METHOD(__setitem__)
MAGIC_METHOD(__delitem__)
// specials
MAGIC_METHOD(__new__)
MAGIC_METHOD(__init__)
MAGIC_METHOD(__call__)
MAGIC_METHOD(__enter__)
MAGIC_METHOD(__exit__)
MAGIC_METHOD(__name__)
MAGIC_METHOD(__all__)
MAGIC_METHOD(__package__)
MAGIC_METHOD(__path__)
MAGIC_METHOD(__class__)
MAGIC_METHOD(__getattr__)
MAGIC_METHOD(__reduce__)
MAGIC_METHOD(__missing__)

#endif
#undef MAGIC_METHOD
}

void InternedNames__dtor(InternedNames* self) {
    for(int i = 0; i < self->r_interned.length; i++) {
        PK_FREE(c11__getitem(RInternedEntry, &self->r_interned, i).data);
    }
    c11_smallmap_s2n__dtor(&self->interned);
    c11_vector__dtor(&self->r_interned);
}

py_Name py_name(const char* name) {
    c11_sv sv;
    sv.data = name;
    sv.size = strlen(name);
    return py_namev(sv);
}

py_Name py_namev(c11_sv name) {
    InternedNames* self = &pk_current_vm->names;
    uint16_t index = c11_smallmap_s2n__get(&self->interned, name, 0);
    if(index != 0) return index;
    // generate new index
    if(self->interned.length > 65530) c11__abort("py_Name index overflow");
    // NOTE: we must allocate the string in the heap so iterators are not invalidated
    char* p = PK_MALLOC(name.size + 1);
    memcpy(p, name.data, name.size);
    p[name.size] = '\0';
    RInternedEntry* entry = c11_vector__emplace(&self->r_interned);
    entry->data = p;
    entry->size = name.size;
    memset(&entry->obj, 0, sizeof(py_TValue));
    index = self->r_interned.length;  // 1-based
    // save to _interned
    c11_smallmap_s2n__set(&self->interned, (c11_sv){p, name.size}, index);
    assert(self->interned.length == self->r_interned.length);
    return index;
}

const char* py_name2str(py_Name index) {
    InternedNames* self = &pk_current_vm->names;
    assert(index > 0 && index <= self->interned.length);
    return c11__getitem(RInternedEntry, &self->r_interned, index - 1).data;
}

c11_sv py_name2sv(py_Name index) {
    InternedNames* self = &pk_current_vm->names;
    assert(index > 0 && index <= self->interned.length);
    RInternedEntry entry = c11__getitem(RInternedEntry, &self->r_interned, index - 1);
    return (c11_sv){entry.data, entry.size};
}

py_GlobalRef py_name2ref(py_Name index) {
    InternedNames* self = &pk_current_vm->names;
    assert(index > 0 && index <= self->interned.length);
    RInternedEntry* entry = c11__at(RInternedEntry, &self->r_interned, index - 1);
    if(entry->obj.type == tp_nil) {
        c11_sv sv;
        sv.data = entry->data;
        sv.size = entry->size;
        py_newstrv(&entry->obj, sv);
    }
    return &entry->obj;
}

// src/interpreter/frame.c
#include <stdbool.h>

void ValueStack__ctor(ValueStack* self) {
    self->sp = self->begin;
    self->end = self->begin + PK_VM_STACK_SIZE;
}

void ValueStack__dtor(ValueStack* self) { self->sp = self->begin; }

void FastLocals__to_dict(py_TValue* locals, const CodeObject* co) {
    py_StackRef dict = py_pushtmp();
    py_newdict(dict);
    c11__foreach(c11_smallmap_n2i_KV, &co->varnames_inv, entry) {
        py_TValue* value = &locals[entry->value];
        if(!py_isnil(value)) {
            bool ok = py_dict_setitem(dict, py_name2ref(entry->key), value);
            assert(ok);
            (void)ok;
        }
    }
    py_assign(py_retval(), dict);
    py_pop();
}

NameDict* FastLocals__to_namedict(py_TValue* locals, const CodeObject* co) {
    NameDict* dict = NameDict__new();
    c11__foreach(c11_smallmap_n2i_KV, &co->varnames_inv, entry) {
        py_TValue value = locals[entry->value];
        if(!py_isnil(&value)) NameDict__set(dict, entry->key, value);
    }
    return dict;
}

UnwindTarget* UnwindTarget__new(UnwindTarget* next, int iblock, int offset) {
    UnwindTarget* self = PK_MALLOC(sizeof(UnwindTarget));
    self->next = next;
    self->iblock = iblock;
    self->offset = offset;
    return self;
}

void UnwindTarget__delete(UnwindTarget* self) { PK_FREE(self); }

py_Frame* Frame__new(const CodeObject* co,
                     py_StackRef p0,
                     py_GlobalRef module,
                     py_Ref globals,
                     py_Ref locals,
                     bool is_locals_special) {
    assert(module->type == tp_module);
    assert(globals->type == tp_module || globals->type == tp_dict);
    if(is_locals_special) {
        assert(locals->type == tp_nil || locals->type == tp_locals || locals->type == tp_dict);
    }
    py_Frame* self = FixedMemoryPool__alloc(&pk_current_vm->pool_frame);
    self->f_back = NULL;
    self->co = co;
    self->p0 = p0;
    self->module = module;
    self->globals = globals;
    self->locals = locals;
    self->is_locals_special = is_locals_special;
    self->ip = -1;
    self->uw_list = NULL;
    return self;
}

void Frame__delete(py_Frame* self) {
    while(self->uw_list) {
        UnwindTarget* p = self->uw_list;
        self->uw_list = p->next;
        UnwindTarget__delete(p);
    }
    FixedMemoryPool__dealloc(&pk_current_vm->pool_frame, self);
}

int Frame__prepare_jump_exception_handler(py_Frame* self, ValueStack* _s) {
    // try to find a parent try block
    int iblock = Frame__iblock(self);
    while(iblock >= 0) {
        CodeBlock* block = c11__at(CodeBlock, &self->co->blocks, iblock);
        if(block->type == CodeBlockType_TRY) break;
        iblock = block->parent;
    }
    if(iblock < 0) return -1;
    UnwindTarget* uw = Frame__find_unwind_target(self, iblock);
    _s->sp = (self->p0 + uw->offset);  // unwind the stack
    return c11__at(CodeBlock, &self->co->blocks, iblock)->end;
}

UnwindTarget* Frame__find_unwind_target(py_Frame* self, int iblock) {
    UnwindTarget* uw;
    for(uw = self->uw_list; uw; uw = uw->next) {
        if(uw->iblock == iblock) return uw;
    }
    return NULL;
}

void Frame__set_unwind_target(py_Frame* self, py_TValue* sp) {
    int iblock = Frame__iblock(self);
    assert(iblock >= 0);
    UnwindTarget* existing = Frame__find_unwind_target(self, iblock);
    if(existing) {
        existing->offset = sp - self->p0;
    } else {
        UnwindTarget* prev = self->uw_list;
        self->uw_list = UnwindTarget__new(prev, iblock, sp - self->p0);
    }
}

void Frame__gc_mark(py_Frame* self) {
    pk__mark_value(self->globals);
    if(self->is_locals_special) pk__mark_value(self->locals);
    CodeObject__gc_mark(self->co);
}

int Frame__lineno(const py_Frame* self) {
    int ip = self->ip;
    if(ip >= 0) return c11__getitem(BytecodeEx, &self->co->codes_ex, ip).lineno;
    if(!self->is_locals_special) return self->co->start_line;
    return 0;
}

int Frame__iblock(const py_Frame* self) {
    int ip = self->ip;
    if(ip < 0) return -1;
    return c11__getitem(BytecodeEx, &self->co->codes_ex, ip).iblock;
}

int Frame__getglobal(py_Frame* self, py_Name name) {
    if(self->globals->type == tp_module) {
        py_ItemRef item = py_getdict(self->globals, name);
        if(item != NULL) {
            py_assign(py_retval(), item);
            return 1;
        }
        return 0;
    } else {
        return py_dict_getitem(self->globals, py_name2ref(name));
    }
}

bool Frame__setglobal(py_Frame* self, py_Name name, py_TValue* val) {
    if(self->globals->type == tp_module) {
        py_setdict(self->globals, name, val);
        return true;
    } else {
        return py_dict_setitem(self->globals, py_name2ref(name), val);
    }
}

int Frame__delglobal(py_Frame* self, py_Name name) {
    if(self->globals->type == tp_module) {
        bool found = py_deldict(self->globals, name);
        return found ? 1 : 0;
    } else {
        return py_dict_delitem(self->globals, py_name2ref(name));
    }
}

py_StackRef Frame__getlocal_noproxy(py_Frame* self, py_Name name) {
    assert(!self->is_locals_special);
    int index = c11_smallmap_n2i__get(&self->co->varnames_inv, name, -1);
    if(index == -1) return NULL;
    return &self->locals[index];
}

py_Ref Frame__getclosure(py_Frame* self, py_Name name) {
    if(self->is_locals_special) return NULL;
    assert(self->p0->type == tp_function);
    Function* ud = py_touserdata(self->p0);
    if(ud->closure == NULL) return NULL;
    return NameDict__try_get(ud->closure, name);
}

SourceLocation Frame__source_location(py_Frame* self) {
    SourceLocation loc;
    loc.lineno = Frame__lineno(self);
    loc.src = self->co->src;
    return loc;
}

const char* py_Frame_sourceloc(py_Frame* self, int* lineno) {
    SourceLocation loc = Frame__source_location(self);
    *lineno = loc.lineno;
    return loc.src->filename->data;
}

void py_Frame_newglobals(py_Frame* frame, py_Ref out) {
    if(!frame) {
        pk_mappingproxy__namedict(out, &pk_current_vm->main);
        return;
    }
    if(frame->globals->type == tp_module) {
        pk_mappingproxy__namedict(out, frame->globals);
    } else {
        *out = *frame->globals;  // dict
    }
}

void py_Frame_newlocals(py_Frame* frame, py_Ref out) {
    if(!frame) {
        py_newdict(out);
        return;
    }
    if(frame->is_locals_special) {
        switch(frame->locals->type) {
            case tp_locals: frame = frame->locals->_ptr; break;
            case tp_dict: *out = *frame->locals; return;
            case tp_nil: py_newdict(out); return;
            default: c11__unreachable();
        }
    }
    FastLocals__to_dict(frame->locals, frame->co);
    py_assign(out, py_retval());
}

py_StackRef py_Frame_function(py_Frame* self) {
    if(self->is_locals_special) return NULL;
    assert(self->p0->type == tp_function);
    return self->p0;
}
// src/interpreter/dll.c
#if PK_IS_DESKTOP_PLATFORM && PK_ENABLE_OS

#ifdef _WIN32

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#else
#include <dlfcn.h>
#endif

typedef bool (*py_module_initialize_t)() PY_RAISE PY_RETURN;

int load_module_from_dll_desktop_only(const char* path) PY_RAISE PY_RETURN {
    const char* f_init_name = "py_module_initialize";
#ifdef _WIN32
    void* dll = LoadLibraryA(path);
    if(dll == NULL) return 0;
    py_module_initialize_t f_init = (py_module_initialize_t)GetProcAddress(dll, f_init_name);
#else
    void* dll = dlopen(path, RTLD_LAZY);
    if(dll == NULL) return 0;
    py_module_initialize_t f_init = (py_module_initialize_t)dlsym(dll, f_init_name);
#endif
    if(f_init == NULL) {
        RuntimeError("%s() not found in '%s'", f_init_name, path);
        return -1;
    }
    bool success = f_init();
    if(!success) return -1;
    return 1;
}

#else

int load_module_from_dll_desktop_only(const char* path) PY_RAISE PY_RETURN {
    return 0;
}

#endif
// src/objects/object.c
#include <assert.h>

void* PyObject__userdata(PyObject* self) { return self->flex + PK_OBJ_SLOTS_SIZE(self->slots); }

NameDict* PyObject__dict(PyObject* self) {
    assert(self->slots == -1);
    return (NameDict*)(self->flex);
}

py_TValue* PyObject__slots(PyObject* self) {
    assert(self->slots >= 0);
    return (py_TValue*)(self->flex);
}
// src/objects/codeobject.c
#include <stdint.h>

void Bytecode__set_signed_arg(Bytecode* self, int arg) {
    self->arg = (int16_t)arg;
    if((int16_t)self->arg != arg) {
        c11__abort("Bytecode__set_signed_arg(): %d is not representable in int16_t", arg);
    }
}

bool Bytecode__is_forward_jump(const Bytecode* self) {
    Opcode op = self->op;
    return (op >= OP_JUMP_FORWARD && op <= OP_LOOP_BREAK) ||
           (op == OP_FOR_ITER || op == OP_FOR_ITER_YIELD_VALUE);
}

static void FuncDecl__dtor(FuncDecl* self) {
    CodeObject__dtor(&self->code);
    c11_vector__dtor(&self->args);
    c11_vector__dtor(&self->kwargs);
    c11_smallmap_n2i__dtor(&self->kw_to_index);
}

FuncDecl_ FuncDecl__rcnew(SourceData_ src, c11_sv name) {
    FuncDecl* self = PK_MALLOC(sizeof(FuncDecl));
    self->rc.count = 1;
    self->rc.dtor = (void (*)(void*))FuncDecl__dtor;
    CodeObject__ctor(&self->code, src, name);

    c11_vector__ctor(&self->args, sizeof(int));
    c11_vector__ctor(&self->kwargs, sizeof(FuncDeclKwArg));

    self->starred_arg = -1;
    self->starred_kwarg = -1;
    self->nested = false;

    self->docstring = NULL;
    self->type = FuncType_UNSET;

    c11_smallmap_n2i__ctor(&self->kw_to_index);
    return self;
}

bool FuncDecl__is_duplicated_arg(const FuncDecl* decl, py_Name name) {
    py_Name tmp_name;
    c11__foreach(int, &decl->args, j) {
        tmp_name = c11__getitem(py_Name, &decl->args, *j);
        if(tmp_name == name) return true;
    }
    c11__foreach(FuncDeclKwArg, &decl->kwargs, kv) {
        tmp_name = c11__getitem(py_Name, &decl->code.varnames, kv->index);
        if(tmp_name == name) return true;
    }
    if(decl->starred_arg != -1) {
        tmp_name = c11__getitem(py_Name, &decl->code.varnames, decl->starred_arg);
        if(tmp_name == name) return true;
    }
    if(decl->starred_kwarg != -1) {
        tmp_name = c11__getitem(py_Name, &decl->code.varnames, decl->starred_kwarg);
        if(tmp_name == name) return true;
    }
    return false;
}

void FuncDecl__add_arg(FuncDecl* self, py_Name name) {
    int index = CodeObject__add_varname(&self->code, name);
    c11_vector__push(int, &self->args, index);
}

void FuncDecl__add_kwarg(FuncDecl* self, py_Name name, const py_TValue* value) {
    int index = CodeObject__add_varname(&self->code, name);
    c11_smallmap_n2i__set(&self->kw_to_index, name, index);
    FuncDeclKwArg* item = c11_vector__emplace(&self->kwargs);
    item->index = index;
    item->key = name;
    item->value = *value;
}

void FuncDecl__add_starred_arg(FuncDecl* self, py_Name name) {
    int index = CodeObject__add_varname(&self->code, name);
    self->starred_arg = index;
}

void FuncDecl__add_starred_kwarg(FuncDecl* self, py_Name name) {
    int index = CodeObject__add_varname(&self->code, name);
    self->starred_kwarg = index;
}

FuncDecl_ FuncDecl__build(c11_sv name,
                          c11_sv* args,
                          int argc,
                          c11_sv starred_arg,
                          c11_sv* kwargs,
                          int kwargc,
                          py_Ref kwdefaults,  // a tuple contains default values
                          c11_sv starred_kwarg,
                          const char* docstring) {
    SourceData_ source = SourceData__rcnew("pass", "<bind>", EXEC_MODE, false);
    FuncDecl_ decl = FuncDecl__rcnew(source, name);
    for(int i = 0; i < argc; i++) {
        FuncDecl__add_arg(decl, py_namev(args[i]));
    }
    if(starred_arg.size) { FuncDecl__add_starred_arg(decl, py_namev(starred_arg)); }
    assert(py_istype(kwdefaults, tp_tuple));
    assert(py_tuple_len(kwdefaults) == kwargc);
    for(int i = 0; i < kwargc; i++) {
        FuncDecl__add_kwarg(decl, py_namev(kwargs[i]), py_tuple_getitem(kwdefaults, i));
    }
    if(starred_kwarg.size) FuncDecl__add_starred_kwarg(decl, py_namev(starred_kwarg));
    decl->docstring = docstring;
    PK_DECREF(source);
    return decl;
}

void CodeObject__ctor(CodeObject* self, SourceData_ src, c11_sv name) {
    self->src = src;
    PK_INCREF(src);
    self->name = c11_string__new2(name.data, name.size);

    c11_vector__ctor(&self->codes, sizeof(Bytecode));
    c11_vector__ctor(&self->codes_ex, sizeof(BytecodeEx));

    c11_vector__ctor(&self->consts, sizeof(py_TValue));
    c11_vector__ctor(&self->varnames, sizeof(uint16_t));
    self->nlocals = 0;

    c11_smallmap_n2i__ctor(&self->varnames_inv);

    c11_vector__ctor(&self->blocks, sizeof(CodeBlock));
    c11_vector__ctor(&self->func_decls, sizeof(FuncDecl_));

    self->start_line = -1;
    self->end_line = -1;

    CodeBlock root_block = {CodeBlockType_NO_BLOCK, -1, 0, -1, -1};
    c11_vector__push(CodeBlock, &self->blocks, root_block);
}

void CodeObject__dtor(CodeObject* self) {
    PK_DECREF(self->src);
    c11_string__delete(self->name);

    c11_vector__dtor(&self->codes);
    c11_vector__dtor(&self->codes_ex);

    c11_vector__dtor(&self->consts);
    c11_vector__dtor(&self->varnames);

    c11_smallmap_n2i__dtor(&self->varnames_inv);

    c11_vector__dtor(&self->blocks);

    for(int i = 0; i < self->func_decls.length; i++) {
        FuncDecl_ decl = c11__getitem(FuncDecl_, &self->func_decls, i);
        PK_DECREF(decl);
    }
    c11_vector__dtor(&self->func_decls);
}

void Function__ctor(Function* self, FuncDecl_ decl, py_GlobalRef module, py_Ref globals) {
    PK_INCREF(decl);
    self->decl = decl;
    self->module = module;
    self->globals = globals;
    self->closure = NULL;
    self->clazz = NULL;
    self->cfunc = NULL;
}

int CodeObject__add_varname(CodeObject* self, py_Name name) {
    int index = c11_smallmap_n2i__get(&self->varnames_inv, name, -1);
    if(index >= 0) return index;
    c11_vector__push(uint16_t, &self->varnames, name);
    self->nlocals++;
    index = self->varnames.length - 1;
    c11_smallmap_n2i__set(&self->varnames_inv, name, index);
    return index;
}

void Function__dtor(Function* self) {
    // printf("%s() in %s freed!\n", self->decl->code.name->data,
    // self->decl->code.src->filename->data);
    PK_DECREF(self->decl);
    if(self->closure) NameDict__delete(self->closure);
}
// src/objects/namedict.c
#define SMALLMAP_T__SOURCE
#define K uint16_t
#define V py_TValue
#define NAME NameDict
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__SOURCE

void ModuleDict__ctor(ModuleDict* self, const char* path, py_TValue module) {
    self->path = path;
    self->module = module;
    self->left = NULL;
    self->right = NULL;
}

void ModuleDict__dtor(ModuleDict* self) {
    if(self->left) {
        ModuleDict__dtor(self->left);
        PK_FREE(self->left);
    }
    if(self->right) {
        ModuleDict__dtor(self->right);
        PK_FREE(self->right);
    }
}

void ModuleDict__set(ModuleDict* self, const char* key, py_TValue val) {
    if(self->path == NULL) {
        self->path = key;
        self->module = val;
    }
    int cmp = strcmp(key, self->path);
    if(cmp < 0) {
        if(self->left) {
            ModuleDict__set(self->left, key, val);
        } else {
            self->left = PK_MALLOC(sizeof(ModuleDict));
            ModuleDict__ctor(self->left, key, val);
        }
    } else if(cmp > 0) {
        if(self->right) {
            ModuleDict__set(self->right, key, val);
        } else {
            self->right = PK_MALLOC(sizeof(ModuleDict));
            ModuleDict__ctor(self->right, key, val);
        }
    } else {
        self->module = val;
    }
}

py_TValue* ModuleDict__try_get(ModuleDict* self, const char* path) {
    if(self->path == NULL) return NULL;
    int cmp = strcmp(path, self->path);
    if(cmp < 0) {
        if(self->left) {
            return ModuleDict__try_get(self->left, path);
        } else {
            return NULL;
        }
    } else if(cmp > 0) {
        if(self->right) {
            return ModuleDict__try_get(self->right, path);
        } else {
            return NULL;
        }
    } else {
        return &self->module;
    }
}

bool ModuleDict__contains(ModuleDict* self, const char* path) {
    return ModuleDict__try_get(self, path) != NULL;
}

void ModuleDict__apply_mark(ModuleDict *self) {
    if(!self->module._obj->gc_marked) PyObject__mark(self->module._obj);
    if(self->left) ModuleDict__apply_mark(self->left);
    if(self->right) ModuleDict__apply_mark(self->right);
}

// src/common/_generated.c
// generated by prebuild.py
#include <string.h>
const char kPythonLibs_bisect[] = "\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    lo = bisect_right(a, x, lo, hi)\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    lo = bisect_left(a, x, lo, hi)\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n";
const char kPythonLibs_builtins[] = "def all(iterable):\n    for i in iterable:\n        if not i:\n            return False\n    return True\n\ndef any(iterable):\n    for i in iterable:\n        if i:\n            return True\n    return False\n\ndef enumerate(iterable, start=0):\n    n = start\n    for elem in iterable:\n        yield n, elem\n        n += 1\n\ndef __minmax_reduce(op, args):\n    if len(args) == 2:  # min(1, 2)\n        return args[0] if op(args[0], args[1]) else args[1]\n    if len(args) == 0:  # min()\n        raise TypeError('expected 1 arguments, got 0')\n    if len(args) == 1:  # min([1, 2, 3, 4]) -> min(1, 2, 3, 4)\n        args = args[0]\n    args = iter(args)\n    try:\n        res = next(args)\n    except StopIteration:\n        raise ValueError('args is an empty sequence')\n    while True:\n        try:\n            i = next(args)\n        except StopIteration:\n            break\n        if op(i, res):\n            res = i\n    return res\n\ndef min(*args, key=None):\n    key = key or (lambda x: x)\n    return __minmax_reduce(lambda x,y: key(x)<key(y), args)\n\ndef max(*args, key=None):\n    key = key or (lambda x: x)\n    return __minmax_reduce(lambda x,y: key(x)>key(y), args)\n\ndef sum(iterable):\n    res = 0\n    for i in iterable:\n        res += i\n    return res\n\ndef map(f, iterable):\n    for i in iterable:\n        yield f(i)\n\ndef filter(f, iterable):\n    for i in iterable:\n        if f(i):\n            yield i\n\ndef zip(a, b):\n    a = iter(a)\n    b = iter(b)\n    while True:\n        try:\n            ai = next(a)\n            bi = next(b)\n        except StopIteration:\n            break\n        yield ai, bi\n\ndef reversed(iterable):\n    a = list(iterable)\n    a.reverse()\n    return a\n\ndef sorted(iterable, key=None, reverse=False):\n    a = list(iterable)\n    a.sort(key=key, reverse=reverse)\n    return a\n\n##### str #####\ndef __format_string(self: str, *args, **kwargs) -> str:\n    def tokenizeString(s: str):\n        tokens = []\n        L, R = 0,0\n        \n        mode = None\n        curArg = 0\n        # lookingForKword = False\n        \n        while(R<len(s)):\n            curChar = s[R]\n            nextChar = s[R+1] if R+1<len(s) else ''\n            \n            # Invalid case 1: stray '}' encountered, example: \"ABCD EFGH {name} IJKL}\", \"Hello {vv}}\", \"HELLO {0} WORLD}\"\n            if curChar == '}' and nextChar != '}':\n                raise ValueError(\"Single '}' encountered in format string\")        \n            \n            # Valid Case 1: Escaping case, we escape \"{{ or \"}}\" to be \"{\" or \"}\", example: \"{{}}\", \"{{My Name is {0}}}\"\n            if (curChar == '{' and nextChar == '{') or (curChar == '}' and nextChar == '}'):\n                \n                if (L<R): # Valid Case 1.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the escape\n                \n                \n                tokens.append(curChar) # Valid Case 1.2: add the escape char\n                L = R+2 # move the left pointer to the next char\n                R = R+2 # move the right pointer to the next char\n                continue\n            \n            # Valid Case 2: Regular command line arg case: example:  \"ABCD EFGH {} IJKL\", \"{}\", \"HELLO {} WORLD\"\n            elif curChar == '{' and nextChar == '}':\n                if mode is not None and mode != 'auto':\n                    # Invalid case 2: mixing automatic and manual field specifications -- example: \"ABCD EFGH {name} IJKL {}\", \"Hello {vv} {}\", \"HELLO {0} WORLD {}\" \n                    raise ValueError(\"Cannot switch from manual field numbering to automatic field specification\")\n                \n                mode = 'auto'\n                if(L<R): # Valid Case 2.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the special marker for the arg\n                \n                tokens.append(\"{\"+str(curArg)+\"}\") # Valid Case 2.2: add the special marker for the arg\n                curArg+=1 # increment the arg position, this will be used for referencing the arg later\n                \n                L = R+2 # move the left pointer to the next char\n                R = R+2 # move the right pointer to the next char\n                continue\n            \n            # Valid Case 3: Key-word arg case: example: \"ABCD EFGH {name} IJKL\", \"Hello {vv}\", \"HELLO {name} WORLD\"\n            elif (curChar == '{'):\n                \n                if mode is not None and mode != 'manual':\n                    # # Invalid case 2: mixing automatic and manual field specifications -- example: \"ABCD EFGH {} IJKL {name}\", \"Hello {} {1}\", \"HELLO {} WORLD {name}\"\n                    raise ValueError(\"Cannot switch from automatic field specification to manual field numbering\")\n                \n                mode = 'manual'\n                \n                if(L<R): # Valid case 3.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the special marker for the arg\n                \n                # We look for the end of the keyword          \n                kwL = R # Keyword left pointer\n                kwR = R+1 # Keyword right pointer\n                while(kwR<len(s) and s[kwR]!='}'):\n                    if s[kwR] == '{': # Invalid case 3: stray '{' encountered, example: \"ABCD EFGH {n{ame} IJKL {\", \"Hello {vv{}}\", \"HELLO {0} WOR{LD}\"\n                        raise ValueError(\"Unexpected '{' in field name\")\n                    kwR += 1\n                \n                # Valid case 3.2: We have successfully found the end of the keyword\n                if kwR<len(s) and s[kwR] == '}':\n                    tokens.append(s[kwL:kwR+1]) # add the special marker for the arg\n                    L = kwR+1\n                    R = kwR+1\n                    \n                # Invalid case 4: We didn't find the end of the keyword, throw error\n                else:\n                    raise ValueError(\"Expected '}' before end of string\")\n                continue\n            \n            R = R+1\n        \n        \n        # Valid case 4: We have reached the end of the string, add the remaining string to the tokens \n        if L<R:\n            tokens.append(s[L:R])\n                \n        # print(tokens)\n        return tokens\n\n    tokens = tokenizeString(self)\n    argMap = {}\n    for i, a in enumerate(args):\n        argMap[str(i)] = a\n    final_tokens = []\n    for t in tokens:\n        if t[0] == '{' and t[-1] == '}':\n            key = t[1:-1]\n            argMapVal = argMap.get(key, None)\n            kwargsVal = kwargs.get(key, None)\n                                    \n            if argMapVal is None and kwargsVal is None:\n                raise ValueError(\"No arg found for token: \"+t)\n            elif argMapVal is not None:\n                final_tokens.append(str(argMapVal))\n            else:\n                final_tokens.append(str(kwargsVal))\n        else:\n            final_tokens.append(t)\n    \n    return ''.join(final_tokens)\n\nstr.format = __format_string\ndel __format_string\n\n\ndef help(obj):\n    if hasattr(obj, '__func__'):\n        obj = obj.__func__\n    # print(obj.__signature__)\n    if obj.__doc__:\n        print(obj.__doc__)\n\ndef complex(real, imag=0):\n    import cmath\n    return cmath.complex(real, imag) # type: ignore\n\ndef dir(obj) -> list[str]:\n    tp_module = type(__import__('math'))\n    if isinstance(obj, tp_module):\n        return [k for k, _ in obj.__dict__.items()]\n    names = set()\n    if not isinstance(obj, type):\n        obj_d = obj.__dict__\n        if obj_d is not None:\n            names.update([k for k, _ in obj_d.items()])\n        cls = type(obj)\n    else:\n        cls = obj\n    while cls is not None:\n        names.update([k for k, _ in cls.__dict__.items()])\n        cls = cls.__base__\n    return sorted(list(names))\n\nclass set:\n    def __init__(self, iterable=None):\n        iterable = iterable or []\n        self._a = {}\n        self.update(iterable)\n\n    def add(self, elem):\n        self._a[elem] = None\n        \n    def discard(self, elem):\n        self._a.pop(elem, None)\n\n    def remove(self, elem):\n        del self._a[elem]\n        \n    def clear(self):\n        self._a.clear()\n\n    def update(self, other):\n        for elem in other:\n            self.add(elem)\n\n    def __len__(self):\n        return len(self._a)\n    \n    def copy(self):\n        return set(self._a.keys())\n    \n    def __and__(self, other):\n        return {elem for elem in self if elem in other}\n\n    def __sub__(self, other):\n        return {elem for elem in self if elem not in other}\n    \n    def __or__(self, other):\n        ret = self.copy()\n        ret.update(other)\n        return ret\n\n    def __xor__(self, other): \n        _0 = self - other\n        _1 = other - self\n        return _0 | _1\n\n    def union(self, other):\n        return self | other\n\n    def intersection(self, other):\n        return self & other\n\n    def difference(self, other):\n        return self - other\n\n    def symmetric_difference(self, other):      \n        return self ^ other\n    \n    def __eq__(self, other):\n        if not isinstance(other, set):\n            return NotImplemented\n        return len(self ^ other) == 0\n    \n    def __ne__(self, other):\n        if not isinstance(other, set):\n            return NotImplemented\n        return len(self ^ other) != 0\n\n    def isdisjoint(self, other):\n        return len(self & other) == 0\n    \n    def issubset(self, other):\n        return len(self - other) == 0\n    \n    def issuperset(self, other):\n        return len(other - self) == 0\n\n    def __contains__(self, elem):\n        return elem in self._a\n    \n    def __repr__(self):\n        if len(self) == 0:\n            return 'set()'\n        return '{'+ ', '.join([repr(i) for i in self._a.keys()]) + '}'\n    \n    def __iter__(self):\n        return iter(self._a.keys())";
const char kPythonLibs_cmath[] = "import math\n\nclass complex:\n    def __init__(self, real, imag=0):\n        self._real = float(real)\n        self._imag = float(imag)\n\n    @property\n    def real(self):\n        return self._real\n    \n    @property\n    def imag(self):\n        return self._imag\n\n    def conjugate(self):\n        return complex(self.real, -self.imag)\n    \n    def __repr__(self):\n        s = ['(', str(self.real)]\n        s.append('-' if self.imag < 0 else '+')\n        s.append(str(abs(self.imag)))\n        s.append('j)')\n        return ''.join(s)\n    \n    def __eq__(self, other):\n        if type(other) is complex:\n            return self.real == other.real and self.imag == other.imag\n        if type(other) in (int, float):\n            return self.real == other and self.imag == 0\n        return NotImplemented\n    \n    def __ne__(self, other):\n        res = self == other\n        if res is NotImplemented:\n            return res\n        return not res\n    \n    def __add__(self, other):\n        if type(other) is complex:\n            return complex(self.real + other.real, self.imag + other.imag)\n        if type(other) in (int, float):\n            return complex(self.real + other, self.imag)\n        return NotImplemented\n        \n    def __radd__(self, other):\n        return self.__add__(other)\n    \n    def __sub__(self, other):\n        if type(other) is complex:\n            return complex(self.real - other.real, self.imag - other.imag)\n        if type(other) in (int, float):\n            return complex(self.real - other, self.imag)\n        return NotImplemented\n    \n    def __rsub__(self, other):\n        if type(other) is complex:\n            return complex(other.real - self.real, other.imag - self.imag)\n        if type(other) in (int, float):\n            return complex(other - self.real, -self.imag)\n        return NotImplemented\n    \n    def __mul__(self, other):\n        if type(other) is complex:\n            return complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        if type(other) in (int, float):\n            return complex(self.real * other, self.imag * other)\n        return NotImplemented\n    \n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __truediv__(self, other):\n        if type(other) is complex:\n            denominator = other.real ** 2 + other.imag ** 2\n            real_part = (self.real * other.real + self.imag * other.imag) / denominator\n            imag_part = (self.imag * other.real - self.real * other.imag) / denominator\n            return complex(real_part, imag_part)\n        if type(other) in (int, float):\n            return complex(self.real / other, self.imag / other)\n        return NotImplemented\n    \n    def __pow__(self, other: int | float):\n        if type(other) in (int, float):\n            return complex(self.__abs__() ** other * math.cos(other * phase(self)),\n                           self.__abs__() ** other * math.sin(other * phase(self)))\n        return NotImplemented\n    \n    def __abs__(self) -> float:\n        return math.sqrt(self.real ** 2 + self.imag ** 2)\n\n    def __neg__(self):\n        return complex(-self.real, -self.imag)\n    \n    def __hash__(self):\n        return hash((self.real, self.imag))\n\n\n# Conversions to and from polar coordinates\n\ndef phase(z: complex):\n    return math.atan2(z.imag, z.real)\n\ndef polar(z: complex):\n    return z.__abs__(), phase(z)\n\ndef rect(r: float, phi: float):\n    return r * math.cos(phi) + r * math.sin(phi) * 1j\n\n# Power and logarithmic functions\n\ndef exp(z: complex):\n    return math.exp(z.real) * rect(1, z.imag)\n\ndef log(z: complex, base=2.718281828459045):\n    return math.log(z.__abs__(), base) + phase(z) * 1j\n\ndef log10(z: complex):\n    return log(z, 10)\n\ndef sqrt(z: complex):\n    return z ** 0.5\n\n# Trigonometric functions\n\ndef acos(z: complex):\n    return -1j * log(z + sqrt(z * z - 1))\n\ndef asin(z: complex):\n    return -1j * log(1j * z + sqrt(1 - z * z))\n\ndef atan(z: complex):\n    return 1j / 2 * log((1 - 1j * z) / (1 + 1j * z))\n\ndef cos(z: complex):\n    return (exp(z) + exp(-z)) / 2\n\ndef sin(z: complex):\n    return (exp(z) - exp(-z)) / (2 * 1j)\n\ndef tan(z: complex):\n    return sin(z) / cos(z)\n\n# Hyperbolic functions\n\ndef acosh(z: complex):\n    return log(z + sqrt(z * z - 1))\n\ndef asinh(z: complex):\n    return log(z + sqrt(z * z + 1))\n\ndef atanh(z: complex):\n    return 1 / 2 * log((1 + z) / (1 - z))\n\ndef cosh(z: complex):\n    return (exp(z) + exp(-z)) / 2\n\ndef sinh(z: complex):\n    return (exp(z) - exp(-z)) / 2\n\ndef tanh(z: complex):\n    return sinh(z) / cosh(z)\n\n# Classification functions\n\ndef isfinite(z: complex):\n    return math.isfinite(z.real) and math.isfinite(z.imag)\n\ndef isinf(z: complex):\n    return math.isinf(z.real) or math.isinf(z.imag)\n\ndef isnan(z: complex):\n    return math.isnan(z.real) or math.isnan(z.imag)\n\ndef isclose(a: complex, b: complex):\n    return math.isclose(a.real, b.real) and math.isclose(a.imag, b.imag)\n\n# Constants\n\npi = math.pi\ne = math.e\ntau = 2 * pi\ninf = math.inf\ninfj = complex(0, inf)\nnan = math.nan\nnanj = complex(0, nan)\n";
const char kPythonLibs_collections[] = "from typing import TypeVar, Iterable\n\ndef Counter[T](iterable: Iterable[T]):\n    a: dict[T, int] = {}\n    for x in iterable:\n        if x in a:\n            a[x] += 1\n        else:\n            a[x] = 1\n    return a\n\n\nclass defaultdict(dict):\n    def __init__(self, default_factory, *args):\n        super().__init__(*args)\n        self.default_factory = default_factory\n\n    def __missing__(self, key):\n        self[key] = self.default_factory()\n        return self[key]\n\n    def __repr__(self) -> str:\n        return f\"defaultdict({self.default_factory}, {super().__repr__()})\"\n\n    def copy(self):\n        return defaultdict(self.default_factory, self)\n\n\nclass deque[T]:\n    _data: list[T]\n    _head: int\n    _tail: int\n    _capacity: int\n\n    def __init__(self, iterable: Iterable[T] = None):\n        self._data = [None] * 8 # type: ignore\n        self._head = 0\n        self._tail = 0\n        self._capacity = len(self._data)\n\n        if iterable is not None:\n            self.extend(iterable)\n\n    def __resize_2x(self):\n        backup = list(self)\n        self._capacity *= 2\n        self._head = 0\n        self._tail = len(backup)\n        self._data.clear()\n        self._data.extend(backup)\n        self._data.extend([None] * (self._capacity - len(backup)))\n\n    def append(self, x: T):\n        self._data[self._tail] = x\n        self._tail = (self._tail + 1) % self._capacity\n        if (self._tail + 1) % self._capacity == self._head:\n            self.__resize_2x()\n\n    def appendleft(self, x: T):\n        self._head = (self._head - 1) % self._capacity\n        self._data[self._head] = x\n        if (self._tail + 1) % self._capacity == self._head:\n            self.__resize_2x()\n\n    def copy(self):\n        return deque(self)\n    \n    def count(self, x: T) -> int:\n        n = 0\n        for item in self:\n            if item == x:\n                n += 1\n        return n\n    \n    def extend(self, iterable: Iterable[T]):\n        for x in iterable:\n            self.append(x)\n\n    def extendleft(self, iterable: Iterable[T]):\n        for x in iterable:\n            self.appendleft(x)\n    \n    def pop(self) -> T:\n        if self._head == self._tail:\n            raise IndexError(\"pop from an empty deque\")\n        self._tail = (self._tail - 1) % self._capacity\n        return self._data[self._tail]\n    \n    def popleft(self) -> T:\n        if self._head == self._tail:\n            raise IndexError(\"pop from an empty deque\")\n        x = self._data[self._head]\n        self._head = (self._head + 1) % self._capacity\n        return x\n    \n    def clear(self):\n        i = self._head\n        while i != self._tail:\n            self._data[i] = None # type: ignore\n            i = (i + 1) % self._capacity\n        self._head = 0\n        self._tail = 0\n\n    def rotate(self, n: int = 1):\n        if len(self) == 0:\n            return\n        if n > 0:\n            n = n % len(self)\n            for _ in range(n):\n                self.appendleft(self.pop())\n        elif n < 0:\n            n = -n % len(self)\n            for _ in range(n):\n                self.append(self.popleft())\n\n    def __len__(self) -> int:\n        return (self._tail - self._head) % self._capacity\n\n    def __contains__(self, x: object) -> bool:\n        for item in self:\n            if item == x:\n                return True\n        return False\n    \n    def __iter__(self):\n        i = self._head\n        while i != self._tail:\n            yield self._data[i]\n            i = (i + 1) % self._capacity\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, deque):\n            return NotImplemented\n        if len(self) != len(other):\n            return False\n        for x, y in zip(self, other):\n            if x != y:\n                return False\n        return True\n    \n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, deque):\n            return NotImplemented\n        return not self == other\n    \n    def __repr__(self) -> str:\n        return f\"deque({list(self)!r})\"\n\n";
const char kPythonLibs_dataclasses[] = "def _get_annotations(cls: type):\n    inherits = []\n    while cls is not object:\n        inherits.append(cls)\n        cls = cls.__base__\n    inherits.reverse()\n    res = {}\n    for cls in inherits:\n        res.update(cls.__annotations__)\n    return res.keys()\n\ndef _wrapped__init__(self, *args, **kwargs):\n    cls = type(self)\n    cls_d = cls.__dict__\n    fields = _get_annotations(cls)\n    i = 0   # index into args\n    for field in fields:\n        if field in kwargs:\n            setattr(self, field, kwargs.pop(field))\n        else:\n            if i < len(args):\n                setattr(self, field, args[i])\n                i += 1\n            elif field in cls_d:    # has default value\n                setattr(self, field, cls_d[field])\n            else:\n                raise TypeError(f\"{cls.__name__} missing required argument {field!r}\")\n    if len(args) > i:\n        raise TypeError(f\"{cls.__name__} takes {len(fields)} positional arguments but {len(args)} were given\")\n    if len(kwargs) > 0:\n        raise TypeError(f\"{cls.__name__} got an unexpected keyword argument {next(iter(kwargs))!r}\")\n\ndef _wrapped__repr__(self):\n    fields = _get_annotations(type(self))\n    obj_d = self.__dict__\n    args: list = [f\"{field}={obj_d[field]!r}\" for field in fields]\n    return f\"{type(self).__name__}({', '.join(args)})\"\n\ndef _wrapped__eq__(self, other):\n    if type(self) is not type(other):\n        return False\n    fields = _get_annotations(type(self))\n    for field in fields:\n        if getattr(self, field) != getattr(other, field):\n            return False\n    return True\n\ndef _wrapped__ne__(self, other):\n    return not self.__eq__(other)\n\ndef dataclass(cls: type):\n    assert type(cls) is type\n    cls_d = cls.__dict__\n    if '__init__' not in cls_d:\n        cls.__init__ = _wrapped__init__\n    if '__repr__' not in cls_d:\n        cls.__repr__ = _wrapped__repr__\n    if '__eq__' not in cls_d:\n        cls.__eq__ = _wrapped__eq__\n    if '__ne__' not in cls_d:\n        cls.__ne__ = _wrapped__ne__\n    fields = _get_annotations(cls)\n    has_default = False\n    for field in fields:\n        if field in cls_d:\n            has_default = True\n        else:\n            if has_default:\n                raise TypeError(f\"non-default argument {field!r} follows default argument\")\n    return cls\n\ndef asdict(obj) -> dict:\n    fields = _get_annotations(type(obj))\n    obj_d = obj.__dict__\n    return {field: obj_d[field] for field in fields}";
const char kPythonLibs_datetime[] = "from time import localtime\nimport operator\n\nclass timedelta:\n    def __init__(self, days=0, seconds=0):\n        self.days = days\n        self.seconds = seconds\n\n    def __repr__(self):\n        return f\"datetime.timedelta(days={self.days}, seconds={self.seconds})\"\n\n    def __eq__(self, other) -> bool:\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        return (self.days, self.seconds) == (other.days, other.seconds)\n\n    def __ne__(self, other) -> bool:\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        return (self.days, self.seconds) != (other.days, other.seconds)\n\n\nclass date:\n    def __init__(self, year: int, month: int, day: int):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    @staticmethod\n    def today():\n        t = localtime()\n        return date(t.tm_year, t.tm_mon, t.tm_mday)\n    \n    def __cmp(self, other, op):\n        if not isinstance(other, date):\n            return NotImplemented\n        if self.year != other.year:\n            return op(self.year, other.year)\n        if self.month != other.month:\n            return op(self.month, other.month)\n        return op(self.day, other.day)\n\n    def __eq__(self, other) -> bool:\n        return self.__cmp(other, operator.eq)\n    \n    def __ne__(self, other) -> bool:\n        return self.__cmp(other, operator.ne)\n\n    def __lt__(self, other: 'date') -> bool:\n        return self.__cmp(other, operator.lt)\n\n    def __le__(self, other: 'date') -> bool:\n        return self.__cmp(other, operator.le)\n\n    def __gt__(self, other: 'date') -> bool:\n        return self.__cmp(other, operator.gt)\n\n    def __ge__(self, other: 'date') -> bool:\n        return self.__cmp(other, operator.ge)\n\n    def __str__(self):\n        return f\"{self.year}-{self.month:02}-{self.day:02}\"\n\n    def __repr__(self):\n        return f\"datetime.date({self.year}, {self.month}, {self.day})\"\n\n\nclass datetime(date):\n    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int):\n        super().__init__(year, month, day)\n        # Validate and set hour, minute, and second\n        if not 0 <= hour <= 23:\n            raise ValueError(\"Hour must be between 0 and 23\")\n        self.hour = hour\n        if not 0 <= minute <= 59:\n            raise ValueError(\"Minute must be between 0 and 59\")\n        self.minute = minute\n        if not 0 <= second <= 59:\n            raise ValueError(\"Second must be between 0 and 59\")\n        self.second = second\n\n    def date(self) -> date:\n        return date(self.year, self.month, self.day)\n\n    @staticmethod\n    def now():\n        t = localtime()\n        tm_sec = t.tm_sec\n        if tm_sec == 60:\n            tm_sec = 59\n        return datetime(t.tm_year, t.tm_mon, t.tm_mday, t.tm_hour, t.tm_min, tm_sec)\n\n    def __str__(self):\n        return f\"{self.year}-{self.month:02}-{self.day:02} {self.hour:02}:{self.minute:02}:{self.second:02}\"\n\n    def __repr__(self):\n        return f\"datetime.datetime({self.year}, {self.month}, {self.day}, {self.hour}, {self.minute}, {self.second})\"\n\n    def __cmp(self, other, op):\n        if not isinstance(other, datetime):\n            return NotImplemented\n        if self.year != other.year:\n            return op(self.year, other.year)\n        if self.month != other.month:\n            return op(self.month, other.month)\n        if self.day != other.day:\n            return op(self.day, other.day)\n        if self.hour != other.hour:\n            return op(self.hour, other.hour)\n        if self.minute != other.minute:\n            return op(self.minute, other.minute)\n        return op(self.second, other.second)\n\n    def __eq__(self, other) -> bool:\n        return self.__cmp(other, operator.eq)\n    \n    def __ne__(self, other) -> bool:\n        return self.__cmp(other, operator.ne)\n    \n    def __lt__(self, other) -> bool:\n        return self.__cmp(other, operator.lt)\n    \n    def __le__(self, other) -> bool:\n        return self.__cmp(other, operator.le)\n    \n    def __gt__(self, other) -> bool:\n        return self.__cmp(other, operator.gt)\n    \n    def __ge__(self, other) -> bool:\n        return self.__cmp(other, operator.ge)\n\n\n";
const char kPythonLibs_functools[] = "class cache:\n    def __init__(self, f):\n        self.f = f\n        self.cache = {}\n\n    def __call__(self, *args):\n        if args not in self.cache:\n            self.cache[args] = self.f(*args)\n        return self.cache[args]\n    \ndef reduce(function, sequence, initial=...):\n    it = iter(sequence)\n    if initial is ...:\n        try:\n            value = next(it)\n        except StopIteration:\n            raise TypeError(\"reduce() of empty sequence with no initial value\")\n    else:\n        value = initial\n    for element in it:\n        value = function(value, element)\n    return value\n\nclass partial:\n    def __init__(self, f, *args, **kwargs):\n        self.f = f\n        if not callable(f):\n            raise TypeError(\"the first argument must be callable\")\n        self.args = args\n        self.kwargs = kwargs\n\n    def __call__(self, *args, **kwargs):\n        kwargs.update(self.kwargs)\n        return self.f(*self.args, *args, **kwargs)\n\n";
const char kPythonLibs_heapq[] = "# Heap queue algorithm (a.k.a. priority queue)\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap)-1)\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\ndef heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup(heap, 0)\n    return returnitem\n\ndef heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\n\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n//2)):\n        _siftup(x, i)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2*pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2*pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)";
const char kPythonLibs_operator[] = "# https://docs.python.org/3/library/operator.html#mapping-operators-to-functions\n\ndef le(a, b): return a <= b\ndef lt(a, b): return a < b\ndef ge(a, b): return a >= b\ndef gt(a, b): return a > b\ndef eq(a, b): return a == b\ndef ne(a, b): return a != b\n\ndef and_(a, b): return a & b\ndef or_(a, b): return a | b\ndef xor(a, b): return a ^ b\ndef invert(a): return ~a\ndef lshift(a, b): return a << b\ndef rshift(a, b): return a >> b\n\ndef is_(a, b): return a is b\ndef is_not(a, b): return a is not b\ndef not_(a): return not a\ndef truth(a): return bool(a)\ndef contains(a, b): return b in a\n\ndef add(a, b): return a + b\ndef sub(a, b): return a - b\ndef mul(a, b): return a * b\ndef truediv(a, b): return a / b\ndef floordiv(a, b): return a // b\ndef mod(a, b): return a % b\ndef pow(a, b): return a ** b\ndef neg(a): return -a\ndef matmul(a, b): return a @ b\n\ndef getitem(a, b): return a[b]\ndef setitem(a, b, c): a[b] = c\ndef delitem(a, b): del a[b]\n\ndef iadd(a, b): a += b; return a\ndef isub(a, b): a -= b; return a\ndef imul(a, b): a *= b; return a\ndef itruediv(a, b): a /= b; return a\ndef ifloordiv(a, b): a //= b; return a\ndef imod(a, b): a %= b; return a\n# def ipow(a, b): a **= b; return a\n# def imatmul(a, b): a @= b; return a\ndef iand(a, b): a &= b; return a\ndef ior(a, b): a |= b; return a\ndef ixor(a, b): a ^= b; return a\ndef ilshift(a, b): a <<= b; return a\ndef irshift(a, b): a >>= b; return a\n";
const char kPythonLibs_typing[] = "class _Placeholder:\n    def __init__(self, *args, **kwargs):\n        pass\n    def __getitem__(self, *args):\n        return self\n    def __call__(self, *args, **kwargs):\n        return self\n    def __and__(self, other):\n        return self\n    def __or__(self, other):\n        return self\n    def __xor__(self, other):\n        return self\n\n\n_PLACEHOLDER = _Placeholder()\n\nList = _PLACEHOLDER\nDict = _PLACEHOLDER\nTuple = _PLACEHOLDER\nSet = _PLACEHOLDER\nAny = _PLACEHOLDER\nUnion = _PLACEHOLDER\nOptional = _PLACEHOLDER\nCallable = _PLACEHOLDER\nType = _PLACEHOLDER\nTypeAlias = _PLACEHOLDER\nNewType = _PLACEHOLDER\n\nLiteral = _PLACEHOLDER\nLiteralString = _PLACEHOLDER\n\nIterable = _PLACEHOLDER\nGenerator = _PLACEHOLDER\nIterator = _PLACEHOLDER\n\nHashable = _PLACEHOLDER\n\nTypeVar = _PLACEHOLDER\nSelf = _PLACEHOLDER\n\nProtocol = object\nGeneric = object\nNever = object\n\nTYPE_CHECKING = False\n\n# decorators\noverload = lambda x: x\nfinal = lambda x: x\n\n# exhaustiveness checking\nassert_never = lambda x: x\n";

const char* load_kPythonLib(const char* name) {
    if (strchr(name, '.') != NULL) return NULL;
    if (strcmp(name, "bisect") == 0) return kPythonLibs_bisect;
    if (strcmp(name, "builtins") == 0) return kPythonLibs_builtins;
    if (strcmp(name, "cmath") == 0) return kPythonLibs_cmath;
    if (strcmp(name, "collections") == 0) return kPythonLibs_collections;
    if (strcmp(name, "dataclasses") == 0) return kPythonLibs_dataclasses;
    if (strcmp(name, "datetime") == 0) return kPythonLibs_datetime;
    if (strcmp(name, "functools") == 0) return kPythonLibs_functools;
    if (strcmp(name, "heapq") == 0) return kPythonLibs_heapq;
    if (strcmp(name, "operator") == 0) return kPythonLibs_operator;
    if (strcmp(name, "typing") == 0) return kPythonLibs_typing;
    return NULL;
}

// src/common/vector.c
#include <stdlib.h>
#include <string.h>
void c11_vector__ctor(c11_vector* self, int elem_size) {
    self->data = NULL;
    self->length = 0;
    self->capacity = 0;
    self->elem_size = elem_size;
}

void c11_vector__dtor(c11_vector* self) {
    if(self->data) PK_FREE(self->data);
    self->data = NULL;
    self->length = 0;
    self->capacity = 0;
}

c11_vector c11_vector__copy(const c11_vector* self) {
    c11_vector retval;
    c11_vector__ctor(&retval, self->elem_size);
    c11_vector__reserve(&retval, self->capacity);
    memcpy(retval.data, self->data, (size_t)self->elem_size * (size_t)self->length);
    retval.length = self->length;
    return retval;
}

void c11_vector__reserve(c11_vector* self, int capacity) {
    if(capacity < 4) capacity = 4;
    if(capacity <= self->capacity) return;
    // self->elem_size * capacity may overflow
    self->data = PK_REALLOC(self->data, (size_t)self->elem_size * (size_t)capacity);
    if(self->data == NULL) c11__abort("c11_vector__reserve(): out of memory");
    self->capacity = capacity;
}

void c11_vector__clear(c11_vector* self) { self->length = 0; }

void* c11_vector__emplace(c11_vector* self) {
    if(self->length == self->capacity) c11_vector__reserve(self, self->capacity * 2);
    void* p = (char*)self->data + (size_t)self->elem_size * (size_t)self->length;
    self->length++;
    return p;
}

bool c11_vector__contains(const c11_vector* self, void* elem) {
    for(int i = 0; i < self->length; i++) {
        void* p = (char*)self->data + (size_t)self->elem_size * (size_t)i;
        if(memcmp(p, elem, self->elem_size) == 0) return true;
    }
    return false;
}

void* c11_vector__submit(c11_vector* self, int* length) {
    void* retval = self->data;
    *length = self->length;
    self->data = NULL;
    self->length = 0;
    self->capacity = 0;
    return retval;
}

void c11_vector__swap(c11_vector *self, c11_vector *other){
    c11_vector tmp = *self;
    *self = *other;
    *other = tmp;
}

// src/common/str.c
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>

c11_string* c11_string__new(const char* data) { return c11_string__new2(data, strlen(data)); }

c11_string* c11_string__new2(const char* data, int size) {
    c11_string* retval = PK_MALLOC(sizeof(c11_string) + size + 1);
    c11_string__ctor2(retval, data, size);
    return retval;
}

c11_string* c11_string__new3(const char* fmt, ...) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    va_list args;
    va_start(args, fmt);
    // c11_sbuf__write_vfmt(&buf, fmt, args);
    pk_vsprintf(&buf, fmt, args);
    va_end(args);
    return c11_sbuf__submit(&buf);
}

void c11_string__ctor(c11_string* self, const char* data) {
    c11_string__ctor2(self, data, strlen(data));
}

void c11_string__ctor2(c11_string* self, const char* data, int size) {
    self->size = size;
    char* p = (char*)self->data;
    memcpy(p, data, size);
    p[size] = '\0';
}

void c11_string__ctor3(c11_string* self, int size) {
    self->size = size;
    char* p = (char*)self->data;
    p[size] = '\0';
}

c11_string* c11_string__copy(c11_string* self) {
    int total_size = sizeof(c11_string) + self->size + 1;
    c11_string* retval = PK_MALLOC(total_size);
    memcpy(retval, self, total_size);
    return retval;
}

void c11_string__delete(c11_string* self) { PK_FREE(self); }

c11_sv c11_string__sv(c11_string* self) { return (c11_sv){self->data, self->size}; }

c11_string* c11_sv__replace(c11_sv self, char old, char new_) {
    c11_string* retval = c11_string__new2(self.data, self.size);
    char* p = (char*)retval->data;
    for(int i = 0; i < retval->size; i++) {
        if(p[i] == old) p[i] = new_;
    }
    return retval;
}

c11_string* c11_sv__replace2(c11_sv self, c11_sv old, c11_sv new_) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    int start = 0;
    while(true) {
        int i = c11_sv__index2(self, old, start);
        if(i == -1) break;
        c11_sv tmp = c11_sv__slice2(self, start, i);
        c11_sbuf__write_sv(&buf, tmp);
        c11_sbuf__write_sv(&buf, new_);
        start = i + old.size;
    }
    c11_sv tmp = c11_sv__slice2(self, start, self.size);
    c11_sbuf__write_sv(&buf, tmp);
    return c11_sbuf__submit(&buf);
}

int c11_sv__u8_length(c11_sv sv) { return c11__byte_index_to_unicode(sv.data, sv.size); }

c11_sv c11_sv__u8_getitem(c11_sv sv, int i) {
    i = c11__unicode_index_to_byte(sv.data, i);
    int size = c11__u8_header(sv.data[i], false);
    return c11_sv__slice2(sv, i, i + size);
}

c11_string* c11_sv__u8_slice(c11_sv sv, int start, int stop, int step) {
    c11_sbuf ss;
    c11_sbuf__ctor(&ss);
    assert(step != 0);
    for(int i = start; step > 0 ? i < stop : i > stop; i += step) {
        c11_sv unicode = c11_sv__u8_getitem(sv, i);
        c11_sbuf__write_sv(&ss, unicode);
    }
    return c11_sbuf__submit(&ss);
}

/////////////////////////////////////////
c11_sv c11_sv__slice(c11_sv sv, int start) { return c11_sv__slice2(sv, start, sv.size); }

c11_sv c11_sv__slice2(c11_sv sv, int start, int stop) {
    if(start < 0) start = 0;
    if(stop < start) stop = start;
    if(stop > sv.size) stop = sv.size;
    return (c11_sv){sv.data + start, stop - start};
}

c11_sv c11_sv__strip(c11_sv sv, c11_sv chars, bool left, bool right) {
    int L = 0;
    int R = c11_sv__u8_length(sv);
    if(left) {
        while(L < R) {
            c11_sv tmp = c11_sv__u8_getitem(sv, L);
            bool found = c11_sv__index2(chars, tmp, 0) != -1;
            if(!found) break;
            L++;
        }
    }
    if(right) {
        while(L < R) {
            c11_sv tmp = c11_sv__u8_getitem(sv, R - 1);
            bool found = c11_sv__index2(chars, tmp, 0) != -1;
            if(!found) break;
            R--;
        }
    }
    int start = c11__unicode_index_to_byte(sv.data, L);
    int stop = c11__unicode_index_to_byte(sv.data, R);
    return c11_sv__slice2(sv, start, stop);
}

int c11_sv__index(c11_sv self, char c) {
    for(int i = 0; i < self.size; i++) {
        if(self.data[i] == c) return i;
    }
    return -1;
}

int c11_sv__rindex(c11_sv self, char c) {
    for(int i = self.size - 1; i >= 0; i--) {
        if(self.data[i] == c) return i;
    }
    return -1;
}

int c11_sv__index2(c11_sv self, c11_sv sub, int start) {
    if(sub.size == 0) return start;
    int max_end = self.size - sub.size;
    for(int i = start; i <= max_end; i++) {
        int res = memcmp(self.data + i, sub.data, sub.size);
        if(res == 0) return i;
    }
    return -1;
}

int c11_sv__count(c11_sv self, c11_sv sub) {
    if(sub.size == 0) return self.size + 1;
    int cnt = 0;
    int start = 0;
    while(true) {
        int i = c11_sv__index2(self, sub, start);
        if(i == -1) break;
        cnt++;
        start = i + sub.size;
    }
    return cnt;
}

bool c11_sv__startswith(c11_sv self, c11_sv prefix) {
    if(prefix.size > self.size) return false;
    return memcmp(self.data, prefix.data, prefix.size) == 0;
}

bool c11_sv__endswith(c11_sv self, c11_sv suffix) {
    if(suffix.size > self.size) return false;
    return memcmp(self.data + self.size - suffix.size, suffix.data, suffix.size) == 0;
}

c11_vector /* T=c11_sv */ c11_sv__split(c11_sv self, char sep) {
    c11_vector retval;
    c11_vector__ctor(&retval, sizeof(c11_sv));
    const char* data = self.data;
    int i = 0;
    for(int j = 0; j < self.size; j++) {
        if(data[j] == sep) {
            assert(j >= i);
            c11_sv tmp = {data + i, j - i};
            c11_vector__push(c11_sv, &retval, tmp);
            i = j + 1;
        }
    }
    if(i <= self.size) {
        c11_sv tmp = {data + i, self.size - i};
        c11_vector__push(c11_sv, &retval, tmp);
    }
    return retval;
}

c11_vector /* T=c11_sv */ c11_sv__split2(c11_sv self, c11_sv sep) {
    if(sep.size == 1) return c11_sv__split(self, sep.data[0]);
    c11_vector retval;
    c11_vector__ctor(&retval, sizeof(c11_sv));
    int start = 0;
    const char* data = self.data;
    while(true) {
        int i = c11_sv__index2(self, sep, start);
        if(i == -1) break;
        c11_sv tmp = {data + start, i - start};
        c11_vector__push(c11_sv, &retval, tmp);
        start = i + sep.size;
    }
    c11_sv tmp = {data + start, self.size - start};
    c11_vector__push(c11_sv, &retval, tmp);
    return retval;
}

int c11__unicode_index_to_byte(const char* data, int i) {
    int j = 0;
    while(i > 0) {
        j += c11__u8_header(data[j], false);
        i--;
    }
    return j;
}

int c11__byte_index_to_unicode(const char* data, int n) {
    int cnt = 0;
    for(int i = 0; i < n; i++) {
        if((data[i] & 0xC0) != 0x80) cnt++;
    }
    return cnt;
}

//////////////
bool c11_bytes__eq(c11_bytes* self, c11_bytes* other) {
    if(self->size != other->size) return false;
    return memcmp(self->data, other->data, self->size) == 0;
}

int c11_sv__cmp(c11_sv self, c11_sv other) {
    int res = strncmp(self.data, other.data, c11__min(self.size, other.size));
    if(res != 0) return res;
    return self.size - other.size;
}

int c11_sv__cmp2(c11_sv self, const char* other) {
    int size = strlen(other);
    int res = strncmp(self.data, other, c11__min(self.size, size));
    if(res != 0) return res;
    return self.size - size;
}

bool c11__streq(const char* a, const char* b) { return strcmp(a, b) == 0; }

bool c11__sveq(c11_sv a, c11_sv b) {
    if(a.size != b.size) return false;
    return memcmp(a.data, b.data, a.size) == 0;
}

bool c11__sveq2(c11_sv a, const char* b) {
    int size = strlen(b);
    if(a.size != size) return false;
    return memcmp(a.data, b, size) == 0;
}

// clang-format off
static const int kLoRangeA[] = {170,186,443,448,660,1488,1519,1568,1601,1646,1649,1749,1774,1786,1791,1808,1810,1869,1969,1994,2048,2112,2144,2208,2230,2308,2365,2384,2392,2418,2437,2447,2451,2474,2482,2486,2493,2510,2524,2527,2544,2556,2565,2575,2579,2602,2610,2613,2616,2649,2654,2674,2693,2703,2707,2730,2738,2741,2749,2768,2784,2809,2821,2831,2835,2858,2866,2869,2877,2908,2911,2929,2947,2949,2958,2962,2969,2972,2974,2979,2984,2990,3024,3077,3086,3090,3114,3133,3160,3168,3200,3205,3214,3218,3242,3253,3261,3294,3296,3313,3333,3342,3346,3389,3406,3412,3423,3450,3461,3482,3507,3517,3520,3585,3634,3648,3713,3716,3718,3724,3749,3751,3762,3773,3776,3804,3840,3904,3913,3976,4096,4159,4176,4186,4193,4197,4206,4213,4238,4352,4682,4688,4696,4698,4704,4746,4752,4786,4792,4800,4802,4808,4824,4882,4888,4992,5121,5743,5761,5792,5873,5888,5902,5920,5952,5984,5998,6016,6108,6176,6212,6272,6279,6314,6320,6400,6480,6512,6528,6576,6656,6688,6917,6981,7043,7086,7098,7168,7245,7258,7401,7406,7413,7418,8501,11568,11648,11680,11688,11696,11704,11712,11720,11728,11736,12294,12348,12353,12447,12449,12543,12549,12593,12704,12784,13312,19968,40960,40982,42192,42240,42512,42538,42606,42656,42895,42999,43003,43011,43015,43020,43072,43138,43250,43259,43261,43274,43312,43360,43396,43488,43495,43514,43520,43584,43588,43616,43633,43642,43646,43697,43701,43705,43712,43714,43739,43744,43762,43777,43785,43793,43808,43816,43968,44032,55216,55243,63744,64112,64285,64287,64298,64312,64318,64320,64323,64326,64467,64848,64914,65008,65136,65142,65382,65393,65440,65474,65482,65490,65498,65536,65549,65576,65596,65599,65616,65664,66176,66208,66304,66349,66370,66384,66432,66464,66504,66640,66816,66864,67072,67392,67424,67584,67592,67594,67639,67644,67647,67680,67712,67808,67828,67840,67872,67968,68030,68096,68112,68117,68121,68192,68224,68288,68297,68352,68416,68448,68480,68608,68864,69376,69415,69424,69600,69635,69763,69840,69891,69956,69968,70006,70019,70081,70106,70108,70144,70163,70272,70280,70282,70287,70303,70320,70405,70415,70419,70442,70450,70453,70461,70480,70493,70656,70727,70751,70784,70852,70855,71040,71128,71168,71236,71296,71352,71424,71680,71935,72096,72106,72161,72163,72192,72203,72250,72272,72284,72349,72384,72704,72714,72768,72818,72960,72968,72971,73030,73056,73063,73066,73112,73440,73728,74880,77824,82944,92160,92736,92880,92928,93027,93053,93952,94032,94208,100352,110592,110928,110948,110960,113664,113776,113792,113808,123136,123214,123584,124928,126464,126469,126497,126500,126503,126505,126516,126521,126523,126530,126535,126537,126539,126541,126545,126548,126551,126553,126555,126557,126559,126561,126564,126567,126572,126580,126585,126590,126592,126603,126625,126629,126635,131072,173824,177984,178208,183984,194560};
static const int kLoRangeB[] = {170,186,443,451,660,1514,1522,1599,1610,1647,1747,1749,1775,1788,1791,1808,1839,1957,1969,2026,2069,2136,2154,2228,2237,2361,2365,2384,2401,2432,2444,2448,2472,2480,2482,2489,2493,2510,2525,2529,2545,2556,2570,2576,2600,2608,2611,2614,2617,2652,2654,2676,2701,2705,2728,2736,2739,2745,2749,2768,2785,2809,2828,2832,2856,2864,2867,2873,2877,2909,2913,2929,2947,2954,2960,2965,2970,2972,2975,2980,2986,3001,3024,3084,3088,3112,3129,3133,3162,3169,3200,3212,3216,3240,3251,3257,3261,3294,3297,3314,3340,3344,3386,3389,3406,3414,3425,3455,3478,3505,3515,3517,3526,3632,3635,3653,3714,3716,3722,3747,3749,3760,3763,3773,3780,3807,3840,3911,3948,3980,4138,4159,4181,4189,4193,4198,4208,4225,4238,4680,4685,4694,4696,4701,4744,4749,4784,4789,4798,4800,4805,4822,4880,4885,4954,5007,5740,5759,5786,5866,5880,5900,5905,5937,5969,5996,6000,6067,6108,6210,6264,6276,6312,6314,6389,6430,6509,6516,6571,6601,6678,6740,6963,6987,7072,7087,7141,7203,7247,7287,7404,7411,7414,7418,8504,11623,11670,11686,11694,11702,11710,11718,11726,11734,11742,12294,12348,12438,12447,12538,12543,12591,12686,12730,12799,19893,40943,40980,42124,42231,42507,42527,42539,42606,42725,42895,42999,43009,43013,43018,43042,43123,43187,43255,43259,43262,43301,43334,43388,43442,43492,43503,43518,43560,43586,43595,43631,43638,43642,43695,43697,43702,43709,43712,43714,43740,43754,43762,43782,43790,43798,43814,43822,44002,55203,55238,55291,64109,64217,64285,64296,64310,64316,64318,64321,64324,64433,64829,64911,64967,65019,65140,65276,65391,65437,65470,65479,65487,65495,65500,65547,65574,65594,65597,65613,65629,65786,66204,66256,66335,66368,66377,66421,66461,66499,66511,66717,66855,66915,67382,67413,67431,67589,67592,67637,67640,67644,67669,67702,67742,67826,67829,67861,67897,68023,68031,68096,68115,68119,68149,68220,68252,68295,68324,68405,68437,68466,68497,68680,68899,69404,69415,69445,69622,69687,69807,69864,69926,69956,70002,70006,70066,70084,70106,70108,70161,70187,70278,70280,70285,70301,70312,70366,70412,70416,70440,70448,70451,70457,70461,70480,70497,70708,70730,70751,70831,70853,70855,71086,71131,71215,71236,71338,71352,71450,71723,71935,72103,72144,72161,72163,72192,72242,72250,72272,72329,72349,72440,72712,72750,72768,72847,72966,72969,73008,73030,73061,73064,73097,73112,73458,74649,75075,78894,83526,92728,92766,92909,92975,93047,93071,94026,94032,100343,101106,110878,110930,110951,111355,113770,113788,113800,113817,123180,123214,123627,125124,126467,126495,126498,126500,126503,126514,126519,126521,126523,126530,126535,126537,126539,126543,126546,126548,126551,126553,126555,126557,126559,126562,126564,126570,126578,126583,126588,126590,126601,126619,126627,126633,126651,173782,177972,178205,183969,191456,195101};

// clang-format on

bool c11__is_unicode_Lo_char(int c) {
    if(c == 0x1f955) return true;
    int index;
    c11__lower_bound(const int, kLoRangeA, 476, c, c11__less, &index);
    if(index == 476) return false;
    if(c == kLoRangeA[index]) return true;
    index -= 1;
    if(index < 0) return false;
    return c >= kLoRangeA[index] && c <= kLoRangeB[index];
}

int c11__u8_header(unsigned char c, bool suppress) {
    if((c & 0b10000000) == 0) return 1;
    if((c & 0b11100000) == 0b11000000) return 2;
    if((c & 0b11110000) == 0b11100000) return 3;
    if((c & 0b11111000) == 0b11110000) return 4;
    if((c & 0b11111100) == 0b11111000) return 5;
    if((c & 0b11111110) == 0b11111100) return 6;
    if(!suppress) c11__abort("invalid utf8 char");
    return 0;
}

int c11__u8_value(int u8bytes, const char* data) {
    assert(u8bytes != 0);
    if(u8bytes == 1) return (int)data[0];
    uint32_t value = 0;
    for(int k = 0; k < u8bytes; k++) {
        uint8_t b = data[k];
        if(k == 0) {
            if(u8bytes == 2)
                value = (b & 0b00011111) << 6;
            else if(u8bytes == 3)
                value = (b & 0b00001111) << 12;
            else if(u8bytes == 4)
                value = (b & 0b00000111) << 18;
        } else {
            value |= (b & 0b00111111) << (6 * (u8bytes - k - 1));
        }
    }
    return (int)value;
}

int c11__u32_to_u8(uint32_t utf32_char, char utf8_output[4]) {
    int length = 0;

    if(utf32_char <= 0x7F) {
        // 1-byte UTF-8
        utf8_output[0] = (char)utf32_char;
        length = 1;
    } else if(utf32_char <= 0x7FF) {
        // 2-byte UTF-8
        utf8_output[0] = (char)(0xC0 | ((utf32_char >> 6) & 0x1F));
        utf8_output[1] = (char)(0x80 | (utf32_char & 0x3F));
        length = 2;
    } else if(utf32_char <= 0xFFFF) {
        // 3-byte UTF-8
        utf8_output[0] = (char)(0xE0 | ((utf32_char >> 12) & 0x0F));
        utf8_output[1] = (char)(0x80 | ((utf32_char >> 6) & 0x3F));
        utf8_output[2] = (char)(0x80 | (utf32_char & 0x3F));
        length = 3;
    } else if(utf32_char <= 0x10FFFF) {
        // 4-byte UTF-8
        utf8_output[0] = (char)(0xF0 | ((utf32_char >> 18) & 0x07));
        utf8_output[1] = (char)(0x80 | ((utf32_char >> 12) & 0x3F));
        utf8_output[2] = (char)(0x80 | ((utf32_char >> 6) & 0x3F));
        utf8_output[3] = (char)(0x80 | (utf32_char & 0x3F));
        length = 4;
    } else {
        // Invalid UTF-32 character
        return -1;
    }
    return length;
}

IntParsingResult c11__parse_uint(c11_sv text, int64_t* out, int base) {
    *out = 0;

    c11_sv prefix = {.data = text.data, .size = c11__min(2, text.size)};
    if(base == -1) {
        if(c11__sveq2(prefix, "0b"))
            base = 2;
        else if(c11__sveq2(prefix, "0o"))
            base = 8;
        else if(c11__sveq2(prefix, "0x"))
            base = 16;
        else
            base = 10;
    }

    if(base == 10) {
        // 10-base  12334
        if(text.size == 0) return IntParsing_FAILURE;
        for(int i = 0; i < text.size; i++) {
            char c = text.data[i];
            if(c >= '0' && c <= '9') {
                *out = (*out * 10) + (c - '0');
            } else {
                return IntParsing_FAILURE;
            }
        }
        // "9223372036854775807".__len__() == 19
        if(text.size > 19) return IntParsing_OVERFLOW;
        return IntParsing_SUCCESS;
    } else if(base == 2) {
        // 2-base   0b101010
        if(c11__sveq2(prefix, "0b")) {
            // text.remove_prefix(2);
            text = (c11_sv){text.data + 2, text.size - 2};
        }
        if(text.size == 0) return IntParsing_FAILURE;
        for(int i = 0; i < text.size; i++) {
            char c = text.data[i];
            if(c == '0' || c == '1') {
                *out = (*out << 1) | (c - '0');
            } else {
                return IntParsing_FAILURE;
            }
        }
        // "111111111111111111111111111111111111111111111111111111111111111".__len__() == 63
        if(text.size > 63) return IntParsing_OVERFLOW;
        return IntParsing_SUCCESS;
    } else if(base == 8) {
        // 8-base   0o123
        if(c11__sveq2(prefix, "0o")) {
            // text.remove_prefix(2);
            text = (c11_sv){text.data + 2, text.size - 2};
        }
        if(text.size == 0) return IntParsing_FAILURE;
        for(int i = 0; i < text.size; i++) {
            char c = text.data[i];
            if(c >= '0' && c <= '7') {
                *out = (*out << 3) | (c - '0');
            } else {
                return IntParsing_FAILURE;
            }
        }
        // "777777777777777777777".__len__() == 21
        if(text.size > 21) return IntParsing_OVERFLOW;
        return IntParsing_SUCCESS;
    } else if(base == 16) {
        // 16-base  0x123
        if(c11__sveq2(prefix, "0x")) {
            // text.remove_prefix(2);
            text = (c11_sv){text.data + 2, text.size - 2};
        }
        if(text.size == 0) return IntParsing_FAILURE;
        for(int i = 0; i < text.size; i++) {
            char c = text.data[i];
            if(c >= '0' && c <= '9') {
                *out = (*out << 4) | (c - '0');
            } else if(c >= 'a' && c <= 'f') {
                *out = (*out << 4) | (c - 'a' + 10);
            } else if(c >= 'A' && c <= 'F') {
                *out = (*out << 4) | (c - 'A' + 10);
            } else {
                return IntParsing_FAILURE;
            }
        }
        // "7fffffffffffffff".__len__() == 16
        if(text.size > 16) return IntParsing_OVERFLOW;
        return IntParsing_SUCCESS;
    }
    return IntParsing_FAILURE;
}
// src/common/memorypool.c
#include <stdlib.h>
#include <stdbool.h>

void FixedMemoryPool__ctor(FixedMemoryPool* self, int BlockSize, int BlockCount) {
    self->BlockSize = BlockSize;
    self->BlockCount = BlockCount;
    self->exceeded_bytes = 0;
    self->data = PK_MALLOC(BlockSize * BlockCount);
    self->data_end = self->data + BlockSize * BlockCount;
    self->_free_list = PK_MALLOC(sizeof(void*) * BlockCount);
    self->_free_list_length = BlockCount;
    for(int i = 0; i < BlockCount; i++) {
        self->_free_list[i] = self->data + i * BlockSize;
    }
}

void FixedMemoryPool__dtor(FixedMemoryPool* self) {
    PK_FREE(self->_free_list);
    PK_FREE(self->data);
}

void* FixedMemoryPool__alloc(FixedMemoryPool* self) {
    if(self->_free_list_length > 0) {
        self->_free_list_length--;
        return self->_free_list[self->_free_list_length];
    } else {
        self->exceeded_bytes += self->BlockSize;
        return PK_MALLOC(self->BlockSize);
    }
}

void FixedMemoryPool__dealloc(FixedMemoryPool* self, void* p) {
    bool is_valid = (char*)p >= self->data && (char*)p < self->data_end;
    if(is_valid) {
        self->_free_list[self->_free_list_length] = p;
        self->_free_list_length++;
    } else {
        self->exceeded_bytes -= self->BlockSize;
        PK_FREE(p);
    }
}

// static int FixedMemoryPool__used_bytes(FixedMemoryPool* self) {
//     return (self->_free_list_end - self->_free_list) * self->BlockSize;
// }

// static int FixedMemoryPool__total_bytes(FixedMemoryPool* self) {
//     return self->BlockCount * self->BlockSize;
// }
// src/common/smallmap.c
#define SMALLMAP_T__SOURCE
#define K uint16_t
#define V int
#define NAME c11_smallmap_n2i
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__SOURCE


#define SMALLMAP_T__SOURCE
#define K c11_sv
#define V uint16_t
#define NAME c11_smallmap_s2n
#define less(a, b)      (c11_sv__cmp((a), (b)) <  0)
#define equal(a, b)     (c11_sv__cmp((a), (b)) == 0)
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__SOURCE


#define SMALLMAP_T__SOURCE
#define K void*
#define V int
#define NAME c11_smallmap_p2i
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__SOURCE

// src/common/sstream.c
#include <stdarg.h>
#include <stdio.h>
#include <assert.h>
#include <ctype.h>
#include <math.h>

void c11_sbuf__ctor(c11_sbuf* self) {
    c11_vector__ctor(&self->data, sizeof(char));
    c11_vector__reserve(&self->data, sizeof(c11_string) + 100);
    self->data.length = sizeof(c11_string);
}

void c11_sbuf__dtor(c11_sbuf* self) { c11_vector__dtor(&self->data); }

void c11_sbuf__write_char(c11_sbuf* self, char c) { c11_vector__push(char, &self->data, c); }

void c11_sbuf__write_pad(c11_sbuf* self, int count, char pad) {
    for(int i = 0; i < count; i++) {
        c11_sbuf__write_char(self, pad);
    }
}

void c11_sbuf__write_int(c11_sbuf* self, int i) {
    // len('-2147483648') == 11
    c11_vector__reserve(&self->data, self->data.length + 11 + 1);
    char* p = (char*)self->data.data + self->data.length;
    int n = snprintf(p, 11 + 1, "%d", i);
    self->data.length += n;
}

void c11_sbuf__write_i64(c11_sbuf* self, int64_t val) {
    // len('-9223372036854775808') == 20
    c11_vector__reserve(&self->data, self->data.length + 20 + 1);
    char* p = (char*)self->data.data + self->data.length;
    int n = snprintf(p, 20 + 1, "%lld", (long long)val);
    self->data.length += n;
}

void c11_sbuf__write_f64(c11_sbuf* self, double val, int precision) {
    if(isinf(val)) {
        c11_sbuf__write_cstr(self, val > 0 ? "inf" : "-inf");
        return;
    }
    if(isnan(val)) {
        c11_sbuf__write_cstr(self, "nan");
        return;
    }
    char b[32];
    int size;
    if(precision < 0) {
        int prec = 17 - 1;  // std::numeric_limits<double>::max_digits10 == 17
        size = snprintf(b, sizeof(b), "%.*g", prec, val);
    } else {
        int prec = precision;
        size = snprintf(b, sizeof(b), "%.*f", prec, val);
    }
    c11_sbuf__write_cstr(self, b);
    bool all_is_digit = true;
    for(int i = 1; i < size; i++) {
        if(!isdigit(b[i])) {
            all_is_digit = false;
            break;
        }
    }
    if(all_is_digit) c11_sbuf__write_cstr(self, ".0");
}

void c11_sbuf__write_sv(c11_sbuf* self, c11_sv sv) {
    c11_sbuf__write_cstrn(self, sv.data, sv.size);
}

void c11_sbuf__write_cstr(c11_sbuf* self, const char* str) {
    c11_sbuf__write_cstrn(self, str, strlen(str));
}

void c11_sbuf__write_cstrn(c11_sbuf* self, const char* str, int n) {
    c11_vector__extend(char, &self->data, str, n);
}

void c11_sbuf__write_quoted(c11_sbuf* self, c11_sv sv, char quote) {
    assert(quote == '"' || quote == '\'');
    c11_sbuf__write_char(self, quote);
    for(int i = 0; i < sv.size; i++) {
        char c = sv.data[i];
        switch(c) {
            case '"':
            case '\'':
                if(c == quote) c11_sbuf__write_char(self, '\\');
                c11_sbuf__write_char(self, c);
                break;
            case '\\': c11_sbuf__write_cstrn(self, "\\\\", 2); break;
            case '\n': c11_sbuf__write_cstrn(self, "\\n", 2); break;
            case '\r': c11_sbuf__write_cstrn(self, "\\r", 2); break;
            case '\t': c11_sbuf__write_cstrn(self, "\\t", 2); break;
            case '\b': c11_sbuf__write_cstrn(self, "\\b", 2); break;
            default: {
                int u8bytes = c11__u8_header(c, true);
                if(i + u8bytes > sv.size) u8bytes = 0;  // invalid utf8
                if(u8bytes <= 1) {
                    // not a valid utf8 char, or ascii
                    if(!isprint((unsigned char)c)) {
                        unsigned char uc = (unsigned char)c;
                        c11_sbuf__write_cstrn(self, "\\x", 2);
                        c11_sbuf__write_char(self, PK_HEX_TABLE[uc >> 4]);
                        c11_sbuf__write_char(self, PK_HEX_TABLE[uc & 0xf]);
                    } else {
                        c11_sbuf__write_char(self, c);
                    }
                } else {
                    for(int j = 0; j < u8bytes; j++) {
                        c11_sbuf__write_char(self, sv.data[i + j]);
                    }
                    i += u8bytes - 1;
                }
                break;
            }
        }
    }
    c11_sbuf__write_char(self, quote);
}

void c11_sbuf__write_hex(c11_sbuf* self, unsigned char c, bool non_zero) {
    unsigned char high = c >> 4;
    unsigned char low = c & 0xf;
    if(non_zero) {
        if(high) c11_sbuf__write_char(self, PK_HEX_TABLE[high]);
        if(high || low) c11_sbuf__write_char(self, PK_HEX_TABLE[low]);
    } else {
        c11_sbuf__write_char(self, PK_HEX_TABLE[high]);
        c11_sbuf__write_char(self, PK_HEX_TABLE[low]);
    }
}

void c11_sbuf__write_ptr(c11_sbuf* self, void* p) {
    if(p == NULL) {
        c11_sbuf__write_cstr(self, "0x0");
        return;
    }
    c11_sbuf__write_cstr(self, "0x");
    uintptr_t p_t = (uintptr_t)(p);
    bool non_zero = true;
    for(int i = sizeof(void*) - 1; i >= 0; i--) {
        unsigned char cpnt = (p_t >> (i * 8)) & 0xff;
        c11_sbuf__write_hex(self, cpnt, non_zero);
        if(cpnt != 0) non_zero = false;
    }
}

c11_string* c11_sbuf__submit(c11_sbuf* self) {
    c11_vector__push(char, &self->data, '\0');
    int arr_length;
    c11_string* retval = c11_vector__submit(&self->data, &arr_length);
    retval->size = arr_length - sizeof(c11_string) - 1;
    return retval;
}

void c11_sbuf__py_submit(c11_sbuf* self, py_Ref out) {
    c11_string* res = c11_sbuf__submit(self);
    py_newstrv(out, (c11_sv){res->data, res->size});
    c11_string__delete(res);
}

void pk_vsprintf(c11_sbuf* ss, const char* fmt, va_list args) {
    while(*fmt) {
        char c = *fmt;
        if(c != '%') {
            c11_sbuf__write_char(ss, c);
            fmt++;
            continue;
        }

        fmt++;
        c = *fmt;

        switch(c) {
            case 'd': {
                int i = va_arg(args, int);
                c11_sbuf__write_int(ss, i);
                break;
            }
            case 'i': {
                int64_t i = va_arg(args, int64_t);
                c11_sbuf__write_i64(ss, i);
                break;
            }
            case 'f': {
                double d = va_arg(args, double);
                c11_sbuf__write_f64(ss, d, -1);
                break;
            }
            case 's': {
                const char* s = va_arg(args, const char*);
                c11_sbuf__write_cstr(ss, s);
                break;
            }
            case 'q': {
                c11_sv sv = va_arg(args, c11_sv);
                c11_sbuf__write_quoted(ss, sv, '\'');
                break;
            }
            case 'v': {
                c11_sv sv = va_arg(args, c11_sv);
                c11_sbuf__write_sv(ss, sv);
                break;
            }
            case 'c': {
                char c = va_arg(args, int);
                c11_sbuf__write_char(ss, c);
                break;
            }
            case 'p': {
                void* p = va_arg(args, void*);
                c11_sbuf__write_ptr(ss, p);
                break;
            }
            case 't': {
                py_Type t = va_arg(args, int);
                c11_sbuf__write_cstr(ss, py_tpname(t));
                break;
            }
            case 'n': {
                py_Name n = va_arg(args, int);
                c11_sbuf__write_cstr(ss, py_name2str(n));
                break;
            }
            case '%': c11_sbuf__write_char(ss, '%'); break;
            default:
                c11_sbuf__write_char(ss, c);
                assert(false);  // invalid format
                break;
        }
        fmt++;
    }
}

void pk_sprintf(c11_sbuf* ss, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    pk_vsprintf(ss, fmt, args);
    va_end(args);
}

// src/common/algorithm.c
#include <string.h>
#include <stdlib.h>

static bool _stable_sort_merge(char* a,
                  char* a_end,
                  char* b,
                  char* b_end,
                  char* r,
                  int elem_size,
                  int (*f_lt)(const void* a, const void* b, void* extra),
                  void* extra) {
    while(a < a_end && b < b_end) {
        int res = f_lt(a, b, extra);
        // check error
        if(res == -1) return false;
        if(res) {
            memcpy(r, a, elem_size);
            a += elem_size;
        } else {
            memcpy(r, b, elem_size);
            b += elem_size;
        }
        r += elem_size;
    }

    // one of the arrays is empty
    for(; a < a_end; a += elem_size, r += elem_size)
        memcpy(r, a, elem_size);
    for(; b < b_end; b += elem_size, r += elem_size)
        memcpy(r, b, elem_size);
    return true;
}

bool c11__stable_sort(void* ptr_,
                      int length,
                      int elem_size,
                      int (*f_lt)(const void* a, const void* b, void* extra),
                      void* extra) {
    // merge sort
    char *ptr = ptr_, *tmp = PK_MALLOC(length * elem_size);
    for(int seg = 1; seg < length; seg *= 2) {
        for(char* a = ptr; a < ptr + (length - seg) * elem_size; a += 2 * seg * elem_size) {
            char *b = a + seg * elem_size, *a_end = b, *b_end = b + seg * elem_size;
            if(b_end > ptr + length * elem_size) b_end = ptr + length * elem_size;
            bool ok = _stable_sort_merge(a, a_end, b, b_end, tmp, elem_size, f_lt, extra);
            if(!ok) {
                PK_FREE(tmp);
                return false;
            }
            memcpy(a, tmp, b_end - a);
        }
    }
    PK_FREE(tmp);
    return true;
}

// src/common/sourcedata.c
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

static void SourceData__ctor(struct SourceData* self,
                             const char* source,
                             const char* filename,
                             enum py_CompileMode mode,
                             bool is_dynamic) {
    self->filename = c11_string__new(filename);
    self->mode = mode;
    c11_vector__ctor(&self->line_starts, sizeof(const char*));

    // Skip utf8 BOM if there is any.
    if(strncmp(source, "\xEF\xBB\xBF", 3) == 0) source += 3;
    // Drop all '\r'
    c11_sbuf ss;
    c11_sbuf__ctor(&ss);
    while(true) {
        char c = *source;
        if(c == '\0') break;
        if(c != '\r') c11_sbuf__write_char(&ss, c);
        source++;
    }
    self->source = c11_sbuf__submit(&ss);
    self->is_dynamic = is_dynamic;
    c11_vector__push(const char*, &self->line_starts, self->source->data);
}

static void SourceData__dtor(struct SourceData* self) {
    c11_string__delete(self->filename);
    c11_string__delete(self->source);
    c11_vector__dtor(&self->line_starts);
}

SourceData_ SourceData__rcnew(const char* source,
                              const char* filename,
                              enum py_CompileMode mode,
                              bool is_dynamic) {
    SourceData_ self = PK_MALLOC(sizeof(struct SourceData));
    SourceData__ctor(self, source, filename, mode, is_dynamic);
    self->rc.count = 1;
    self->rc.dtor = (void (*)(void*))SourceData__dtor;
    return self;
}

bool SourceData__get_line(const struct SourceData* self,
                          int lineno,
                          const char** st,
                          const char** ed) {
    if(lineno < 0) return false;
    lineno -= 1;
    if(lineno < 0) lineno = 0;
    const char* _start = c11__getitem(const char*, &self->line_starts, lineno);
    const char* i = _start;
    // max 300 chars
    while(*i != '\n' && *i != '\0' && i - _start < 300)
        i++;
    *st = _start;
    *ed = i;
    return true;
}

void SourceData__snapshot(const struct SourceData* self,
                          c11_sbuf* ss,
                          int lineno,
                          const char* cursor,
                          const char* name) {
    pk_sprintf(ss, "  File \"%s\", line %d", self->filename->data, lineno);

    if(name && *name) {
        c11_sbuf__write_cstr(ss, ", in ");
        c11_sbuf__write_cstr(ss, name);
    }

    c11_sbuf__write_char(ss, '\n');
    const char *st = NULL, *ed;
    if(SourceData__get_line(self, lineno, &st, &ed)) {
        while(st < ed && isblank(*st))
            ++st;
        if(st < ed) {
            c11_sbuf__write_cstr(ss, "    ");
            c11_sbuf__write_cstrn(ss, st, ed - st);
            if(cursor && st <= cursor && cursor <= ed) {
                c11_sbuf__write_cstr(ss, "\n    ");
                for(int i = 0; i < (cursor - st); ++i)
                    c11_sbuf__write_char(ss, ' ');
                c11_sbuf__write_cstr(ss, "^");
            }
        } else {
            st = NULL;
        }
    }

    if(!st) { c11_sbuf__write_cstr(ss, "    <?>"); }
}

// src/public/values.c
void py_newint(py_Ref out, int64_t val) {
    out->type = tp_int;
    out->is_ptr = false;
    out->_i64 = val;
}

void py_newfloat(py_Ref out, double val) {
    out->type = tp_float;
    out->is_ptr = false;
    out->_f64 = val;
}

void py_newbool(py_Ref out, bool val) {
    out->type = tp_bool;
    out->is_ptr = false;
    out->_bool = val;
}

void py_newnone(py_Ref out) {
    out->type = tp_NoneType;
    out->is_ptr = false;
}

void py_newnotimplemented(py_Ref out) {
    out->type = tp_NotImplementedType;
    out->is_ptr = false;
}

void py_newellipsis(py_Ref out) {
    out->type = tp_ellipsis;
    out->is_ptr = false;
}

void py_newnil(py_Ref out) { out->type = 0; }

void py_newnativefunc(py_Ref out, py_CFunction f) {
    out->type = tp_nativefunc;
    out->is_ptr = false;
    out->_cfunc = f;
}

void py_bindmethod(py_Type type, const char* name, py_CFunction f) {
    py_TValue tmp;
    py_newnativefunc(&tmp, f);
    py_setdict(py_tpobject(type), py_name(name), &tmp);
}

void py_bindstaticmethod(py_Type type, const char* name, py_CFunction f) {
    py_TValue tmp;
    py_newnativefunc(&tmp, f);
    bool ok = py_tpcall(tp_staticmethod, 1, &tmp);
    if(!ok) {
        py_printexc();
        c11__abort("py_bindstaticmethod(): failed to create staticmethod");
    }
    py_setdict(py_tpobject(type), py_name(name), py_retval());
}

void py_bindfunc(py_Ref obj, const char* name, py_CFunction f) {
    py_TValue tmp;
    py_newnativefunc(&tmp, f);
    py_setdict(obj, py_name(name), &tmp);
}

void py_bindproperty(py_Type type, const char* name, py_CFunction getter, py_CFunction setter) {
    py_TValue tmp;
    py_newobject(&tmp, tp_property, 2, 0);
    py_newnativefunc(py_getslot(&tmp, 0), getter);
    if(setter) {
        py_newnativefunc(py_getslot(&tmp, 1), setter);
    } else {
        py_setslot(&tmp, 1, py_None());
    }
    py_setdict(py_tpobject(type), py_name(name), &tmp);
}

void py_bind(py_Ref obj, const char* sig, py_CFunction f) {
    py_TValue tmp;
    py_Name name = py_newfunction(&tmp, sig, f, NULL, 0);
    py_setdict(obj, name, &tmp);
}

py_Name
    py_newfunction(py_Ref out, const char* sig, py_CFunction f, const char* docstring, int slots) {
    char buffer[256];
    snprintf(buffer, sizeof(buffer), "def %s: pass", sig);
    // fn(a, b, *c, d=1) -> None
    CodeObject code;
    SourceData_ source = SourceData__rcnew(buffer, "<bind>", EXEC_MODE, false);
    Error* err = pk_compile(source, &code);
    if(err || code.func_decls.length != 1) {
        c11__abort("py_newfunction(): invalid signature '%s'", sig);
    }
    FuncDecl_ decl = c11__getitem(FuncDecl_, &code.func_decls, 0);
    decl->docstring = docstring;
    // construct the function
    Function* ud = py_newobject(out, tp_function, slots, sizeof(Function));
    Function__ctor(ud, decl, NULL, NULL);
    ud->cfunc = f;
    CodeObject__dtor(&code);
    PK_DECREF(source);
    assert(decl->rc.count == 1);
    py_Name decl_name = py_name(ud->decl->code.name->data);
    if(decl_name == __new__ || decl_name == __init__) {
        if(ud->decl->args.length == 0) {
            c11__abort("%s() should have at least one positional argument", py_name2str(decl_name));
        }
    }
    return decl_name;
}

void py_newboundmethod(py_Ref out, py_Ref self, py_Ref func) {
    py_newobject(out, tp_boundmethod, 2, 0);
    py_setslot(out, 0, self);
    py_setslot(out, 1, func);
}

void* py_newobject(py_Ref out, py_Type type, int slots, int udsize) {
    ManagedHeap* heap = &pk_current_vm->heap;
    PyObject* obj = ManagedHeap__gcnew(heap, type, slots, udsize);
    out->type = type;
    out->is_ptr = true;
    out->_obj = obj;
    return PyObject__userdata(obj);
}

// src/public/modules.c
#include <ctype.h>
#include <math.h>

py_Ref py_getmodule(const char* path) {
    VM* vm = pk_current_vm;
    return ModuleDict__try_get(&vm->modules, path);
}

py_Ref py_getbuiltin(py_Name name) { return py_getdict(&pk_current_vm->builtins, name); }

py_Ref py_getglobal(py_Name name) { return py_getdict(&pk_current_vm->main, name); }

void py_setglobal(py_Name name, py_Ref val) { py_setdict(&pk_current_vm->main, name, val); }

py_Ref py_newmodule(const char* path) {
    ManagedHeap* heap = &pk_current_vm->heap;
    if(strlen(path) > PK_MAX_MODULE_PATH_LEN) c11__abort("module path too long: %s", path);

    py_Ref r0 = py_pushtmp();
    py_Ref r1 = py_pushtmp();

    *r0 = (py_TValue){
        .type = tp_module,
        .is_ptr = true,
        ._obj = ManagedHeap__new(heap, tp_module, -1, 0),
    };

    int last_dot = c11_sv__rindex((c11_sv){path, strlen(path)}, '.');
    if(last_dot == -1) {
        py_newstr(r1, path);
        py_setdict(r0, __name__, r1);
        py_newstr(r1, "");
        py_setdict(r0, __package__, r1);
    } else {
        const char* start = path + last_dot + 1;
        py_newstr(r1, start);
        py_setdict(r0, __name__, r1);
        py_newstrv(r1, (c11_sv){path, last_dot});
        py_setdict(r0, __package__, r1);
    }

    py_newstr(r1, path);
    py_setdict(r0, __path__, r1);

    // we do not allow override in order to avoid memory leak
    // it is because Module objects are not garbage collected
    bool exists = ModuleDict__contains(&pk_current_vm->modules, path);
    if(exists) c11__abort("module '%s' already exists", path);

    // convert to a weak (const char*)
    path = py_tostr(py_getdict(r0, __path__));
    ModuleDict__set(&pk_current_vm->modules, path, *r0);

    py_shrink(2);
    return py_getmodule(path);
}

int load_module_from_dll_desktop_only(const char* path) PY_RAISE PY_RETURN;

int py_import(const char* path_cstr) {
    VM* vm = pk_current_vm;
    c11_sv path = {path_cstr, strlen(path_cstr)};
    if(path.size == 0) return ValueError("empty module name");

    if(path.data[0] == '.') {
        // try relative import
        int dot_count = 1;
        while(dot_count < path.size && path.data[dot_count] == '.')
            dot_count++;

        c11_sv top_filename = c11_string__sv(vm->top_frame->co->src->filename);
        int is_init = c11_sv__endswith(top_filename, (c11_sv){"__init__.py", 11});

        py_Ref package = py_getdict(vm->top_frame->module, __path__);
        c11_sv package_sv = py_tosv(package);
        if(package_sv.size == 0) {
            return ImportError("attempted relative import with no known parent package");
        }

        c11_vector /* T=c11_sv */ cpnts = c11_sv__split(package_sv, '.');
        for(int i = is_init; i < dot_count; i++) {
            if(cpnts.length == 0)
                return ImportError("attempted relative import beyond top-level package");
            c11_vector__pop(&cpnts);
        }

        if(dot_count < path.size) {
            c11_sv last_cpnt = c11_sv__slice(path, dot_count);
            c11_vector__push(c11_sv, &cpnts, last_cpnt);
        }

        // join cpnts
        c11_sbuf buf;
        c11_sbuf__ctor(&buf);
        for(int i = 0; i < cpnts.length; i++) {
            if(i > 0) c11_sbuf__write_char(&buf, '.');
            c11_sbuf__write_sv(&buf, c11__getitem(c11_sv, &cpnts, i));
        }

        c11_vector__dtor(&cpnts);
        c11_string* new_path = c11_sbuf__submit(&buf);
        int res = py_import(new_path->data);
        c11_string__delete(new_path);
        return res;
    }

    assert(path.data[0] != '.' && path.data[path.size - 1] != '.');

    // check existing module
    py_GlobalRef ext_mod = py_getmodule(path.data);
    if(ext_mod) {
        py_assign(py_retval(), ext_mod);
        return true;
    }

    // try import
    c11_string* slashed_path = c11_sv__replace(path, '.', PK_PLATFORM_SEP);
    c11_string* filename = c11_string__new3("%s.py", slashed_path->data);

    bool need_free = true;
    const char* data = load_kPythonLib(path_cstr);
    if(data != NULL) {
        need_free = false;
        goto __SUCCESS;
    }

    data = vm->callbacks.importfile(filename->data);
    if(data != NULL) goto __SUCCESS;

    c11_string__delete(filename);
    filename = c11_string__new3("%s%c__init__.py", slashed_path->data, PK_PLATFORM_SEP);
    data = vm->callbacks.importfile(filename->data);
    if(data != NULL) goto __SUCCESS;

    c11_string__delete(filename);
    c11_string__delete(slashed_path);
    // not found
    return load_module_from_dll_desktop_only(path_cstr);

__SUCCESS:
    do {
    } while(0);
    py_GlobalRef mod = py_newmodule(path_cstr);
    bool ok = py_exec((const char*)data, filename->data, EXEC_MODE, mod);
    py_assign(py_retval(), mod);

    c11_string__delete(filename);
    c11_string__delete(slashed_path);
    if(need_free) PK_FREE((void*)data);
    return ok ? 1 : -1;
}

bool py_importlib_reload(py_GlobalRef module) {
    VM* vm = pk_current_vm;
    c11_sv path = py_tosv(py_getdict(module, __path__));
    c11_string* slashed_path = c11_sv__replace(path, '.', PK_PLATFORM_SEP);
    c11_string* filename = c11_string__new3("%s.py", slashed_path->data);
    char* data = vm->callbacks.importfile(filename->data);
    if(data == NULL) {
        c11_string__delete(filename);
        filename = c11_string__new3("%s%c__init__.py", slashed_path->data, PK_PLATFORM_SEP);
        data = vm->callbacks.importfile(filename->data);
    }
    c11_string__delete(slashed_path);
    if(data == NULL) return ImportError("module '%v' not found", path);
    bool ok = py_exec(data, filename->data, EXEC_MODE, module);
    c11_string__delete(filename);
    PK_FREE(data);
    py_assign(py_retval(), module);
    return ok;
}

//////////////////////////

static bool builtins_exit(int argc, py_Ref argv) {
    int code = 0;
    if(argc > 1) return TypeError("exit() takes at most 1 argument");
    if(argc == 1) {
        PY_CHECK_ARG_TYPE(0, tp_int);
        code = py_toint(argv);
    }
    exit(code);
    return false;
}

static bool builtins_input(int argc, py_Ref argv) {
    if(argc > 1) return TypeError("input() takes at most 1 argument");
    const char* prompt = "";
    if(argc == 1) {
        if(!py_checkstr(argv)) return false;
        prompt = py_tostr(argv);
    }
    pk_current_vm->callbacks.print(prompt);

    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    while(true) {
        int c = pk_current_vm->callbacks.getchar();
        if(c == '\n' || c == '\r') break;
        if(c == EOF) break;
        c11_sbuf__write_char(&buf, c);
    }
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool builtins_repr(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return py_repr(argv);
}

static bool builtins_len(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return py_len(argv);
}

static bool builtins_hex(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_int);

    py_i64 val = py_toint(argv);

    if(val == 0) {
        py_newstr(py_retval(), "0x0");
        return true;
    }

    c11_sbuf ss;
    c11_sbuf__ctor(&ss);

    if(val < 0) {
        c11_sbuf__write_char(&ss, '-');
        val = -val;
    }
    c11_sbuf__write_cstr(&ss, "0x");
    bool non_zero = true;
    for(int i = 56; i >= 0; i -= 8) {
        unsigned char cpnt = (val >> i) & 0xff;
        c11_sbuf__write_hex(&ss, cpnt, non_zero);
        if(cpnt != 0) non_zero = false;
    }

    c11_sbuf__py_submit(&ss, py_retval());
    return true;
}

static bool builtins_iter(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return py_iter(argv);
}

static bool builtins_next(int argc, py_Ref argv) {
    if(argc == 0 || argc > 2) return TypeError("next() takes 1 or 2 arguments");
    int res = py_next(argv);
    if(res == -1) return false;
    if(res) return true;
    if(argc == 1) {
        // StopIteration stored in py_retval()
        return py_raise(py_retval());
    } else {
        py_assign(py_retval(), py_arg(1));
        return true;
    }
}

static bool builtins_hash(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 val;
    if(!py_hash(argv, &val)) return false;
    py_newint(py_retval(), val);
    return true;
}

static bool builtins_abs(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return pk_callmagic(__abs__, 1, argv);
}

static bool builtins_divmod(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    return pk_callmagic(__divmod__, 2, argv);
}

static bool builtins_round(int argc, py_Ref argv) {
    py_i64 ndigits;

    if(argc == 1) {
        ndigits = -1;
    } else if(argc == 2) {
        PY_CHECK_ARG_TYPE(1, tp_int);
        ndigits = py_toint(py_arg(1));
        if(ndigits < 0) return ValueError("ndigits should be non-negative");
    } else {
        return TypeError("round() takes 1 or 2 arguments");
    }

    if(argv->type == tp_int) {
        py_assign(py_retval(), py_arg(0));
        return true;
    } else if(argv->type == tp_float) {
        py_f64 x = py_tofloat(py_arg(0));
        py_f64 offset = x >= 0 ? 0.5 : -0.5;
        if(ndigits == -1) {
            py_newint(py_retval(), (py_i64)(x + offset));
            return true;
        }
        py_f64 factor = pow(10, ndigits);
        py_newfloat(py_retval(), (py_i64)(x * factor + offset) / factor);
        return true;
    }

    return pk_callmagic(__round__, argc, argv);
}

static bool builtins_print(int argc, py_Ref argv) {
    // print(*args, sep=' ', end='\n')
    py_TValue* args = py_tuple_data(argv);
    int length = py_tuple_len(argv);
    c11_sv sep = py_tosv(py_arg(1));
    c11_sv end = py_tosv(py_arg(2));
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    for(int i = 0; i < length; i++) {
        if(i > 0) c11_sbuf__write_sv(&buf, sep);
        if(!py_str(&args[i])) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
    }
    c11_sbuf__write_sv(&buf, end);
    c11_string* res = c11_sbuf__submit(&buf);
    pk_current_vm->callbacks.print(res->data);
    c11_string__delete(res);
    py_newnone(py_retval());
    return true;
}

static bool builtins_isinstance(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(py_istuple(py_arg(1))) {
        int length = py_tuple_len(py_arg(1));
        for(int i = 0; i < length; i++) {
            py_Ref item = py_tuple_getitem(py_arg(1), i);
            if(!py_checktype(item, tp_type)) return false;
            if(py_isinstance(py_arg(0), py_totype(item))) {
                py_newbool(py_retval(), true);
                return true;
            }
        }
        py_newbool(py_retval(), false);
        return true;
    }

    if(!py_checktype(py_arg(1), tp_type)) return false;
    py_newbool(py_retval(), py_isinstance(py_arg(0), py_totype(py_arg(1))));
    return true;
}

static bool builtins_issubclass(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(!py_checktype(py_arg(0), tp_type)) return false;
    if(!py_checktype(py_arg(1), tp_type)) return false;
    py_newbool(py_retval(), py_issubclass(py_totype(py_arg(0)), py_totype(py_arg(1))));
    return true;
}

bool py_callable(py_Ref val) {
    switch(val->type) {
        case tp_nativefunc: return true;
        case tp_function: return true;
        case tp_type: return true;
        case tp_boundmethod: return true;
        case tp_staticmethod: return true;
        case tp_classmethod: return true;
        default: return py_tpfindmagic(val->type, __call__);
    }
}

static bool builtins_callable(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    bool res = py_callable(py_arg(0));
    py_newbool(py_retval(), res);
    return true;
}

static bool builtins_getattr(int argc, py_Ref argv) {
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    if(argc == 2) {
        return py_getattr(py_arg(0), name);
    } else if(argc == 3) {
        bool ok = py_getattr(py_arg(0), name);
        if(!ok && py_matchexc(tp_AttributeError)) {
            py_clearexc(NULL);
            py_assign(py_retval(), py_arg(2));
            return true;  // default value
        }
        return ok;
    } else {
        return TypeError("getattr() expected 2 or 3 arguments");
    }
    return true;
}

static bool builtins_setattr(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    py_newnone(py_retval());
    return py_setattr(py_arg(0), name, py_arg(2));
}

static bool builtins_hasattr(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    bool ok = py_getattr(py_arg(0), name);
    if(ok) {
        py_newbool(py_retval(), true);
        return true;
    }
    if(py_matchexc(tp_AttributeError)) {
        py_clearexc(NULL);
        py_newbool(py_retval(), false);
        return true;
    }
    return false;
}

static bool builtins_delattr(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    py_newnone(py_retval());
    return py_delattr(py_arg(0), name);
}

static bool builtins_chr(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_int);
    uint32_t val = py_toint(py_arg(0));
    if(val >= 0 && val < 128) {
        py_assign(py_retval(), &pk_current_vm->ascii_literals[val]);
    } else {
        // convert to utf-8
        char utf8[4];
        int len = c11__u32_to_u8(val, utf8);
        if(len == -1) return ValueError("invalid unicode code point: %d", val);
        py_newstrv(py_retval(), (c11_sv){utf8, len});
    }
    return true;
}

static bool builtins_ord(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    c11_sv sv = py_tosv(py_arg(0));
    if(c11_sv__u8_length(sv) != 1) {
        return TypeError("ord() expected a character, but string of length %d found",
                         c11_sv__u8_length(sv));
    }
    int u8bytes = c11__u8_header(sv.data[0], true);
    if(u8bytes == 0) { return ValueError("invalid char: %c", sv.data[0]); }
    int value = c11__u8_value(u8bytes, sv.data);
    py_newint(py_retval(), value);
    return true;
}

static bool builtins_id(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    if(argv->is_ptr) {
        py_newint(py_retval(), (intptr_t)argv->_obj);
    } else {
        py_newnone(py_retval());
    }
    return true;
}

static bool builtins_globals(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    py_newglobals(py_retval());
    return true;
}

static bool builtins_locals(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    py_newlocals(py_retval());
    return true;
}

void py_newglobals(py_Ref out) {
    py_Frame* frame = pk_current_vm->top_frame;
    py_Frame_newglobals(frame, out);
}

void py_newlocals(py_Ref out) {
    py_Frame* frame = pk_current_vm->top_frame;
    py_Frame_newlocals(frame, out);
}

static void pk_push_special_locals() {
    py_Frame* frame = pk_current_vm->top_frame;
    if(!frame) {
        py_pushnil();
        return;
    }
    if(frame->is_locals_special) {
        py_push(frame->locals);
    } else {
        py_StackRef out = py_pushtmp();
        out->type = tp_locals;
        out->is_ptr = false;
        out->extra = 0;
        // this is a weak reference
        // which will expire when the frame is destroyed
        out->_ptr = frame;
    }
}

static bool _builtins_execdyn(const char* title, int argc, py_Ref argv, enum py_CompileMode mode) {
    switch(argc) {
        case 1: {
            py_newglobals(py_pushtmp());
            pk_push_special_locals();
            break;
        }
        case 2: {
            // globals
            if(py_isnone(py_arg(1))) {
                py_newglobals(py_pushtmp());
            } else {
                py_push(py_arg(1));
            }
            // locals
            py_pushnil();
            break;
        }
        case 3: {
            // globals
            if(py_isnone(py_arg(1))) {
                py_newglobals(py_pushtmp());
            } else {
                py_push(py_arg(1));
            }
            // locals
            if(py_isnone(py_arg(2))) {
                py_pushnil();
            } else {
                py_push(py_arg(2));
            }
            break;
        }
        default: return TypeError("%s() takes at most 3 arguments", title);
    }

    if(py_isstr(argv)) {
        bool ok = py_compile(py_tostr(argv), "<string>", mode, true);
        if(!ok) return false;
        py_push(py_retval());
    } else if(py_istype(argv, tp_code)) {
        py_push(argv);
    } else {
        return TypeError("%s() expected 'str' or 'code', got '%t'", title, argv->type);
    }

    py_Frame* frame = pk_current_vm->top_frame;
    // [globals, locals, code]
    CodeObject* code = py_touserdata(py_peek(-1));
    if(code->src->is_dynamic) {
        bool ok = pk_execdyn(code, frame ? frame->module : NULL, py_peek(-3), py_peek(-2));
        py_shrink(3);
        return ok;
    } else {
        if(argc != 1) {
            return ValueError(
                "code object is not dynamic, `globals` and `locals` must not be specified");
        }
        bool ok = pk_exec(code, frame ? frame->module : NULL);
        py_shrink(3);
        return ok;
    }
}

static bool builtins_exec(int argc, py_Ref argv) {
    bool ok = _builtins_execdyn("exec", argc, argv, EXEC_MODE);
    py_newnone(py_retval());
    return ok;
}

static bool builtins_eval(int argc, py_Ref argv) {
    return _builtins_execdyn("eval", argc, argv, EVAL_MODE);
}

static bool
    pk_smartexec(const char* source, py_Ref module, enum py_CompileMode mode, va_list args) {
    if(module == NULL) module = &pk_current_vm->main;
    pk_mappingproxy__namedict(py_pushtmp(), module);  // globals
    py_newdict(py_pushtmp());                         // locals
    bool ok = py_compile(source, "<string>", mode, true);
    if(!ok) return false;
    py_push(py_retval());
    // [globals, locals, code]
    CodeObject* co = py_touserdata(py_peek(-1));
    py_StackRef locals = py_peek(-2);
    int max_index = -1;
    c11__foreach(Bytecode, &co->codes, bc) {
        if(bc->op == OP_LOAD_NAME) {
            c11_sv name = py_name2sv(bc->arg);
            if(name.data[0] != '_') continue;
            int index;
            if(name.size == 1) {
                index = 0;
            } else if(name.size == 2 && isdigit(name.data[1])) {
                index = name.data[1] - '0';
            } else {
                continue;
            }
            max_index = c11__max(max_index, index);
        }
    }

    if(max_index == -1) return ValueError("no placeholder found in the source");

    for(int i = 0; i <= max_index; i++) {
        py_Ref val = va_arg(args, py_Ref);
        char buf[3];
        buf[0] = '_';
        buf[1] = '0' + i;
        buf[2] = '\0';
        py_dict_setitem_by_str(locals, buf, val);
        if(i == 0) {
            // _ => _0
            py_dict_setitem_by_str(locals, "_", val);
        }
    }
    ok = pk_execdyn(co, module, py_peek(-3), locals);
    if(!ok) return false;
    py_shrink(3);
    return true;
}

bool py_smartexec(const char* source, py_Ref module, ...) {
    va_list args;
    va_start(args, module);
    bool ok = pk_smartexec(source, module, EXEC_MODE, args);
    va_end(args);
    return ok;
}

bool py_smarteval(const char* source, py_Ref module, ...) {
    va_list args;
    va_start(args, module);
    bool ok = pk_smartexec(source, module, EVAL_MODE, args);
    va_end(args);
    return ok;
}

static bool builtins_compile(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    for(int i = 0; i < 3; i++) {
        if(!py_checktype(py_arg(i), tp_str)) return false;
    }
    const char* source = py_tostr(py_arg(0));
    const char* filename = py_tostr(py_arg(1));
    const char* mode = py_tostr(py_arg(2));

    enum py_CompileMode compile_mode;
    if(strcmp(mode, "exec") == 0) {
        compile_mode = EXEC_MODE;
    } else if(strcmp(mode, "eval") == 0) {
        compile_mode = EVAL_MODE;
    } else if(strcmp(mode, "single") == 0) {
        compile_mode = SINGLE_MODE;
    } else {
        return ValueError("compile() mode must be 'exec', 'eval', or 'single'");
    }
    return py_compile(source, filename, compile_mode, true);
}

static bool builtins__import__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    int res = py_import(py_tostr(argv));
    if(res == -1) return false;
    if(res) return true;
    return ImportError("module '%s' not found", py_tostr(argv));
}

static bool NoneType__repr__(int argc, py_Ref argv) {
    py_newstr(py_retval(), "None");
    return true;
}

static bool ellipsis__repr__(int argc, py_Ref argv) {
    py_newstr(py_retval(), "...");
    return true;
}

static bool NotImplementedType__repr__(int argc, py_Ref argv) {
    py_newstr(py_retval(), "NotImplemented");
    return true;
}

py_TValue pk_builtins__register() {
    py_Ref builtins = py_newmodule("builtins");
    py_bindfunc(builtins, "exit", builtins_exit);
    py_bindfunc(builtins, "input", builtins_input);
    py_bindfunc(builtins, "repr", builtins_repr);
    py_bindfunc(builtins, "len", builtins_len);
    py_bindfunc(builtins, "hex", builtins_hex);
    py_bindfunc(builtins, "iter", builtins_iter);
    py_bindfunc(builtins, "next", builtins_next);
    py_bindfunc(builtins, "hash", builtins_hash);
    py_bindfunc(builtins, "abs", builtins_abs);
    py_bindfunc(builtins, "divmod", builtins_divmod);
    py_bindfunc(builtins, "round", builtins_round);

    py_bind(builtins, "print(*args, sep=' ', end='\\n')", builtins_print);

    py_bindfunc(builtins, "isinstance", builtins_isinstance);
    py_bindfunc(builtins, "issubclass", builtins_issubclass);
    py_bindfunc(builtins, "callable", builtins_callable);

    py_bindfunc(builtins, "getattr", builtins_getattr);
    py_bindfunc(builtins, "setattr", builtins_setattr);
    py_bindfunc(builtins, "hasattr", builtins_hasattr);
    py_bindfunc(builtins, "delattr", builtins_delattr);

    py_bindfunc(builtins, "chr", builtins_chr);
    py_bindfunc(builtins, "ord", builtins_ord);
    py_bindfunc(builtins, "id", builtins_id);

    py_bindfunc(builtins, "globals", builtins_globals);
    py_bindfunc(builtins, "locals", builtins_locals);
    py_bindfunc(builtins, "exec", builtins_exec);
    py_bindfunc(builtins, "eval", builtins_eval);
    py_bindfunc(builtins, "compile", builtins_compile);

    py_bindfunc(builtins, "__import__", builtins__import__);

    // some patches
    py_bindmagic(tp_NoneType, __repr__, NoneType__repr__);
    *py_tpgetmagic(tp_NoneType, __hash__) = *py_None();
    py_bindmagic(tp_ellipsis, __repr__, ellipsis__repr__);
    *py_tpgetmagic(tp_ellipsis, __hash__) = *py_None();
    py_bindmagic(tp_NotImplementedType, __repr__, NotImplementedType__repr__);
    *py_tpgetmagic(tp_NotImplementedType, __hash__) = *py_None();
    return *builtins;
}

void function__gc_mark(void* ud) {
    Function* func = ud;
    if(func->globals) pk__mark_value(func->globals);
    if(func->closure) {
        NameDict* namedict = func->closure;
        for(int i = 0; i < namedict->length; i++) {
            NameDict_KV* kv = c11__at(NameDict_KV, namedict, i);
            pk__mark_value(&kv->value);
        }
    }
    FuncDecl__gc_mark(func->decl);
}

static bool function__doc__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Function* func = py_touserdata(py_arg(0));
    if(func->decl->docstring) {
        py_newstr(py_retval(), func->decl->docstring);
    } else {
        py_newnone(py_retval());
    }
    return true;
}

static bool function__name__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Function* func = py_touserdata(py_arg(0));
    py_newstr(py_retval(), func->decl->code.name->data);
    return true;
}

static bool function__repr__(int argc, py_Ref argv) {
    // <function f at 0x10365b9c0>
    PY_CHECK_ARGC(1);
    Function* func = py_touserdata(py_arg(0));
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_cstr(&buf, "<function ");
    c11_sbuf__write_cstr(&buf, func->decl->code.name->data);
    c11_sbuf__write_cstr(&buf, " at ");
    c11_sbuf__write_ptr(&buf, func);
    c11_sbuf__write_char(&buf, '>');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

py_Type pk_function__register() {
    py_Type type =
        pk_newtype("function", tp_object, NULL, (void (*)(void*))Function__dtor, false, true);
    py_bindproperty(type, "__doc__", function__doc__, NULL);
    py_bindproperty(type, "__name__", function__name__, NULL);
    py_bindmagic(type, __repr__, function__repr__);
    return type;
}

static bool nativefunc__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_newstr(py_retval(), "<nativefunc object>");
    return true;
}

py_Type pk_nativefunc__register() {
    py_Type type = pk_newtype("nativefunc", tp_object, NULL, NULL, false, true);
    py_bindmagic(type, __repr__, nativefunc__repr__);
    return type;
}

static bool super__new__(int argc, py_Ref argv) {
    py_Type class_arg = 0;
    py_Frame* frame = pk_current_vm->top_frame;
    py_Ref self_arg = NULL;
    if(argc == 1) {
        // super()
        if(!frame->is_locals_special) {
            py_TValue* callable = frame->p0;
            if(callable->type == tp_boundmethod) callable = py_getslot(frame->p0, 1);
            if(callable->type == tp_function) {
                Function* func = py_touserdata(callable);
                if(func->clazz != NULL) {
                    class_arg = *(py_Type*)PyObject__userdata(func->clazz);
                    if(frame->co->nlocals > 0) { self_arg = &frame->locals[0]; }
                }
            }
        }
        if(class_arg == 0 || self_arg == NULL) return RuntimeError("super(): no arguments");
        if(self_arg->type == tp_type) {
            // f(cls, ...)
            class_arg = pk__type_info(class_arg)->base;
            if(class_arg == 0) return RuntimeError("super(): base class is invalid");
            py_assign(py_retval(), py_tpobject(class_arg));
            return true;
        }
    } else if(argc == 3) {
        // super(type[T], obj)
        PY_CHECK_ARG_TYPE(1, tp_type);
        class_arg = py_totype(py_arg(1));
        self_arg = py_arg(2);
        if(!py_isinstance(self_arg, class_arg)) {
            return TypeError("super(type, obj): obj must be an instance of type");
        }
    } else {
        return TypeError("super() takes 0 or 2 arguments");
    }

    class_arg = pk__type_info(class_arg)->base;
    if(class_arg == 0) return RuntimeError("super(): base class is invalid");

    py_Type* p_class_arg = py_newobject(py_retval(), tp_super, 1, sizeof(py_Type));
    *p_class_arg = class_arg;
    py_setslot(py_retval(), 0, self_arg);
    return true;
}

py_Type pk_super__register() {
    py_Type type = pk_newtype("super", tp_object, NULL, NULL, false, true);
    py_bindmagic(type, __new__, super__new__);
    return type;
}

// src/public/py_method.c
/* staticmethod */

static bool staticmethod__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_newobject(py_retval(), tp_staticmethod, 1, 0);
    py_setslot(py_retval(), 0, py_arg(1));
    return true;
}

py_Type pk_staticmethod__register() {
    py_Type type = pk_newtype("staticmethod", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, staticmethod__new__);
    return type;
}

/* classmethod */
static bool classmethod__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_newobject(py_retval(), tp_classmethod, 1, 0);
    py_setslot(py_retval(), 0, py_arg(1));
    return true;
}

py_Type pk_classmethod__register() {
    py_Type type = pk_newtype("classmethod", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, classmethod__new__);
    return type;
}

/* boundmethod */
static bool boundmethod__self__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_assign(py_retval(), py_getslot(argv, 0));
    return true;
}

static bool boundmethod__func__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_assign(py_retval(), py_getslot(argv, 1));
    return true;
}

static bool boundmethod__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(!py_istype(py_arg(1), tp_boundmethod)) {
        py_newbool(py_retval(), false);
        return true;
    }
    for(int i = 0; i < 2; i++) {
        int res = py_equal(py_getslot(&argv[0], i), py_getslot(&argv[1], i));
        if(res == -1) return false;
        if(!res) {
            py_newbool(py_retval(), false);
            return true;
        }
    }
    py_newbool(py_retval(), true);
    return true;
}

static bool boundmethod__ne__(int argc, py_Ref argv) {
    bool ok = boundmethod__eq__(argc, argv);
    if(!ok) return false;
    bool res = py_tobool(py_retval());
    py_newbool(py_retval(), !res);
    return true;
}

py_Type pk_boundmethod__register() {
    py_Type type = pk_newtype("boundmethod", tp_object, NULL, NULL, false, true);
    py_bindproperty(type, "__self__", boundmethod__self__, NULL);
    py_bindproperty(type, "__func__", boundmethod__func__, NULL);
    py_bindmagic(type, __eq__, boundmethod__eq__);
    py_bindmagic(type, __ne__, boundmethod__ne__);
    return type;
}
// src/public/py_dict.c
static uint32_t Dict__next_cap(uint32_t cap) {
    switch(cap) {
        case 7: return 17;
        case 17: return 37;
        case 37: return 79;
        case 79: return 163;
        case 163: return 331;
        case 331: return 673;
        case 673: return 1361;
        case 1361: return 2053;
        case 2053: return 3083;
        case 3083: return 4637;
        case 4637: return 6959;
        case 6959: return 10453;
        case 10453: return 15683;
        case 15683: return 23531;
        case 23531: return 35311;
        case 35311: return 52967;
        case 52967: return 79451;
        case 79451: return 119179;
        case 119179: return 178781;
        case 178781: return 268189;
        case 268189: return 402299;
        case 402299: return 603457;
        case 603457: return 905189;
        case 905189: return 1357787;
        case 1357787: return 2036687;
        case 2036687: return 3055043;
        case 3055043: return 4582577;
        case 4582577: return 6873871;
        case 6873871: return 10310819;
        case 10310819: return 15466229;
        case 15466229: return 23199347;
        case 23199347: return 34799021;
        case 34799021: return 52198537;
        case 52198537: return 78297827;
        case 78297827: return 117446801;
        case 117446801: return 176170229;
        case 176170229: return 264255353;
        case 264255353: return 396383041;
        case 396383041: return 594574583;
        case 594574583: return 891861923;
        default: c11__unreachable();
    }
}



typedef struct {
    DictEntry* curr;
    DictEntry* end;
} DictIterator;

static void Dict__ctor(Dict* self, uint32_t capacity, int entries_capacity) {
    self->length = 0;
    self->capacity = capacity;
    self->indices = PK_MALLOC(self->capacity * sizeof(DictIndex));
    memset(self->indices, -1, self->capacity * sizeof(DictIndex));
    c11_vector__ctor(&self->entries, sizeof(DictEntry));
    c11_vector__reserve(&self->entries, entries_capacity);
}

static void Dict__dtor(Dict* self) {
    self->length = 0;
    self->capacity = 0;
    PK_FREE(self->indices);
    c11_vector__dtor(&self->entries);
}

static bool Dict__try_get(Dict* self, py_TValue* key, DictEntry** out) {
    py_i64 hash;
    if(!py_hash(key, &hash)) return false;
    int idx = (uint64_t)hash % self->capacity;
    for(int i = 0; i < PK_DICT_MAX_COLLISION; i++) {
        int idx2 = self->indices[idx]._[i];
        if(idx2 == -1) continue;
        DictEntry* entry = c11__at(DictEntry, &self->entries, idx2);
        if(entry->hash == (uint64_t)hash) {
            int res = py_equal(&entry->key, key);
            if(res == 1) {
                *out = entry;
                return true;
            }
            if(res == -1) return false;  // error
        }
    }
    *out = NULL;
    return true;
}

static void Dict__clear(Dict* self) {
    memset(self->indices, -1, self->capacity * sizeof(DictIndex));
    c11_vector__clear(&self->entries);
    self->length = 0;
}

static void Dict__rehash_2x(Dict* self) {
    Dict old_dict = *self;
    uint32_t new_capacity = self->capacity;

__RETRY:
    // use next capacity
    new_capacity = Dict__next_cap(new_capacity);
    // create a new dict with new capacity
    Dict__ctor(self, new_capacity, old_dict.entries.capacity);
    // move entries from old dict to new dict
    for(int i = 0; i < old_dict.entries.length; i++) {
        DictEntry* old_entry = c11__at(DictEntry, &old_dict.entries, i);
        if(py_isnil(&old_entry->key)) continue;
        int idx = old_entry->hash % new_capacity;
        bool success = false;
        for(int i = 0; i < PK_DICT_MAX_COLLISION; i++) {
            int idx2 = self->indices[idx]._[i];
            if(idx2 == -1) {
                // insert new entry (empty slot)
                c11_vector__push(DictEntry, &self->entries, *old_entry);
                self->indices[idx]._[i] = self->entries.length - 1;
                self->length++;
                success = true;
                break;
            }
        }
        if(!success) {
            Dict__dtor(self);
            goto __RETRY;
        }
    }
    // done
    Dict__dtor(&old_dict);
}

static void Dict__compact_entries(Dict* self) {
    int* mappings = PK_MALLOC(self->entries.length * sizeof(int));

    int n = 0;
    for(int i = 0; i < self->entries.length; i++) {
        DictEntry* entry = c11__at(DictEntry, &self->entries, i);
        if(py_isnil(&entry->key)) continue;
        mappings[i] = n;
        if(i != n) {
            DictEntry* new_entry = c11__at(DictEntry, &self->entries, n);
            *new_entry = *entry;
        }
        n++;
    }
    self->entries.length = n;
    // update indices
    for(uint32_t i = 0; i < self->capacity; i++) {
        for(int j = 0; j < PK_DICT_MAX_COLLISION; j++) {
            int idx = self->indices[i]._[j];
            if(idx == -1) continue;
            self->indices[i]._[j] = mappings[idx];
        }
    }
    PK_FREE(mappings);
}

static bool Dict__set(Dict* self, py_TValue* key, py_TValue* val) {
    py_i64 hash;
    if(!py_hash(key, &hash)) return false;
    int idx = (uint64_t)hash % self->capacity;
    int bad_hash_count = 0;
    for(int i = 0; i < PK_DICT_MAX_COLLISION; i++) {
        int idx2 = self->indices[idx]._[i];
        if(idx2 == -1) {
            // insert new entry
            DictEntry* new_entry = c11_vector__emplace(&self->entries);
            new_entry->hash = (uint64_t)hash;
            new_entry->key = *key;
            new_entry->val = *val;
            self->indices[idx]._[i] = self->entries.length - 1;
            self->length++;
            return true;
        }
        // update existing entry
        DictEntry* entry = c11__at(DictEntry, &self->entries, idx2);
        // check if they have the same hash
        if(entry->hash == (uint64_t)hash) {
            // check if they are equal
            int res = py_equal(&entry->key, key);
            if(res == 1) {
                entry->val = *val;
                return true;
            }
            if(res == -1) return false;  // error
            // res == 0
            bad_hash_count++;
        }
    }
    // no empty slot found
    if(bad_hash_count == PK_DICT_MAX_COLLISION) {
        // all `PK_DICT_MAX_COLLISION` slots have the same hash but different keys
        // we are unable to solve this collision via rehashing
        return RuntimeError("dict: %d/%d/%d: maximum collision reached (hash=%i)",
                            self->entries.length,
                            self->entries.capacity,
                            self->capacity,
                            hash);
    }

    if(self->capacity >= (uint32_t)self->entries.length * 10) {
        return RuntimeError("dict: %d/%d/%d: minimum load factor reached",
                            self->entries.length,
                            self->entries.capacity,
                            self->capacity);
    }
    Dict__rehash_2x(self);
    return Dict__set(self, key, val);
}

/// Delete an entry from the dict.
/// -1: error, 0: not found, 1: found and deleted
static int Dict__pop(Dict* self, py_Ref key) {
    py_i64 hash;
    if(!py_hash(key, &hash)) return -1;
    int idx = (uint64_t)hash % self->capacity;
    for(int i = 0; i < PK_DICT_MAX_COLLISION; i++) {
        int idx2 = self->indices[idx]._[i];
        if(idx2 == -1) continue;
        DictEntry* entry = c11__at(DictEntry, &self->entries, idx2);
        if(entry->hash == (uint64_t)hash) {
            int res = py_equal(&entry->key, key);
            if(res == 1) {
                *py_retval() = entry->val;
                py_newnil(&entry->key);
                self->indices[idx]._[i] = -1;
                self->length--;
                if(self->length < self->entries.length / 2) Dict__compact_entries(self);
                return 1;
            }
            if(res == -1) return -1;  // error
        }
    }
    return 0;
}

static void DictIterator__ctor(DictIterator* self, Dict* dict) {
    self->curr = dict->entries.data;
    self->end = self->curr + dict->entries.length;
}

static DictEntry* DictIterator__next(DictIterator* self) {
    DictEntry* retval;
    do {
        if(self->curr == self->end) return NULL;
        retval = self->curr++;
    } while(py_isnil(&retval->key));
    return retval;
}

///////////////////////////////
static bool dict__new__(int argc, py_Ref argv) {
    py_Type cls = py_totype(argv);
    int slots = cls == tp_dict ? 0 : -1;
    Dict* ud = py_newobject(py_retval(), cls, slots, sizeof(Dict));
    Dict__ctor(ud, 7, 8);
    return true;
}

void py_newdict(py_Ref out) {
    Dict* ud = py_newobject(out, tp_dict, 0, sizeof(Dict));
    Dict__ctor(ud, 7, 8);
}

static bool dict__init__(int argc, py_Ref argv) {
    py_newnone(py_retval());
    if(argc > 2) return TypeError("dict.__init__() takes at most 2 arguments (%d given)", argc);
    if(argc == 1) return true;
    assert(argc == 2);

    py_TValue* p;
    int length = pk_arrayview(py_arg(1), &p);
    if(length == -1) { return TypeError("dict.__init__() expects a list or tuple"); }

    Dict* self = py_touserdata(argv);
    for(int i = 0; i < length; i++) {
        py_Ref tuple = &p[i];
        if(!py_istuple(tuple) || py_tuple_len(tuple) != 2) {
            return ValueError("dict.__init__() argument must be a list of tuple-2");
        }
        py_Ref key = py_tuple_getitem(tuple, 0);
        py_Ref val = py_tuple_getitem(tuple, 1);
        if(!Dict__set(self, key, val)) return false;
    }
    return true;
}

static bool dict__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    Dict* self = py_touserdata(argv);
    DictEntry* entry;
    if(!Dict__try_get(self, py_arg(1), &entry)) return false;
    if(entry) {
        *py_retval() = entry->val;
        return true;
    }
    // try __missing__
    py_Ref missing = py_tpfindmagic(argv->type, __missing__);
    if(missing) return py_call(missing, argc, argv);
    return KeyError(py_arg(1));
}

static bool dict__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    Dict* self = py_touserdata(argv);
    return Dict__set(self, py_arg(1), py_arg(2));
}

static bool dict__delitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    Dict* self = py_touserdata(argv);
    int res = Dict__pop(self, py_arg(1));
    if(res == 1) {
        py_newnone(py_retval());
        return true;
    }
    if(res == 0) return KeyError(py_arg(1));
    return false;
}

static bool dict__contains__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    Dict* self = py_touserdata(argv);
    DictEntry* entry;
    if(!Dict__try_get(self, py_arg(1), &entry)) return false;
    py_newbool(py_retval(), entry != NULL);
    return true;
}

static bool dict__len__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    py_newint(py_retval(), self->length);
    return true;
}

static bool dict__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_char(&buf, '{');
    bool is_first = true;
    for(int i = 0; i < self->entries.length; i++) {
        DictEntry* entry = c11__at(DictEntry, &self->entries, i);
        if(py_isnil(&entry->key)) continue;
        if(!is_first) c11_sbuf__write_cstr(&buf, ", ");
        if(!py_repr(&entry->key)) return false;
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        c11_sbuf__write_cstr(&buf, ": ");
        if(!py_repr(&entry->val)) return false;
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        is_first = false;
    }
    c11_sbuf__write_char(&buf, '}');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool dict__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    Dict* self = py_touserdata(py_arg(0));
    if(!py_isdict(py_arg(1))) {
        py_newnotimplemented(py_retval());
        return true;
    }
    Dict* other = py_touserdata(py_arg(1));
    if(self->length != other->length) {
        py_newbool(py_retval(), false);
        return true;
    }
    DictIterator iter;
    DictIterator__ctor(&iter, self);
    // for each self key
    while(1) {
        DictEntry* entry = DictIterator__next(&iter);
        if(!entry) break;
        DictEntry* other_entry;
        if(!Dict__try_get(other, &entry->key, &other_entry)) return false;
        if(!other_entry) {
            py_newbool(py_retval(), false);
            return true;
        }
        if(entry->hash != other_entry->hash) {
            py_newbool(py_retval(), false);
            return true;
        }
        int res = py_equal(&entry->val, &other_entry->val);
        if(res == 0) {
            py_newbool(py_retval(), false);
            return true;
        }
        if(res == -1) return false;  // error
    }
    py_newbool(py_retval(), true);
    return true;
}

static bool dict__ne__(int argc, py_Ref argv) {
    if(!dict__eq__(argc, argv)) return false;
    if(py_isbool(py_retval())) {
        bool res = py_tobool(py_retval());
        py_newbool(py_retval(), !res);
    }
    return true;
}

static bool dict_clear(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    Dict__clear(self);
    py_newnone(py_retval());
    return true;
}

static bool dict_copy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    Dict* new_dict = py_newobject(py_retval(), tp_dict, 0, sizeof(Dict));
    new_dict->capacity = self->capacity;
    new_dict->length = self->length;
    new_dict->entries = c11_vector__copy(&self->entries);
    // copy indices
    new_dict->indices = PK_MALLOC(new_dict->capacity * sizeof(DictIndex));
    memcpy(new_dict->indices, self->indices, new_dict->capacity * sizeof(DictIndex));
    return true;
}

static bool dict_update(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_dict);
    Dict* self = py_touserdata(argv);
    Dict* other = py_touserdata(py_arg(1));
    for(int i = 0; i < other->entries.length; i++) {
        DictEntry* entry = c11__at(DictEntry, &other->entries, i);
        if(py_isnil(&entry->key)) continue;
        if(!Dict__set(self, &entry->key, &entry->val)) return false;
    }
    py_newnone(py_retval());
    return true;
}

static bool dict_get(int argc, py_Ref argv) {
    Dict* self = py_touserdata(argv);
    if(argc > 3) return TypeError("get() takes at most 3 arguments (%d given)", argc);
    py_Ref default_val = argc == 3 ? py_arg(2) : py_None();
    DictEntry* entry;
    if(!Dict__try_get(self, py_arg(1), &entry)) return false;
    *py_retval() = entry ? entry->val : *default_val;
    return true;
}

static bool dict_pop(int argc, py_Ref argv) {
    Dict* self = py_touserdata(argv);
    if(argc < 2 || argc > 3) return TypeError("pop() takes 1 or 2 arguments (%d given)", argc - 1);
    py_Ref default_val = argc == 3 ? py_arg(2) : py_None();
    int res = Dict__pop(self, py_arg(1));
    if(res == -1) return false;
    if(res == 0) { py_assign(py_retval(), default_val); }
    return true;
}

static bool dict_items(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    DictIterator* ud = py_newobject(py_retval(), tp_dict_items, 1, sizeof(DictIterator));
    DictIterator__ctor(ud, self);
    py_setslot(py_retval(), 0, argv);  // keep a reference to the dict
    return true;
}

static bool dict_keys(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    py_Ref p = py_newtuple(py_retval(), self->length);
    DictIterator iter;
    DictIterator__ctor(&iter, self);
    int i = 0;
    while(1) {
        DictEntry* entry = DictIterator__next(&iter);
        if(!entry) break;
        p[i++] = entry->key;
    }
    assert(i == self->length);
    return true;
}

static bool dict_values(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    Dict* self = py_touserdata(argv);
    py_Ref p = py_newtuple(py_retval(), self->length);
    DictIterator iter;
    DictIterator__ctor(&iter, self);
    int i = 0;
    while(1) {
        DictEntry* entry = DictIterator__next(&iter);
        if(!entry) break;
        p[i++] = entry->val;
    }
    assert(i == self->length);
    return true;
}

py_Type pk_dict__register() {
    py_Type type = pk_newtype("dict", tp_object, NULL, (void (*)(void*))Dict__dtor, false, false);

    py_bindmagic(type, __new__, dict__new__);
    py_bindmagic(type, __init__, dict__init__);
    py_bindmagic(type, __getitem__, dict__getitem__);
    py_bindmagic(type, __setitem__, dict__setitem__);
    py_bindmagic(type, __delitem__, dict__delitem__);
    py_bindmagic(type, __contains__, dict__contains__);
    py_bindmagic(type, __len__, dict__len__);
    py_bindmagic(type, __repr__, dict__repr__);
    py_bindmagic(type, __eq__, dict__eq__);
    py_bindmagic(type, __ne__, dict__ne__);

    py_bindmethod(type, "clear", dict_clear);
    py_bindmethod(type, "copy", dict_copy);
    py_bindmethod(type, "update", dict_update);
    py_bindmethod(type, "get", dict_get);
    py_bindmethod(type, "pop", dict_pop);
    py_bindmethod(type, "items", dict_items);
    py_bindmethod(type, "keys", dict_keys);
    py_bindmethod(type, "values", dict_values);

    py_setdict(py_tpobject(type), __hash__, py_None());
    return type;
}

//////////////////////////
static bool dict_items__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    DictIterator* iter = py_touserdata(py_arg(0));
    DictEntry* entry = (DictIterator__next(iter));
    if(entry) {
        py_Ref p = py_newtuple(py_retval(), 2);
        p[0] = entry->key;
        p[1] = entry->val;
        return true;
    }
    return StopIteration();
}

py_Type pk_dict_items__register() {
    py_Type type = pk_newtype("dict_items", tp_object, NULL, NULL, false, true);
    py_bindmagic(type, __iter__, pk_wrapper__self);
    py_bindmagic(type, __next__, dict_items__next__);
    return type;
}

//////////////////////////

int py_dict_getitem(py_Ref self, py_Ref key) {
    assert(py_isdict(self));
    Dict* ud = py_touserdata(self);
    DictEntry* entry;
    if(!Dict__try_get(ud, key, &entry)) return -1;
    if(entry) {
        py_assign(py_retval(), &entry->val);
        return 1;
    }
    return 0;
}

bool py_dict_setitem(py_Ref self, py_Ref key, py_Ref val) {
    assert(py_isdict(self));
    Dict* ud = py_touserdata(self);
    return Dict__set(ud, key, val);
}

int py_dict_delitem(py_Ref self, py_Ref key) {
    assert(py_isdict(self));
    Dict* ud = py_touserdata(self);
    return Dict__pop(ud, key);
}

int py_dict_getitem_by_str(py_Ref self, const char* key) {
    py_Ref tmp = py_pushtmp();
    py_newstr(tmp, key);
    int res = py_dict_getitem(self, tmp);
    py_pop();
    return res;
}

bool py_dict_setitem_by_str(py_Ref self, const char* key, py_Ref val) {
    py_Ref tmp = py_pushtmp();
    py_newstr(tmp, key);
    bool res = py_dict_setitem(self, tmp, val);
    py_pop();
    return res;
}

int py_dict_delitem_by_str(py_Ref self, const char* key) {
    py_Ref tmp = py_pushtmp();
    py_newstr(tmp, key);
    int res = py_dict_delitem(self, tmp);
    py_pop();
    return res;
}

int py_dict_getitem_by_int(py_Ref self, py_i64 key) {
    py_TValue tmp;
    py_newint(&tmp, key);
    return py_dict_getitem(self, &tmp);
}

bool py_dict_setitem_by_int(py_Ref self, py_i64 key, py_Ref val) {
    py_TValue tmp;
    py_newint(&tmp, key);
    return py_dict_setitem(self, &tmp, val);
}

int py_dict_delitem_by_int(py_Ref self, py_i64 key) {
    py_TValue tmp;
    py_newint(&tmp, key);
    return py_dict_delitem(self, &tmp);
}

int py_dict_len(py_Ref self) {
    assert(py_isdict(self));
    Dict* ud = py_touserdata(self);
    return ud->length;
}

bool py_dict_apply(py_Ref self, bool (*f)(py_Ref, py_Ref, void*), void* ctx) {
    Dict* ud = py_touserdata(self);
    for(int i = 0; i < ud->entries.length; i++) {
        DictEntry* entry = c11__at(DictEntry, &ud->entries, i);
        if(py_isnil(&entry->key)) continue;
        if(!f(&entry->key, &entry->val, ctx)) return false;
    }
    return true;
}

#undef PK_DICT_MAX_COLLISION
// src/public/py_range.c
typedef struct Range {
    py_i64 start;
    py_i64 stop;
    py_i64 step;
} Range;

static bool range__new__(int argc, py_Ref argv) {
    Range* ud = py_newobject(py_retval(), tp_range, 0, sizeof(Range));
    switch(argc - 1) {  // skip cls
        case 1: {
            PY_CHECK_ARG_TYPE(1, tp_int);
            ud->start = 0;
            ud->stop = py_toint(py_arg(1));
            ud->step = 1;
            break;
        }
        case 2:
            PY_CHECK_ARG_TYPE(1, tp_int);
            PY_CHECK_ARG_TYPE(2, tp_int);
            ud->start = py_toint(py_arg(1));
            ud->stop = py_toint(py_arg(2));
            ud->step = 1;
            break;
        case 3:
            PY_CHECK_ARG_TYPE(1, tp_int);
            PY_CHECK_ARG_TYPE(2, tp_int);
            PY_CHECK_ARG_TYPE(3, tp_int);
            ud->start = py_toint(py_arg(1));
            ud->stop = py_toint(py_arg(2));
            ud->step = py_toint(py_arg(3));
            break;
        default: return TypeError("range() expected at most 3 arguments, got %d", argc - 1);
    }
    if(ud->step == 0) return ValueError("range() step must not be zero");
    return true;
}

static bool range__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return py_tpcall(tp_range_iterator, 1, argv);
}

py_Type pk_range__register() {
    py_Type type = pk_newtype("range", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, range__new__);
    py_bindmagic(type, __iter__, range__iter__);
    return type;
}

typedef struct RangeIterator {
    Range range;
    py_i64 current;
} RangeIterator;

static bool range_iterator__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_range);
    RangeIterator* ud = py_newobject(py_retval(), tp_range_iterator, 0, sizeof(RangeIterator));
    ud->range = *(Range*)py_touserdata(py_arg(1));
    ud->current = ud->range.start;
    return true;
}

static bool range_iterator__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    RangeIterator* ud = py_touserdata(py_arg(0));
    if(ud->range.step > 0) {
        if(ud->current >= ud->range.stop) return StopIteration();
    } else {
        if(ud->current <= ud->range.stop) return StopIteration();
    }
    py_newint(py_retval(), ud->current);
    ud->current += ud->range.step;
    return true;
}

py_Type pk_range_iterator__register() {
    py_Type type = pk_newtype("range_iterator", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, range_iterator__new__);
    py_bindmagic(type, __iter__, pk_wrapper__self);
    py_bindmagic(type, __next__, range_iterator__next__);
    return type;
}
// src/public/exec.c
#include <assert.h>

py_Type pk_code__register() {
    py_Type type = pk_newtype("code", tp_object, NULL, (py_Dtor)CodeObject__dtor, false, true);
    return type;
}

bool _py_compile(CodeObject* out,
                 const char* source,
                 const char* filename,
                 enum py_CompileMode mode,
                 bool is_dynamic) {
    VM* vm = pk_current_vm;
    SourceData_ src = SourceData__rcnew(source, filename, mode, is_dynamic);
    Error* err = pk_compile(src, out);
    if(err) {
        py_exception(tp_SyntaxError, err->msg);
        py_BaseException__stpush(&vm->curr_exception, err->src, err->lineno, NULL);
        PK_DECREF(src);

        PK_DECREF(err->src);
        PK_FREE(err);
        return false;
    }
    PK_DECREF(src);
    return true;
}

bool py_compile(const char* source,
                const char* filename,
                enum py_CompileMode mode,
                bool is_dynamic) {
    CodeObject co;
    bool ok = _py_compile(&co, source, filename, mode, is_dynamic);
    if(ok) {
        // compile success
        CodeObject* ud = py_newobject(py_retval(), tp_code, 0, sizeof(CodeObject));
        *ud = co;
    }
    return ok;
}

bool pk_exec(CodeObject* co, py_Ref module) {
    VM* vm = pk_current_vm;
    if(!module) module = &vm->main;
    assert(module->type == tp_module);

    py_StackRef sp = vm->stack.sp;
    py_Frame* frame = Frame__new(co, sp, module, module, py_NIL(), true);
    VM__push_frame(vm, frame);
    FrameResult res = VM__run_top_frame(vm);
    if(res == RES_ERROR) return false;
    assert(res == RES_RETURN);
    return true;
}

bool pk_execdyn(CodeObject* co, py_Ref module, py_Ref globals, py_Ref locals) {
    VM* vm = pk_current_vm;
    if(!module) module = &vm->main;
    assert(module->type == tp_module);

    py_StackRef sp = vm->stack.sp;
    assert(globals != NULL && locals != NULL);

    // check globals
    if(globals->type == tp_namedict) {
        globals = py_getslot(globals, 0);
        assert(globals->type == tp_module);
    } else {
        if(!py_istype(globals, tp_dict)) { return TypeError("globals must be a dict object"); }
    }
    // check locals
    switch(locals->type) {
        case tp_locals: break;
        case tp_dict: break;
        case tp_nil: break;
        default: return TypeError("locals must be a dict object");
    }

    py_Frame* frame = Frame__new(co, sp, module, globals, locals, true);
    VM__push_frame(vm, frame);
    FrameResult res = VM__run_top_frame(vm);
    if(res == RES_ERROR) return false;
    assert(res == RES_RETURN);
    return true;
}

bool py_exec(const char* source, const char* filename, enum py_CompileMode mode, py_Ref module) {
    CodeObject co;
    if(!_py_compile(&co, source, filename, mode, false)) return false;
    bool ok = pk_exec(&co, module);
    CodeObject__dtor(&co);
    return ok;
}

bool py_eval(const char* source, py_Ref module) {
    return py_exec(source, "<string>", EVAL_MODE, module);
}
// src/public/py_mappingproxy.c
#include <stdbool.h>

void pk_mappingproxy__namedict(py_Ref out, py_Ref object) {
    py_newobject(out, tp_namedict, 1, 0);
    assert(object->is_ptr && object->_obj->slots == -1);
    py_setslot(out, 0, object);
}

static bool namedict__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    py_Ref res = py_getdict(py_getslot(argv, 0), name);
    if(!res) return KeyError(py_arg(1));
    py_assign(py_retval(), res);
    return true;
}

static bool namedict__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    py_setdict(py_getslot(argv, 0), name, py_arg(2));
    py_newnone(py_retval());
    return true;
}

static bool namedict__delitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    if(!py_deldict(py_getslot(argv, 0), name)) return KeyError(py_arg(1));
    py_newnone(py_retval());
    return true;
}

static bool namedict__contains__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_Name name = py_namev(py_tosv(py_arg(1)));
    py_Ref res = py_getdict(py_getslot(argv, 0), name);
    py_newbool(py_retval(), res != NULL);
    return true;
}

static bool namedict_items(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref object = py_getslot(argv, 0);
    NameDict* dict = PyObject__dict(object->_obj);
    py_newlist(py_retval());
    if(object->type == tp_type) {
        py_TypeInfo* ti = pk__type_info(py_totype(object));
        for(int j = 0; j < PK_MAGIC_SLOTS_COMMON_LENGTH; j++) {
            if(py_isnil(ti->magic_0 + j)) continue;
            py_Ref slot = py_list_emplace(py_retval());
            py_Ref p = py_newtuple(slot, 2);
            p[0] = *py_name2ref(j + PK_MAGIC_SLOTS_UNCOMMON_LENGTH);
            p[1] = ti->magic_0[j];
        }
        if(ti->magic_1) {
            for(int j = 0; j < PK_MAGIC_SLOTS_UNCOMMON_LENGTH; j++) {
                if(py_isnil(ti->magic_1 + j)) continue;
                py_Ref slot = py_list_emplace(py_retval());
                py_Ref p = py_newtuple(slot, 2);
                p[0] = *py_name2ref(j);
                p[1] = ti->magic_1[j];
            }
        }
    }
    for(int i = 0; i < dict->length; i++) {
        py_Ref slot = py_list_emplace(py_retval());
        py_Ref p = py_newtuple(slot, 2);
        NameDict_KV* kv = c11__at(NameDict_KV, dict, i);
        p[0] = *py_name2ref(kv->key);
        p[1] = kv->value;
    }
    return true;
}

static bool namedict_clear(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref object = py_getslot(argv, 0);
    NameDict* dict = PyObject__dict(object->_obj);
    NameDict__clear(dict);
    py_newnone(py_retval());
    return true;
}

py_Type pk_namedict__register() {
    py_Type type = pk_newtype("namedict", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __getitem__, namedict__getitem__);
    py_bindmagic(type, __setitem__, namedict__setitem__);
    py_bindmagic(type, __delitem__, namedict__delitem__);
    py_bindmagic(type, __contains__, namedict__contains__);
    py_newnone(py_tpgetmagic(type, __hash__));
    py_bindmethod(type, "items", namedict_items);
    py_bindmethod(type, "clear", namedict_clear);
    return type;
}

// src/public/py_list.c
void py_newlist(py_Ref out) {
    List* ud = py_newobject(out, tp_list, 0, sizeof(List));
    c11_vector__ctor(ud, sizeof(py_TValue));
}

void py_newlistn(py_Ref out, int n) {
    py_newlist(out);
    List* ud = py_touserdata(out);
    c11_vector__reserve(ud, n);
    ud->length = n;
}

py_Ref py_list_data(py_Ref self) {
    List* ud = py_touserdata(self);
    return ud->data;
}

py_Ref py_list_getitem(py_Ref self, int i) {
    List* ud = py_touserdata(self);
    return c11__at(py_TValue, ud, i);
}

void py_list_setitem(py_Ref self, int i, py_Ref val) {
    List* ud = py_touserdata(self);
    c11__setitem(py_TValue, ud, i, *val);
}

void py_list_delitem(py_Ref self, int i) {
    List* ud = py_touserdata(self);
    c11_vector__erase(py_TValue, ud, i);
}

int py_list_len(py_Ref self) {
    List* ud = py_touserdata(self);
    return ud->length;
}

void py_list_swap(py_Ref self, int i, int j) {
    py_TValue* data = py_list_data(self);
    py_TValue tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}

void py_list_append(py_Ref self, py_Ref val) {
    List* ud = py_touserdata(self);
    c11_vector__push(py_TValue, ud, *val);
}

py_ItemRef py_list_emplace(py_Ref self) {
    List* ud = py_touserdata(self);
    c11_vector__emplace(ud);
    return &c11_vector__back(py_TValue, ud);
}

void py_list_clear(py_Ref self) {
    List* ud = py_touserdata(self);
    c11_vector__clear(ud);
}

void py_list_insert(py_Ref self, int i, py_Ref val) {
    List* ud = py_touserdata(self);
    c11_vector__insert(py_TValue, ud, i, *val);
}

////////////////////////////////
static bool list__len__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 res = py_list_len(py_arg(0));
    py_newint(py_retval(), res);
    return true;
}

static bool list__eq__(int argc, py_Ref argv) {
    return pk_wrapper__arrayequal(tp_list, argc, argv);
}

static bool list__ne__(int argc, py_Ref argv) {
    if(!list__eq__(argc, argv)) return false;
    if(py_isbool(py_retval())) {
        bool res = py_tobool(py_retval());
        py_newbool(py_retval(), !res);
    }
    return true;
}

static bool list__new__(int argc, py_Ref argv) {
    if(argc == 1) {
        py_newlist(py_retval());
        return true;
    }
    if(argc == 2) {
        py_TValue* p;
        int length = pk_arrayview(py_arg(1), &p);
        if(length != -1) {
            py_newlistn(py_retval(), length);
            for(int i = 0; i < length; i++) {
                py_list_setitem(py_retval(), i, p + i);
            }
            return true;
        }

        if(!py_iter(py_arg(1))) return false;

        py_Ref iter = py_pushtmp();
        py_Ref list = py_pushtmp();
        *iter = *py_retval();
        py_newlist(list);
        while(true) {
            int res = py_next(iter);
            if(res == -1) {
                py_shrink(2);
                return false;
            }
            if(!res) break;
            py_list_append(list, py_retval());
        }
        *py_retval() = *list;
        py_shrink(2);
        return true;
    }
    return TypeError("list() takes at most 1 argument");
}

static bool list__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    List* self = py_touserdata(py_arg(0));
    py_Ref _1 = py_arg(1);
    if(_1->type == tp_int) {
        int index = py_toint(py_arg(1));
        if(!pk__normalize_index(&index, self->length)) return false;
        *py_retval() = c11__getitem(py_TValue, self, index);
        return true;
    } else if(_1->type == tp_slice) {
        int start, stop, step;
        bool ok = pk__parse_int_slice(_1, self->length, &start, &stop, &step);
        if(!ok) return false;
        py_newlist(py_retval());
        List* list = py_touserdata(py_retval());
        PK_SLICE_LOOP(i, start, stop, step) {
            c11_vector__push(py_TValue, list, c11__getitem(py_TValue, self, i));
        }
        return true;
    } else {
        return TypeError("list indices must be integers");
    }
}

static bool list__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_int);
    List* self = py_touserdata(py_arg(0));
    int index = py_toint(py_arg(1));
    if(!pk__normalize_index(&index, self->length)) return false;
    c11__setitem(py_TValue, self, index, *py_arg(2));
    py_newnone(py_retval());
    return true;
}

static bool list__delitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_int);
    List* self = py_touserdata(py_arg(0));
    int index = py_toint(py_arg(1));
    if(!pk__normalize_index(&index, self->length)) return false;
    c11_vector__erase(py_TValue, self, index);
    py_newnone(py_retval());
    return true;
}

static bool list__add__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_Ref _0 = py_arg(0);
    py_Ref _1 = py_arg(1);
    if(py_istype(_1, tp_list)) {
        List* list_0 = py_touserdata(_0);
        List* list_1 = py_touserdata(_1);
        py_newlist(py_retval());
        List* list = py_touserdata(py_retval());
        c11_vector__extend(py_TValue, list, list_0->data, list_0->length);
        c11_vector__extend(py_TValue, list, list_1->data, list_1->length);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool list__mul__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_Ref _0 = py_arg(0);
    py_Ref _1 = py_arg(1);
    if(py_istype(_1, tp_int)) {
        int n = py_toint(_1);
        py_newlist(py_retval());
        List* list = py_touserdata(py_retval());
        List* list_0 = py_touserdata(_0);
        for(int i = 0; i < n; i++) {
            c11_vector__extend(py_TValue, list, list_0->data, list_0->length);
        }
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool list__rmul__(int argc, py_Ref argv) { return list__mul__(argc, argv); }

static bool list_append(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_list_append(py_arg(0), py_arg(1));
    py_newnone(py_retval());
    return true;
}

static bool list__repr__(int argc, py_Ref argv) {
    List* self = py_touserdata(py_arg(0));
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_char(&buf, '[');
    for(int i = 0; i < self->length; i++) {
        py_TValue* val = c11__at(py_TValue, self, i);
        bool ok = py_repr(val);
        if(!ok) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        if(i != self->length - 1) c11_sbuf__write_cstr(&buf, ", ");
    }
    c11_sbuf__write_char(&buf, ']');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool list_extend(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    List* self = py_touserdata(py_arg(0));
    py_TValue* p;
    int length = pk_arrayview(py_arg(1), &p);
    if(length == -1) return TypeError("extend() argument must be a list or tuple");
    c11_vector__extend(py_TValue, self, p, length);
    py_newnone(py_retval());
    return true;
}

static bool list_count(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    int count = 0;
    for(int i = 0; i < py_list_len(py_arg(0)); i++) {
        int res = py_equal(py_list_getitem(py_arg(0), i), py_arg(1));
        if(res == -1) return false;
        if(res) count++;
    }
    py_newint(py_retval(), count);
    return true;
}

static bool list_clear(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_list_clear(py_arg(0));
    py_newnone(py_retval());
    return true;
}

static bool list_copy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_newlist(py_retval());
    List* self = py_touserdata(py_arg(0));
    List* list = py_touserdata(py_retval());
    c11_vector__extend(py_TValue, list, self->data, self->length);
    return true;
}

static bool list_index(int argc, py_Ref argv) {
    if(argc > 3) return TypeError("index() takes at most 3 arguments");
    int start = 0;
    if(argc == 3) {
        PY_CHECK_ARG_TYPE(2, tp_int);
        start = py_toint(py_arg(2));
    }
    for(int i = start; i < py_list_len(py_arg(0)); i++) {
        int res = py_equal(py_list_getitem(py_arg(0), i), py_arg(1));
        if(res == -1) return false;
        if(res) {
            py_newint(py_retval(), i);
            return true;
        }
    }
    return ValueError("list.index(x): x not in list");
}

static bool list_reverse(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    List* self = py_touserdata(py_arg(0));
    c11__reverse(py_TValue, self);
    py_newnone(py_retval());
    return true;
}

static bool list_remove(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    for(int i = 0; i < py_list_len(py_arg(0)); i++) {
        int res = py_equal(py_list_getitem(py_arg(0), i), py_arg(1));
        if(res == -1) return false;
        if(res) {
            py_list_delitem(py_arg(0), i);
            py_newnone(py_retval());
            return true;
        }
    }
    return ValueError("list.remove(x): x not in list");
}

static bool list_pop(int argc, py_Ref argv) {
    int index;
    if(argc == 1) {
        index = -1;
    } else if(argc == 2) {
        PY_CHECK_ARG_TYPE(1, tp_int);
        index = py_toint(py_arg(1));
    } else {
        return TypeError("pop() takes at most 2 arguments");
    }
    List* self = py_touserdata(py_arg(0));
    if(self->length == 0) return IndexError("pop from empty list");
    if(!pk__normalize_index(&index, self->length)) return false;
    *py_retval() = c11__getitem(py_TValue, self, index);
    c11_vector__erase(py_TValue, self, index);
    return true;
}

static bool list_insert(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_int);
    List* self = py_touserdata(py_arg(0));
    int index = py_toint(py_arg(1));
    if(index < 0) index += self->length;
    if(index < 0) index = 0;
    if(index > self->length) index = self->length;
    c11_vector__insert(py_TValue, self, index, *py_arg(2));
    py_newnone(py_retval());
    return true;
}

static int lt_with_key(py_TValue* a, py_TValue* b, py_TValue* key) {
    if(!key) return py_less(a, b);
    VM* vm = pk_current_vm;
    // project a
    py_push(key);
    py_pushnil();
    py_push(a);
    if(!py_vectorcall(1, 0)) return -1;
    py_push(py_retval());
    // project b
    py_push(key);
    py_pushnil();
    py_push(b);
    if(!py_vectorcall(1, 0)) return -1;
    py_push(py_retval());
    // binary op
    bool ok = pk_stack_binaryop(vm, __lt__, __gt__);
    if(!ok) return -1;
    py_shrink(2);
    return py_bool(py_retval());
}

// sort(self, key=None, reverse=False)
static bool list_sort(int argc, py_Ref argv) {
    List* self = py_touserdata(py_arg(0));

    py_Ref key = py_arg(1);
    if(py_isnone(key)) key = NULL;

    bool ok = c11__stable_sort(self->data,
                               self->length,
                               sizeof(py_TValue),
                               (int (*)(const void*, const void*, void*))lt_with_key,
                               key);
    if(!ok) return false;

    PY_CHECK_ARG_TYPE(2, tp_bool);
    bool reverse = py_tobool(py_arg(2));
    if(reverse) c11__reverse(py_TValue, self);
    py_newnone(py_retval());
    return true;
}

static bool list__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return pk_arrayiter(argv);
}

static bool list__contains__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    return pk_arraycontains(py_arg(0), py_arg(1));
}

py_Type pk_list__register() {
    py_Type type =
        pk_newtype("list", tp_object, NULL, (void (*)(void*))c11_vector__dtor, false, true);

    py_bindmagic(type, __len__, list__len__);
    py_bindmagic(type, __eq__, list__eq__);
    py_bindmagic(type, __ne__, list__ne__);
    py_bindmagic(type, __new__, list__new__);
    py_bindmagic(type, __getitem__, list__getitem__);
    py_bindmagic(type, __setitem__, list__setitem__);
    py_bindmagic(type, __delitem__, list__delitem__);
    py_bindmagic(type, __add__, list__add__);
    py_bindmagic(type, __mul__, list__mul__);
    py_bindmagic(type, __rmul__, list__rmul__);
    py_bindmagic(type, __repr__, list__repr__);
    py_bindmagic(type, __iter__, list__iter__);
    py_bindmagic(type, __contains__, list__contains__);

    py_bindmethod(type, "append", list_append);
    py_bindmethod(type, "extend", list_extend);
    py_bindmethod(type, "count", list_count);
    py_bindmethod(type, "clear", list_clear);
    py_bindmethod(type, "copy", list_copy);
    py_bindmethod(type, "index", list_index);
    py_bindmethod(type, "reverse", list_reverse);
    py_bindmethod(type, "remove", list_remove);
    py_bindmethod(type, "pop", list_pop);
    py_bindmethod(type, "insert", list_insert);
    py_bindmethod(type, "sort", list_sort);

    py_bind(py_tpobject(type), "sort(self, key=None, reverse=False)", list_sort);

    py_setdict(py_tpobject(type), __hash__, py_None());
    return type;
}

// src/public/cast.c
int64_t py_toint(py_Ref self) {
    assert(self->type == tp_int);
    return self->_i64;
}

double py_tofloat(py_Ref self) {
    assert(self->type == tp_float);
    return self->_f64;
}

bool py_castfloat(py_Ref self, double* out) {
    switch(self->type) {
        case tp_int: *out = (double)self->_i64; return true;
        case tp_float: *out = self->_f64; return true;
        default: return TypeError("expected 'int' or 'float', got '%t'", self->type);
    }
}

bool py_castfloat32(py_Ref self, float* out) {
    switch(self->type) {
        case tp_int: *out = (float)self->_i64; return true;
        case tp_float: *out = (float)self->_f64; return true;
        default: return TypeError("expected 'int' or 'float', got '%t'", self->type);
    }
}

bool py_castint(py_Ref self, int64_t* out) {
    if(self->type == tp_int) {
        *out = self->_i64;
        return true;
    }
    return TypeError("expected 'int', got '%t'", self->type);
}

bool py_tobool(py_Ref self) {
    assert(self->type == tp_bool);
    return self->_bool;
}

py_Type py_totype(py_Ref self) {
    assert(self->type == tp_type);
    py_Type* ud = py_touserdata(self);
    return *ud;
}

void* py_touserdata(py_Ref self) {
    assert(self && self->is_ptr);
    return PyObject__userdata(self->_obj);
}

bool py_istype(py_Ref self, py_Type type) { return self->type == type; }

bool py_checktype(py_Ref self, py_Type type) {
    if(self->type == type) return true;
    return TypeError("expected '%t', got '%t'", type, self->type);
}

bool py_checkinstance(py_Ref self, py_Type type) {
    if(py_isinstance(self, type)) return true;
    return TypeError("expected '%t' or its subclass, got '%t'", type, self->type);
}

bool py_isinstance(py_Ref obj, py_Type type) { return py_issubclass(obj->type, type); }

bool py_issubclass(py_Type derived, py_Type base) {
    TypeList* types = &pk_current_vm->types;
    do {
        if(derived == base) return true;
        derived = TypeList__get(types, derived)->base;
    } while(derived);
    return false;
}

py_Type py_typeof(py_Ref self) { return self->type; }

py_Type py_gettype(const char* module, py_Name name) {
    py_Ref mod;
    if(module != NULL) {
        mod = py_getmodule(module);
        if(!mod) return 0;
    } else {
        mod = &pk_current_vm->builtins;
    }
    py_Ref object = py_getdict(mod, name);
    if(object && py_istype(object, tp_type)) return py_totype(object);
    return 0;
}
// src/public/py_property.c
static bool property__new__(int argc, py_Ref argv) {
    py_newobject(py_retval(), tp_property, 2, 0);
    if(argc == 1 + 1) {
        py_setslot(py_retval(), 0, py_arg(1));
        py_setslot(py_retval(), 1, py_None());
    } else if(argc == 1 + 2) {
        py_setslot(py_retval(), 0, py_arg(1));
        py_setslot(py_retval(), 1, py_arg(2));
    } else {
        return TypeError("property() expected 1 or 2 arguments, got %d", argc - 1);
    }
    return true;
}

static bool property_setter(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_setslot(argv, 1, py_arg(1));
    py_assign(py_retval(), argv);
    return true;
}

static bool property_fget(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref fget = py_getslot(argv, 0);
    py_assign(py_retval(), fget);
    return true;
}

static bool property_fset(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref fset = py_getslot(argv, 1);
    py_assign(py_retval(), fset);
    return true;
}

py_Type pk_property__register() {
    py_Type type = pk_newtype("property", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, property__new__);
    py_bindmethod(type, "setter", property_setter);

    py_bindproperty(type, "fget", property_fget, NULL);
    py_bindproperty(type, "fset", property_fset, NULL);
    return type;
}

// src/public/py_slice.c
void py_newslice(py_Ref out) {
    VM* vm = pk_current_vm;
    PyObject* obj = ManagedHeap__gcnew(&vm->heap, tp_slice, 3, 0);
    out->type = tp_slice;
    out->is_ptr = true;
    out->_obj = obj;
}

static bool slice__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1 + 3);
    py_Ref slice = py_retval();
    py_newslice(slice);
    py_setslot(slice, 0, py_arg(1));
    py_setslot(slice, 1, py_arg(2));
    py_setslot(slice, 2, py_arg(3));
    return true;
}

static bool slice__repr__(int argc, py_Ref argv) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_cstr(&buf, "slice(");
    for(int i = 0; i < 3; i++) {
        py_TValue* val = py_getslot(argv, i);
        bool ok = py_repr(val);
        if(!ok) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        if(i != 2) c11_sbuf__write_cstr(&buf, ", ");
    }
    c11_sbuf__write_char(&buf, ')');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool slice_start(int argc, py_Ref argv) {
    py_Ref self = py_arg(0);
    py_TValue* val = py_getslot(self, 0);
    py_assign(py_retval(), val);
    return true;
}

static bool slice_stop(int argc, py_Ref argv) {
    py_Ref self = py_arg(0);
    py_TValue* val = py_getslot(self, 1);
    py_assign(py_retval(), val);
    return true;
}

static bool slice_step(int argc, py_Ref argv) {
    py_Ref self = py_arg(0);
    py_TValue* val = py_getslot(self, 2);
    py_assign(py_retval(), val);
    return true;
}

static bool slice__eq__(int argc, py_Ref argv) {
    py_Ref self = py_arg(0);
    py_Ref other = py_arg(1);
    if(!py_istype(other, tp_slice)) {
        py_newnotimplemented(py_retval());
        return true;
    }
    for(int i = 0; i < 3; i++) {
        py_Ref lhs = py_getslot(self, i);
        py_Ref rhs = py_getslot(other, i);
        int res = py_equal(lhs, rhs);
        if(res == -1) return false;
        if(res == 0) {
            py_newbool(py_retval(), false);
            return true;
        }
    }
    py_newbool(py_retval(), true);
    return true;
}

static bool slice__ne__(int argc, py_Ref argv) {
    bool ok = slice__eq__(argc, argv);
    if(!ok) return false;
    py_Ref res = py_retval();
    if(py_isbool(res)) py_newbool(py_retval(), !py_tobool(res));
    return true;
}

py_Type pk_slice__register() {
    py_Type type = pk_newtype("slice", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __new__, slice__new__);
    py_bindmagic(type, __repr__, slice__repr__);
    py_bindmagic(type, __eq__, slice__eq__);
    py_bindmagic(type, __ne__, slice__ne__);

    py_setdict(py_tpobject(type), __hash__, py_None());

    py_bindproperty(type, "start", slice_start, NULL);
    py_bindproperty(type, "stop", slice_stop, NULL);
    py_bindproperty(type, "step", slice_step, NULL);
    return type;
}
// src/public/stack_ops.c
py_Ref py_getreg(int i) { return pk_current_vm->reg + i; }

void py_setreg(int i, py_Ref val) { pk_current_vm->reg[i] = *val; }

py_Ref py_getdict(py_Ref self, py_Name name) {
    assert(self && self->is_ptr);
    if(!py_ismagicname(name) || self->type != tp_type) {
        return NameDict__try_get(PyObject__dict(self->_obj), name);
    } else {
        py_Type* ud = py_touserdata(self);
        py_Ref slot = py_tpgetmagic(*ud, name);
        return py_isnil(slot) ? NULL : slot;
    }
}

void py_setdict(py_Ref self, py_Name name, py_Ref val) {
    assert(self && self->is_ptr);
    if(!py_ismagicname(name) || self->type != tp_type) {
        NameDict__set(PyObject__dict(self->_obj), name, *val);
    } else {
        py_Type* ud = py_touserdata(self);
        *py_tpgetmagic(*ud, name) = *val;
    }
}

py_ItemRef py_emplacedict(py_Ref self, py_Name name) {
    py_setdict(self, name, py_NIL());
    return py_getdict(self, name);
}

bool py_applydict(py_Ref self, bool (*f)(py_Name, py_Ref, void*), void* ctx) {
    assert(self && self->is_ptr);
    NameDict* dict = PyObject__dict(self->_obj);
    for(int i = 0; i < dict->length; i++) {
        NameDict_KV* kv = c11__at(NameDict_KV, dict, i);
        bool ok = f(kv->key, &kv->value, ctx);
        if(!ok) return false;
    }
    return true;
}

bool py_deldict(py_Ref self, py_Name name) {
    assert(self && self->is_ptr);
    if(!py_ismagicname(name) || self->type != tp_type) {
        return NameDict__del(PyObject__dict(self->_obj), name);
    } else {
        py_Type* ud = py_touserdata(self);
        py_newnil(py_tpgetmagic(*ud, name));
        return true;
    }
}

py_Ref py_getslot(py_Ref self, int i) {
    assert(self && self->is_ptr);
    assert(i >= 0 && i < self->_obj->slots);
    return PyObject__slots(self->_obj) + i;
}

void py_setslot(py_Ref self, int i, py_Ref val) {
    assert(self && self->is_ptr);
    assert(i >= 0 && i < self->_obj->slots);
    PyObject__slots(self->_obj)[i] = *val;
}

py_StackRef py_inspect_currentfunction() {
    VM* vm = pk_current_vm;
    if(vm->curr_decl_based_function) { return vm->curr_decl_based_function; }
    py_Frame* frame = vm->top_frame;
    if(!frame || frame->is_locals_special) return NULL;
    return frame->p0;
}

py_GlobalRef py_inspect_currentmodule() {
    py_Frame* frame = pk_current_vm->top_frame;
    if(!frame) return NULL;
    return frame->module;
}

py_Frame* py_inspect_currentframe() { return pk_current_vm->top_frame; }

void py_assign(py_Ref dst, py_Ref src) { *dst = *src; }

/* Stack References */
py_Ref py_peek(int i) {
    assert(i <= 0);
    return pk_current_vm->stack.sp + i;
}

void py_pop() {
    VM* vm = pk_current_vm;
    vm->stack.sp--;
}

void py_shrink(int n) {
    VM* vm = pk_current_vm;
    vm->stack.sp -= n;
}

void py_push(py_Ref src) {
    VM* vm = pk_current_vm;
    *vm->stack.sp++ = *src;
}

void py_pushnil() {
    VM* vm = pk_current_vm;
    py_newnil(vm->stack.sp++);
}

void py_pushnone() {
    VM* vm = pk_current_vm;
    py_newnone(vm->stack.sp++);
}

void py_pushname(py_Name name) {
    VM* vm = pk_current_vm;
    py_newint(vm->stack.sp++, name);
}

py_Ref py_pushtmp() {
    VM* vm = pk_current_vm;
    return vm->stack.sp++;
}
// src/public/internal.c
VM* pk_current_vm;

static VM pk_default_vm;
static VM* pk_all_vm[16];
static py_TValue _True, _False, _None, _NIL;

void py_initialize() {
    if(pk_current_vm) {
        // c11__abort("py_initialize() can only be called once!");
        return;
    }

    // check endianness
    int x = 1;
    bool is_little_endian = *(char*)&x == 1;
    if(!is_little_endian) c11__abort("is_little_endian != true");

    // check py_TValue; 16 bytes to make py_arg() macro work
    static_assert(sizeof(py_CFunction) <= 8, "sizeof(py_CFunction) > 8");
    static_assert(sizeof(py_TValue) == 16, "sizeof(py_TValue) != 16");
    static_assert(offsetof(py_TValue, extra) == 4, "offsetof(py_TValue, extra) != 4");

    pk_current_vm = pk_all_vm[0] = &pk_default_vm;

    // initialize some convenient references
    py_newbool(&_True, true);
    py_newbool(&_False, false);
    py_newnone(&_None);
    py_newnil(&_NIL);
    VM__ctor(&pk_default_vm);
}

py_GlobalRef py_True() { return &_True; }

py_GlobalRef py_False() { return &_False; }

py_GlobalRef py_None() { return &_None; }

py_GlobalRef py_NIL() { return &_NIL; }

void py_finalize() {
    for(int i = 1; i < 16; i++) {
        VM* vm = pk_all_vm[i];
        if(vm) {
            // temp fix https://github.com/pocketpy/pocketpy/issues/315
            // TODO: refactor VM__ctor and VM__dtor
            pk_current_vm = vm;
            VM__dtor(vm);
            PK_FREE(vm);
        }
    }
    pk_current_vm = &pk_default_vm;
    VM__dtor(&pk_default_vm);
    pk_current_vm = NULL;
}

void py_switchvm(int index) {
    if(index < 0 || index >= 16) c11__abort("invalid vm index");
    if(!pk_all_vm[index]) {
        pk_current_vm = pk_all_vm[index] = PK_MALLOC(sizeof(VM));
        memset(pk_current_vm, 0, sizeof(VM));
        VM__ctor(pk_all_vm[index]);
    } else {
        pk_current_vm = pk_all_vm[index];
    }
}

void py_resetvm() {
    VM* vm = pk_current_vm;
    VM__dtor(vm);
    memset(vm, 0, sizeof(VM));
    VM__ctor(vm);
}

int py_currentvm() {
    for(int i = 0; i < 16; i++) {
        if(pk_all_vm[i] == pk_current_vm) return i;
    }
    return -1;
}

void* py_getvmctx() { return pk_current_vm->ctx; }

void py_setvmctx(void* ctx) { pk_current_vm->ctx = ctx; }

void py_sys_setargv(int argc, char** argv) {
    py_GlobalRef sys = py_getmodule("sys");
    py_Ref argv_list = py_getdict(sys, py_name("argv"));
    py_list_clear(argv_list);
    for(int i = 0; i < argc; i++) {
        py_newstr(py_list_emplace(argv_list), argv[i]);
    }
}

py_Callbacks* py_callbacks() { return &pk_current_vm->callbacks; }

const char* pk_opname(Opcode op) {
    const static char* OP_NAMES[] = {
#define OPCODE(name) #name,
#ifdef OPCODE

/**************************/
OPCODE(NO_OP)
/**************************/
OPCODE(POP_TOP)
OPCODE(DUP_TOP)
OPCODE(DUP_TOP_TWO)
OPCODE(ROT_TWO)
OPCODE(ROT_THREE)
OPCODE(PRINT_EXPR)
/**************************/
OPCODE(LOAD_CONST)
OPCODE(LOAD_NONE)
OPCODE(LOAD_TRUE)
OPCODE(LOAD_FALSE)
/**************************/
OPCODE(LOAD_SMALL_INT)
/**************************/
OPCODE(LOAD_ELLIPSIS)
OPCODE(LOAD_FUNCTION)
OPCODE(LOAD_NULL)
/**************************/
OPCODE(LOAD_FAST)
OPCODE(LOAD_NAME)
OPCODE(LOAD_NONLOCAL)
OPCODE(LOAD_GLOBAL)
OPCODE(LOAD_ATTR)
OPCODE(LOAD_CLASS_GLOBAL)
OPCODE(LOAD_METHOD)
OPCODE(LOAD_SUBSCR)

OPCODE(STORE_FAST)
OPCODE(STORE_NAME)
OPCODE(STORE_GLOBAL)
OPCODE(STORE_ATTR)
OPCODE(STORE_SUBSCR)

OPCODE(DELETE_FAST)
OPCODE(DELETE_NAME)
OPCODE(DELETE_GLOBAL)
OPCODE(DELETE_ATTR)
OPCODE(DELETE_SUBSCR)
/**************************/
OPCODE(BUILD_IMAG)
OPCODE(BUILD_BYTES)
OPCODE(BUILD_TUPLE)
OPCODE(BUILD_LIST)
OPCODE(BUILD_DICT)
OPCODE(BUILD_SET)
OPCODE(BUILD_SLICE)
OPCODE(BUILD_STRING)
/**************************/
OPCODE(BINARY_OP)
OPCODE(IS_OP)
OPCODE(CONTAINS_OP)
/**************************/
OPCODE(JUMP_FORWARD)
OPCODE(POP_JUMP_IF_FALSE)
OPCODE(POP_JUMP_IF_TRUE)
OPCODE(JUMP_IF_TRUE_OR_POP)
OPCODE(JUMP_IF_FALSE_OR_POP)
OPCODE(SHORTCUT_IF_FALSE_OR_POP)
OPCODE(LOOP_CONTINUE)
OPCODE(LOOP_BREAK)
/**************************/
OPCODE(CALL)
OPCODE(CALL_VARGS)
/**************************/
OPCODE(RETURN_VALUE)
OPCODE(YIELD_VALUE)
OPCODE(FOR_ITER_YIELD_VALUE)
/**************************/
OPCODE(LIST_APPEND)
OPCODE(DICT_ADD)
OPCODE(SET_ADD)
/**************************/
OPCODE(UNARY_NEGATIVE)
OPCODE(UNARY_NOT)
OPCODE(UNARY_STAR)
OPCODE(UNARY_INVERT)
/**************************/
OPCODE(GET_ITER)
OPCODE(FOR_ITER)
/**************************/
OPCODE(IMPORT_PATH)
OPCODE(POP_IMPORT_STAR)
/**************************/
OPCODE(UNPACK_SEQUENCE)
OPCODE(UNPACK_EX)
/**************************/
OPCODE(BEGIN_CLASS)
OPCODE(END_CLASS)
OPCODE(STORE_CLASS_ATTR)
OPCODE(ADD_CLASS_ANNOTATION)
/**************************/
OPCODE(WITH_ENTER)
OPCODE(WITH_EXIT)
/**************************/
OPCODE(TRY_ENTER)
OPCODE(EXCEPTION_MATCH)
OPCODE(RAISE)
OPCODE(RAISE_ASSERT)
OPCODE(RE_RAISE)
OPCODE(PUSH_EXCEPTION)
OPCODE(BEGIN_EXC_HANDLING)
OPCODE(END_EXC_HANDLING)
OPCODE(BEGIN_FINALLY)
OPCODE(END_FINALLY)
/**************************/
OPCODE(FORMAT_STRING)
/**************************/
#endif

#undef OPCODE
    };
    return OP_NAMES[op];
}

bool py_call(py_Ref f, int argc, py_Ref argv) {
    if(f->type == tp_nativefunc) {
        return py_callcfunc(f->_cfunc, argc, argv);
    } else {
        py_push(f);
        py_pushnil();
        for(int i = 0; i < argc; i++)
            py_push(py_offset(argv, i));
        bool ok = py_vectorcall(argc, 0);
        return ok;
    }
}

#ifndef NDEBUG
bool py_callcfunc(py_CFunction f, int argc, py_Ref argv) {
    py_StackRef p0 = py_peek(0);
    // NOTE: sometimes users are using `py_retval()` to pass `argv`
    // It will be reset to `nil` and cause an exception
    py_newnil(py_retval());
    bool ok = f(argc, argv);
    if(!ok) {
        if(!py_checkexc(true)) {
            c11__abort("py_CFunction returns `false` but no exception is set!");
        }
        return false;
    }
    if(py_peek(0) != p0) {
        c11__abort("py_CFunction corrupts the stack! Did you forget to call `py_pop()`?");
    }
    if(py_isnil(py_retval())) {
        c11__abort(
            "py_CFunction returns nothing! Did you forget to call `py_newnone(py_retval())`?");
    }
    if(py_checkexc(true)) {
        const char* name = py_tpname(pk_current_vm->curr_exception.type);
        c11__abort("py_CFunction returns `true`, but `%s` was set!", name);
    }
    return true;
}
#endif

bool py_vectorcall(uint16_t argc, uint16_t kwargc) {
    return VM__vectorcall(pk_current_vm, argc, kwargc, false) != RES_ERROR;
}

py_Ref py_retval() { return &pk_current_vm->last_retval; }

bool py_pushmethod(py_Name name) {
    bool ok = pk_loadmethod(py_peek(-1), name);
    if(ok) pk_current_vm->stack.sp++;
    return ok;
}

bool pk_loadmethod(py_StackRef self, py_Name name) {
    // NOTE: `out` and `out_self` may overlap with `self`
    py_Type type;

    if(name == __new__) {
        // __new__ acts like a @staticmethod
        if(self->type == tp_type) {
            // T.__new__(...)
            type = py_totype(self);
        } else if(self->type == tp_super) {
            // super(T, obj).__new__(...)
            type = *(py_Type*)py_touserdata(self);
        } else {
            // invalid usage of `__new__`
            return false;
        }
        py_Ref cls_var = py_tpfindmagic(type, name);
        if(cls_var) {
            self[0] = *cls_var;
            self[1] = *py_NIL();
            return true;
        }
        return false;
    }

    py_TValue self_bak;  // to avoid overlapping
    // handle super() proxy
    if(py_istype(self, tp_super)) {
        type = *(py_Type*)py_touserdata(self);
        // BUG: here we modify `self` which refers to the stack directly
        // If `pk_loadmethod` fails, `self` will be corrupted
        self_bak = *py_getslot(self, 0);
    } else {
        type = self->type;
        self_bak = *self;
    }

    py_Ref cls_var = py_tpfindname(type, name);
    if(cls_var != NULL) {
        switch(cls_var->type) {
            case tp_function:
            case tp_nativefunc: {
                self[0] = *cls_var;
                self[1] = self_bak;
                break;
            }
            case tp_staticmethod:
                self[0] = *py_getslot(cls_var, 0);
                self[1] = *py_NIL();
                break;
            case tp_classmethod:
                self[0] = *py_getslot(cls_var, 0);
                self[1] = pk__type_info(type)->self;
                break;
            default: c11__unreachable();
        }
        return true;
    }
    return false;
}

py_Ref py_tpfindmagic(py_Type t, py_Name name) {
    assert(py_ismagicname(name));
    py_TypeInfo* ti = pk__type_info(t);
    do {
        py_Ref f = TypeList__magic_readonly(ti, name);
        assert(f != NULL);
        if(!py_isnil(f)) return f;
        ti = ti->base_ti;
    } while(ti);
    return NULL;
}

py_Ref py_tpfindname(py_Type t, py_Name name) {
    py_TypeInfo* ti = pk__type_info(t);
    do {
        py_Ref res = py_getdict(&ti->self, name);
        if(res) return res;
        ti = ti->base_ti;
    } while(ti);
    return NULL;
}

py_Ref py_tpgetmagic(py_Type type, py_Name name) {
    assert(py_ismagicname(name));
    py_TypeInfo* ti = pk__type_info(type);
    return TypeList__magic(ti, name);
}

py_Ref py_tpobject(py_Type type) {
    assert(type);
    return &pk__type_info(type)->self;
}

const char* py_tpname(py_Type type) {
    if(!type) return "nil";
    py_Name name = pk__type_info(type)->name;
    return py_name2str(name);
}

bool py_tpcall(py_Type type, int argc, py_Ref argv) {
    return py_call(py_tpobject(type), argc, argv);
}

bool pk_callmagic(py_Name name, int argc, py_Ref argv) {
    assert(argc >= 1);
    assert(py_ismagicname(name));
    py_Ref tmp = py_tpfindmagic(argv->type, name);
    if(!tmp) return AttributeError(argv, name);
    return py_call(tmp, argc, argv);
}

bool StopIteration() {
    bool ok = py_tpcall(tp_StopIteration, 0, NULL);
    if(!ok) return false;
    return py_raise(py_retval());
}

// src/public/py_tuple.c
py_ObjectRef py_newtuple(py_Ref out, int n) {
    VM* vm = pk_current_vm;
    PyObject* obj = ManagedHeap__gcnew(&vm->heap, tp_tuple, n, 0);
    out->type = tp_tuple;
    out->is_ptr = true;
    out->_obj = obj;
    return PyObject__slots(obj);
}

py_Ref py_tuple_getitem(py_Ref self, int i) { return py_getslot(self, i); }

py_Ref py_tuple_data(py_Ref self) { return PyObject__slots(self->_obj); }

void py_tuple_setitem(py_Ref self, int i, py_Ref val) { py_setslot(self, i, val); }

int py_tuple_len(py_Ref self) { return self->_obj->slots; }

//////////////
static bool tuple__len__(int argc, py_Ref argv) {
    py_newint(py_retval(), py_tuple_len(argv));
    return true;
}

static bool tuple__repr__(int argc, py_Ref argv) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_char(&buf, '(');
    int length = py_tuple_len(argv);
    for(int i = 0; i < length; i++) {
        py_TValue* val = py_getslot(argv, i);
        bool ok = py_repr(val);
        if(!ok) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        if(i != length - 1) c11_sbuf__write_cstr(&buf, ", ");
    }
    if(length == 1) c11_sbuf__write_char(&buf, ',');
    c11_sbuf__write_char(&buf, ')');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool tuple__new__(int argc, py_Ref argv) {
    if(argc == 1 + 0) {
        py_newtuple(py_retval(), 0);
        return true;
    }
    if(argc == 1 + 1) {
        bool ok = py_tpcall(tp_list, 1, py_arg(1));
        if(!ok) return false;
        py_Ref tmp = py_pushtmp();
        *tmp = *py_retval();  // backup the list
        int length = py_list_len(tmp);
        py_Ref p = py_newtuple(py_retval(), length);
        for(int i = 0; i < py_tuple_len(py_retval()); i++) {
            p[i] = *py_list_getitem(tmp, i);
        }
        py_pop();
        return true;
    }
    return TypeError("tuple() takes at most 1 argument");
}

static bool tuple__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    int length = py_tuple_len(argv);
    py_Ref _1 = py_arg(1);
    if(_1->type == tp_int) {
        int index = py_toint(py_arg(1));
        if(!pk__normalize_index(&index, length)) return false;
        *py_retval() = *py_getslot(argv, index);
        return true;
    } else if(_1->type == tp_slice) {
        int start, stop, step;
        bool ok = pk__parse_int_slice(_1, length, &start, &stop, &step);
        if(!ok) return false;
        py_Ref tmp = py_pushtmp();
        py_newlist(tmp);
        PK_SLICE_LOOP(i, start, stop, step) py_list_append(tmp, py_getslot(argv, i));
        // convert list to tuple
        py_Ref p = py_newtuple(py_retval(), py_list_len(tmp));
        for(int i = 0; i < py_tuple_len(py_retval()); i++) {
            p[i] = *py_list_getitem(tmp, i);
        }
        py_pop();
        return true;
    } else {
        return TypeError("tuple indices must be integers");
    }
}

static bool tuple__eq__(int argc, py_Ref argv) {
    return pk_wrapper__arrayequal(tp_tuple, argc, argv);
}

static bool tuple__ne__(int argc, py_Ref argv) {
    if(!tuple__eq__(argc, argv)) return false;
    if(py_isbool(py_retval())) {
        bool res = py_tobool(py_retval());
        py_newbool(py_retval(), !res);
    }
    return true;
}

static bool tuple__lt__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(!py_istype(py_arg(1), tp_tuple)) {
        py_newnotimplemented(py_retval());
        return true;
    }
    py_TValue *p0, *p1;
    int lhs_length = py_tuple_len(py_arg(0));
    int rhs_length = py_tuple_len(py_arg(1));
    p0 = py_tuple_data(py_arg(0));
    p1 = py_tuple_data(py_arg(1));
    int length = lhs_length < rhs_length ? lhs_length : rhs_length;
    for(int i = 0; i < length; i++) {
        int res_lt = py_less(p0 + i, p1 + i);
        if(res_lt == -1) return false;
        if(res_lt) {
            py_newbool(py_retval(), true);
            return true;
        } else {
            int res_eq = py_equal(p0 + i, p1 + i);
            if(res_eq == -1) return false;
            if(!res_eq) {
                py_newbool(py_retval(), false);
                return true;
            }
        }
    }
    py_newbool(py_retval(), lhs_length < rhs_length);
    return true;
}

static bool tuple__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return pk_arrayiter(argv);
}

static bool tuple__contains__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    return pk_arraycontains(py_arg(0), py_arg(1));
}

static bool tuple__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int length = py_tuple_len(argv);
    py_TValue* data = py_tuple_data(argv);
    uint64_t x = 1000003;
    for(int i = 0; i < length; i++) {
        py_i64 y;
        if(!py_hash(&data[i], &y)) return false;
        // recommended by Github Copilot
        x = x ^ (y + 0x9e3779b9 + (x << 6) + (x >> 2));
    }
    py_newint(py_retval(), x);
    return true;
}

py_Type pk_tuple__register() {
    py_Type type = pk_newtype("tuple", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __len__, tuple__len__);
    py_bindmagic(type, __repr__, tuple__repr__);
    py_bindmagic(type, __new__, tuple__new__);
    py_bindmagic(type, __getitem__, tuple__getitem__);
    py_bindmagic(type, __eq__, tuple__eq__);
    py_bindmagic(type, __ne__, tuple__ne__);
    py_bindmagic(type, __lt__, tuple__lt__);
    py_bindmagic(type, __iter__, tuple__iter__);
    py_bindmagic(type, __contains__, tuple__contains__);
    py_bindmagic(type, __hash__, tuple__hash__);
    return type;
}

// src/public/py_array.c
typedef struct array_iterator {
    py_TValue* p;
    int length;
    int index;
} array_iterator;

int pk_arrayview(py_Ref self, py_TValue** p) {
    if(self->type == tp_list) {
        *p = py_list_data(self);
        return py_list_len(self);
    }
    if(self->type == tp_tuple) {
        *p = PyObject__slots(self->_obj);
        return py_tuple_len(self);
    }
    return -1;
}

bool pk_wrapper__arrayequal(py_Type type, int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(!py_istype(py_arg(1), type)) {
        py_newnotimplemented(py_retval());
        return true;
    }
    py_TValue *p0, *p1;
    int lhs_length = pk_arrayview(py_arg(0), &p0);
    int rhs_length = pk_arrayview(py_arg(1), &p1);
    assert(lhs_length != -1 && rhs_length != -1);
    if(lhs_length != rhs_length) {
        py_newbool(py_retval(), false);
        return true;
    }
    for(int i = 0; i < lhs_length; i++) {
        int res = py_equal(p0 + i, p1 + i);
        if(res == -1) return false;
        if(!res) {
            py_newbool(py_retval(), false);
            return true;
        }
    }
    py_newbool(py_retval(), true);
    return true;
}

bool pk_arrayiter(py_Ref val) {
    py_TValue* p;
    int length = pk_arrayview(val, &p);
    if(length == -1) return TypeError("expected list or tuple, got %t", val->type);
    array_iterator* ud = py_newobject(py_retval(), tp_array_iterator, 1, sizeof(array_iterator));
    ud->p = p;
    ud->length = length;
    ud->index = 0;
    py_setslot(py_retval(), 0, val);  // keep a reference to the object
    return true;
}

bool pk_arraycontains(py_Ref self, py_Ref val) {
    py_TValue* p;
    int length = pk_arrayview(self, &p);
    if(length == -1) return TypeError("expected list or tuple, got %t", self->type);
    for(int i = 0; i < length; i++) {
        int res = py_equal(p + i, val);
        if(res == -1) return false;
        if(res) {
            py_newbool(py_retval(), true);
            return true;
        }
    }
    py_newbool(py_retval(), false);
    return true;
}

static bool array_iterator__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    *py_retval() = *argv;
    return true;
}

static bool array_iterator__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    array_iterator* ud = py_touserdata(argv);
    if(ud->index < ud->length) {
        *py_retval() = ud->p[ud->index++];
        return true;
    }
    return StopIteration();
}

py_Type pk_array_iterator__register() {
    py_Type type = pk_newtype("array_iterator", tp_object, NULL, NULL, false, true);
    py_bindmagic(type, __iter__, array_iterator__iter__);
    py_bindmagic(type, __next__, array_iterator__next__);
    return type;
}

// src/public/py_exception.c
typedef struct BaseExceptionFrame {
    SourceData_ src;
    int lineno;
    c11_string* name;
} BaseExceptionFrame;

typedef struct BaseException {
    c11_vector /*T=BaseExceptionFrame*/ stacktrace;
} BaseException;

void py_BaseException__stpush(py_Ref self, SourceData_ src, int lineno, const char* func_name) {
    BaseException* ud = py_touserdata(self);
    if(ud->stacktrace.length >= 7) return;
    BaseExceptionFrame* frame = c11_vector__emplace(&ud->stacktrace);
    PK_INCREF(src);
    frame->src = src;
    frame->lineno = lineno;
    frame->name = func_name ? c11_string__new(func_name) : NULL;
}

static void BaseException__dtor(void* ud) {
    BaseException* self = (BaseException*)ud;
    c11__foreach(BaseExceptionFrame, &self->stacktrace, it) {
        PK_DECREF(it->src);
        if(it->name) c11_string__delete(it->name);
    }
    c11_vector__dtor(&self->stacktrace);
}

static bool _py_BaseException__new__(int argc, py_Ref argv) {
    py_Type cls = py_totype(argv);
    BaseException* ud = py_newobject(py_retval(), cls, 2, sizeof(BaseException));
    c11_vector__ctor(&ud->stacktrace, sizeof(BaseExceptionFrame));
    return true;
}

static bool _py_BaseException__init__(int argc, py_Ref argv) {
    py_newnone(py_retval());
    if(argc == 1 + 0) return true;
    if(argc == 1 + 1) {
        py_setslot(py_arg(0), 0, py_arg(1));
        return true;
    }
    return TypeError("__init__() takes at most 1 arguments but %d were given", argc - 1);
}

static bool _py_BaseException__repr__(int argc, py_Ref argv) {
    c11_sbuf ss;
    c11_sbuf__ctor(&ss);
    pk_sprintf(&ss, "%t(", argv->type);
    py_Ref arg = py_getslot(argv, 0);
    if(!py_isnil(arg)) {
        if(!py_repr(arg)) return false;
        c11_sbuf__write_sv(&ss, py_tosv(py_retval()));
    }
    c11_sbuf__write_char(&ss, ')');
    c11_sbuf__py_submit(&ss, py_retval());
    return true;
}

static bool _py_BaseException__str__(int argc, py_Ref argv) {
    c11_sbuf ss;
    c11_sbuf__ctor(&ss);
    py_Ref arg = py_getslot(argv, 0);
    if(!py_isnil(arg)) {
        if(argv->type == tp_KeyError) {
            if(!py_repr(arg)) return false;
        } else {
            if(!py_str(arg)) return false;
        }
        c11_sbuf__write_sv(&ss, py_tosv(py_retval()));
    }
    c11_sbuf__py_submit(&ss, py_retval());
    return true;
}

static bool BaseException_args(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref arg = py_getslot(argv, 0);
    if(!py_isnil(arg)) {
        py_Ref p = py_newtuple(py_retval(), 1);
        p[0] = *arg;
    } else {
        py_newtuple(py_retval(), 0);
    }
    return true;
}

static bool StopIteration_value(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref arg = py_getslot(argv, 0);
    if(py_isnil(arg)) {
        py_newnone(py_retval());
    } else {
        py_assign(py_retval(), arg);
    }
    return true;
}

py_Type pk_BaseException__register() {
    py_Type type = pk_newtype("BaseException", tp_object, NULL, BaseException__dtor, false, false);

    py_bindmagic(type, __new__, _py_BaseException__new__);
    py_bindmagic(type, __init__, _py_BaseException__init__);
    py_bindmagic(type, __repr__, _py_BaseException__repr__);
    py_bindmagic(type, __str__, _py_BaseException__str__);
    py_bindproperty(type, "args", BaseException_args, NULL);
    return type;
}

py_Type pk_Exception__register() {
    py_Type type = pk_newtype("Exception", tp_BaseException, NULL, NULL, false, false);
    return type;
}

py_Type pk_StopIteration__register() {
    py_Type type = pk_newtype("StopIteration", tp_Exception, NULL, NULL, false, false);
    py_bindproperty(type, "value", StopIteration_value, NULL);
    return type;
}

//////////////////////////////////////////////////
bool py_checkexc(bool ignore_handled) {
    VM* vm = pk_current_vm;
    if(ignore_handled && vm->is_curr_exc_handled) return false;
    return !py_isnil(&vm->curr_exception);
}

bool py_matchexc(py_Type type) {
    VM* vm = pk_current_vm;
    if(vm->is_curr_exc_handled) return false;
    if(py_isnil(&vm->curr_exception)) return false;
    bool ok = py_issubclass(vm->curr_exception.type, type);
    if(ok) {
        // if match, then the exception is handled
        vm->is_curr_exc_handled = true;
        vm->last_retval = vm->curr_exception;
    }
    return ok;
}

void py_clearexc(py_StackRef p0) {
    VM* vm = pk_current_vm;
    vm->curr_exception = *py_NIL();
    vm->is_curr_exc_handled = false;
    /* Don't clear this, because StopIteration() may corrupt the class definition */
    // vm->curr_class = NULL;
    vm->curr_decl_based_function = NULL;
    if(p0) vm->stack.sp = p0;
}

void py_printexc() {
    char* msg = py_formatexc();
    if(!msg) return;
    pk_current_vm->callbacks.print(msg);
    pk_current_vm->callbacks.print("\n");
    PK_FREE(msg);
}

static void c11_sbuf__write_exc(c11_sbuf* self, py_Ref exc) {
    if(true) { c11_sbuf__write_cstr(self, "Traceback (most recent call last):\n"); }

    BaseException* ud = py_touserdata(exc);

    for(int i = ud->stacktrace.length - 1; i >= 0; i--) {
        BaseExceptionFrame* frame = c11__at(BaseExceptionFrame, &ud->stacktrace, i);
        SourceData__snapshot(frame->src,
                             self,
                             frame->lineno,
                             NULL,
                             frame->name ? frame->name->data : NULL);
        c11_sbuf__write_char(self, '\n');
    }

    const char* name = py_tpname(exc->type);
    const char* message;
    bool ok = py_str(exc);
    if(!ok || !py_isstr(py_retval())) {
        message = "<exception str() failed>";
    } else {
        message = py_tostr(py_retval());
    }

    c11_sbuf__write_cstr(self, name);
    c11_sbuf__write_cstr(self, ": ");
    c11_sbuf__write_cstr(self, message);
}

char* py_formatexc() {
    VM* vm = pk_current_vm;
    if(py_isnil(&vm->curr_exception)) return NULL;

    // when you call `py_formatexc()`, you are handling the exception
    vm->is_curr_exc_handled = true;

    c11_sbuf ss;
    c11_sbuf__ctor(&ss);

    py_Ref inner = py_getslot(&vm->curr_exception, 1);
    if(py_isnil(inner)) {
        c11_sbuf__write_exc(&ss, &vm->curr_exception);
    } else {
        c11_sbuf__write_exc(&ss, inner);
        c11_sbuf__write_cstr(
            &ss,
            "\n\nDuring handling of the above exception, another exception occurred:\n\n");
        c11_sbuf__write_exc(&ss, &vm->curr_exception);
    }

    c11_string* res = c11_sbuf__submit(&ss);
    char* dup = PK_MALLOC(res->size + 1);
    memcpy(dup, res->data, res->size);
    dup[res->size] = '\0';
    c11_string__delete(res);
    return dup;
}

bool py_exception(py_Type type, const char* fmt, ...) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    va_list args;
    va_start(args, fmt);
    pk_vsprintf(&buf, fmt, args);
    va_end(args);

    py_Ref message = py_pushtmp();
    c11_sbuf__py_submit(&buf, message);

    bool ok = py_tpcall(type, 1, message);
    if(!ok) return false;
    py_pop();

    return py_raise(py_retval());
}

bool py_raise(py_Ref exc) {
    assert(py_isinstance(exc, tp_BaseException));
    VM* vm = pk_current_vm;
    if(!py_isnil(&vm->curr_exception)) {
        // inner exception
        py_setslot(exc, 1, &vm->curr_exception);
    }
    vm->curr_exception = *exc;
    vm->is_curr_exc_handled = false;
    
    if(vm->trace_info.func && !py_istype(exc, tp_StopIteration)) {
        py_Frame* frame = vm->top_frame;
        vm->trace_info.func(frame, TRACE_EVENT_EXCEPTION);
    }
    return false;
}

bool KeyError(py_Ref key) {
    bool ok = py_tpcall(tp_KeyError, 1, key);
    if(!ok) return false;
    return py_raise(py_retval());
}
// src/public/py_number.c
#include <math.h>

static bool try_castfloat(py_Ref self, double* out) {
    switch(self->type) {
        case tp_int: *out = (double)self->_i64; return true;
        case tp_float: *out = self->_f64; return true;
        default: return false;
    }
}

#define DEF_NUM_BINARY_OP(name, op, rint, rfloat)                                                  \
    static bool int##name(int argc, py_Ref argv) {                                                 \
        PY_CHECK_ARGC(2);                                                                          \
        if(py_isint(&argv[1])) {                                                                   \
            py_i64 lhs = py_toint(&argv[0]);                                                       \
            py_i64 rhs = py_toint(&argv[1]);                                                       \
            rint(py_retval(), lhs op rhs);                                                         \
        } else if(py_isfloat(&argv[1])) {                                                          \
            py_i64 lhs = py_toint(&argv[0]);                                                       \
            py_f64 rhs = py_tofloat(&argv[1]);                                                     \
            rfloat(py_retval(), lhs op rhs);                                                       \
        } else {                                                                                   \
            py_newnotimplemented(py_retval());                                                     \
        }                                                                                          \
        return true;                                                                               \
    }                                                                                              \
    static bool float##name(int argc, py_Ref argv) {                                               \
        PY_CHECK_ARGC(2);                                                                          \
        py_f64 lhs = py_tofloat(&argv[0]);                                                         \
        py_f64 rhs;                                                                                \
        if(try_castfloat(&argv[1], &rhs)) {                                                        \
            rfloat(py_retval(), lhs op rhs);                                                       \
        } else {                                                                                   \
            py_newnotimplemented(py_retval());                                                     \
        }                                                                                          \
        return true;                                                                               \
    }

DEF_NUM_BINARY_OP(__add__, +, py_newint, py_newfloat)
DEF_NUM_BINARY_OP(__sub__, -, py_newint, py_newfloat)
DEF_NUM_BINARY_OP(__mul__, *, py_newint, py_newfloat)

DEF_NUM_BINARY_OP(__eq__, ==, py_newbool, py_newbool)
DEF_NUM_BINARY_OP(__ne__, !=, py_newbool, py_newbool)
DEF_NUM_BINARY_OP(__lt__, <, py_newbool, py_newbool)
DEF_NUM_BINARY_OP(__le__, <=, py_newbool, py_newbool)
DEF_NUM_BINARY_OP(__gt__, >, py_newbool, py_newbool)
DEF_NUM_BINARY_OP(__ge__, >=, py_newbool, py_newbool)

static bool int__neg__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 val = py_toint(&argv[0]);
    py_newint(py_retval(), -val);
    return true;
}

static bool float__neg__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_f64 val = py_tofloat(&argv[0]);
    py_newfloat(py_retval(), -val);
    return true;
}

static bool int__truediv__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_i64 lhs = py_toint(&argv[0]);
    py_f64 rhs;
    if(try_castfloat(&argv[1], &rhs)) {
        py_newfloat(py_retval(), lhs / rhs);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool float__truediv__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_f64 lhs = py_tofloat(&argv[0]);
    py_f64 rhs;
    if(try_castfloat(&argv[1], &rhs)) {
        py_newfloat(py_retval(), lhs / rhs);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool number__pow__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(py_isint(&argv[0]) && py_isint(&argv[1])) {
        py_i64 lhs = py_toint(&argv[0]);
        py_i64 rhs = py_toint(&argv[1]);
        if(rhs < 0) {
            if(lhs == 0) {
                return ZeroDivisionError("0.0 cannot be raised to a negative power");
            } else {
                py_newfloat(py_retval(), pow(lhs, rhs));
            }
        } else {
            // rhs >= 0
            py_i64 ret = 1;
            while(true) {
                if(rhs & 1) ret *= lhs;
                rhs >>= 1;
                if(!rhs) break;
                lhs *= lhs;  // place this here to avoid overflow
            }
            py_newint(py_retval(), ret);
        }
    } else {
        py_f64 lhs, rhs;
        if(!py_castfloat(&argv[0], &lhs)) return false;
        if(try_castfloat(&argv[1], &rhs)) {
            py_newfloat(py_retval(), pow(lhs, rhs));
        } else {
            py_newnotimplemented(py_retval());
        }
    }
    return true;
}

static py_i64 i64_abs(py_i64 x) { return x < 0 ? -x : x; }

static py_i64 cpy11__fast_floor_div(py_i64 a, py_i64 b) {
    assert(b != 0);
    if(a == 0) return 0;
    if((a < 0) == (b < 0)) {
        return i64_abs(a) / i64_abs(b);
    } else {
        return -1 - (i64_abs(a) - 1) / i64_abs(b);
    }
}

static py_i64 cpy11__fast_mod(py_i64 a, py_i64 b) {
    assert(b != 0);
    if(a == 0) return 0;
    py_i64 res;
    if((a < 0) == (b < 0)) {
        res = i64_abs(a) % i64_abs(b);
    } else {
        res = i64_abs(b) - 1 - (i64_abs(a) - 1) % i64_abs(b);
    }
    return b < 0 ? -res : res;
}

static bool int__floordiv__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_i64 lhs = py_toint(&argv[0]);
    if(py_isint(&argv[1])) {
        py_i64 rhs = py_toint(&argv[1]);
        if(rhs == 0) return ZeroDivisionError("integer division by zero");
        py_newint(py_retval(), cpy11__fast_floor_div(lhs, rhs));
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool int__mod__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_i64 lhs = py_toint(&argv[0]);
    if(py_isint(&argv[1])) {
        py_i64 rhs = py_toint(&argv[1]);
        if(rhs == 0) return ZeroDivisionError("integer modulo by zero");
        py_newint(py_retval(), cpy11__fast_mod(lhs, rhs));
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool int__divmod__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_int);
    py_i64 lhs = py_toint(&argv[0]);
    py_i64 rhs = py_toint(&argv[1]);
    if(rhs == 0) return ZeroDivisionError("integer division or modulo by zero");
    py_Ref p = py_newtuple(py_retval(), 2);
    py_newint(&p[0], cpy11__fast_floor_div(lhs, rhs));
    py_newint(&p[1], cpy11__fast_mod(lhs, rhs));
    return true;
}

static bool int__invert__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 val = py_toint(&argv[0]);
    py_newint(py_retval(), ~val);
    return true;
}

static bool int_bit_length(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 x = py_toint(py_arg(0));
    if(x < 0) x = -x;
    int bits = 0;
    while(x) {
        x >>= 1;
        bits++;
    }
    py_newint(py_retval(), bits);
    return true;
}

#define DEF_INT_BITWISE_OP(name, op)                                                               \
    static bool int##name(int argc, py_Ref argv) {                                                 \
        PY_CHECK_ARGC(2);                                                                          \
        py_i64 lhs = py_toint(&argv[0]);                                                           \
        if(py_isint(&argv[1])) {                                                                   \
            py_i64 rhs = py_toint(&argv[1]);                                                       \
            py_newint(py_retval(), lhs op rhs);                                                    \
        } else {                                                                                   \
            py_newnotimplemented(py_retval());                                                     \
        }                                                                                          \
        return true;                                                                               \
    }

DEF_INT_BITWISE_OP(__and__, &)
DEF_INT_BITWISE_OP(__or__, |)
DEF_INT_BITWISE_OP(__xor__, ^)
DEF_INT_BITWISE_OP(__lshift__, <<)
DEF_INT_BITWISE_OP(__rshift__, >>)

static bool int__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 val = py_toint(&argv[0]);
    char buf[32];
    int size = snprintf(buf, sizeof(buf), "%lld", (long long)val);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

static bool float__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_f64 val = py_tofloat(&argv[0]);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_f64(&buf, val, -1);
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

union c11_8bytes {
    py_i64 _i64;
    py_f64 _f64;

    union {
        uint32_t upper;
        uint32_t lower;
    } bits;
};

static py_i64 c11_8bytes__hash(union c11_8bytes u) {
    // https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
    const uint32_t C = 2654435761;
    u.bits.upper *= C;
    u.bits.lower *= C;
    return u._i64;
}

static bool int__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_assign(py_retval(), argv);
    return true;
}

static bool float__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_f64 val = py_tofloat(&argv[0]);
    union c11_8bytes u = {._f64 = val};
    py_newint(py_retval(), c11_8bytes__hash(u));
    return true;
}

static bool int__abs__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_i64 val = py_toint(&argv[0]);
    py_newint(py_retval(), val < 0 ? -val : val);
    return true;
}

static bool float__abs__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_f64 val = py_tofloat(&argv[0]);
    py_newfloat(py_retval(), val < 0 ? -val : val);
    return true;
}

static bool int__new__(int argc, py_Ref argv) {
    if(argc == 1 + 0) {
        // int() == 0
        py_newint(py_retval(), 0);
        return true;
    }
    // 1 arg
    if(argc == 1 + 1) {
        switch(argv[1].type) {
            case tp_float: {
                // int(1.1) == 1
                py_newint(py_retval(), (py_i64)py_tofloat(&argv[1]));
                return true;
            }
            case tp_int: {
                // int(1) == 1
                *py_retval() = argv[1];
                return true;
            }
            case tp_bool: {
                // int(True) == 1
                py_newint(py_retval(), (py_i64)py_tobool(&argv[1]));
                return true;
            }
            case tp_str: break;  // leave to the next block
            default: return TypeError("int() argument must be a string, number or boolean");
        }
    }
    // 2+ args -> error
    if(argc > 1 + 2) return TypeError("int() takes at most 2 arguments");
    // 1 or 2 args with str
    int base = 10;
    if(argc == 1 + 2) {
        PY_CHECK_ARG_TYPE(2, tp_int);
        base = py_toint(py_arg(2));
    }

    PY_CHECK_ARG_TYPE(1, tp_str);

    c11_sv sv = py_tosv(py_arg(1));
    bool negative = false;
    if(sv.size && (sv.data[0] == '+' || sv.data[0] == '-')) {
        negative = sv.data[0] == '-';
        sv.data++;
        sv.size--;
    }
    py_i64 val;
    if(c11__parse_uint(sv, &val, base) != IntParsing_SUCCESS) {
        return ValueError("invalid literal for int() with base %d: %q", base, sv);
    }
    py_newint(py_retval(), negative ? -val : val);
    return true;
}

static bool float__new__(int argc, py_Ref argv) {
    if(argc == 1 + 0) {
        // float() == 0.0
        py_newfloat(py_retval(), 0.0);
        return true;
    }
    if(argc > 1 + 1) return TypeError("float() takes at most 1 argument");
    // 1 arg
    switch(argv[1].type) {
        case tp_int: {
            // float(1) == 1.0
            py_newfloat(py_retval(), py_toint(&argv[1]));
            return true;
        }
        case tp_float: {
            // float(1.1) == 1.1
            *py_retval() = argv[1];
            return true;
        }
        case tp_bool: {
            // float(True) == 1.0
            py_newfloat(py_retval(), py_tobool(&argv[1]));
            return true;
        }
        case tp_str: {
            // str to float
            c11_sv sv = py_tosv(py_arg(1));

            if(c11__sveq2(sv, "inf")) {
                py_newfloat(py_retval(), INFINITY);
                return true;
            }
            if(c11__sveq2(sv, "-inf")) {
                py_newfloat(py_retval(), -INFINITY);
                return true;
            }

            char* p_end;
            py_f64 float_out = strtod(sv.data, &p_end);
            if(p_end != sv.data + sv.size) return ValueError("invalid literal for float(): %q", sv);
            py_newfloat(py_retval(), float_out);
            return true;
        }
        default: return TypeError("float() argument must be a string or a real number");
    }
}

// tp_bool
static bool bool__new__(int argc, py_Ref argv) {
    assert(argc > 0);
    if(argc == 1) {
        py_newbool(py_retval(), false);
        return true;
    }
    if(argc == 2) {
        int res = py_bool(py_arg(1));
        if(res == -1) return false;
        py_newbool(py_retval(), res);
        return true;
    }
    return TypeError("bool() takes at most 1 argument");
}

static bool bool__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    bool res = py_tobool(argv);
    py_newint(py_retval(), res);
    return true;
}

static bool bool__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    bool res = py_tobool(argv);
    py_newstr(py_retval(), res ? "True" : "False");
    return true;
}

static bool bool__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    bool lhs = py_tobool(&argv[0]);
    if(argv[1].type == tp_bool) {
        bool rhs = py_tobool(&argv[1]);
        py_newbool(py_retval(), lhs == rhs);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool bool__ne__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    bool lhs = py_tobool(&argv[0]);
    if(argv[1].type == tp_bool) {
        bool rhs = py_tobool(&argv[1]);
        py_newbool(py_retval(), lhs != rhs);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

#define DEF_BOOL_BITWISE(name, op)                                                                 \
    static bool bool##name(int argc, py_Ref argv) {                                                \
        PY_CHECK_ARGC(2);                                                                          \
        bool lhs = py_tobool(&argv[0]);                                                            \
        if(argv[1].type == tp_bool) {                                                              \
            bool rhs = py_tobool(&argv[1]);                                                        \
            py_newbool(py_retval(), lhs op rhs);                                                   \
        } else {                                                                                   \
            py_newnotimplemented(py_retval());                                                     \
        }                                                                                          \
        return true;                                                                               \
    }

DEF_BOOL_BITWISE(__and__, &&)
DEF_BOOL_BITWISE(__or__, ||)
DEF_BOOL_BITWISE(__xor__, !=)

static bool bool__invert__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    bool val = py_tobool(&argv[0]);
    py_newbool(py_retval(), !val);
    return true;
}

void pk_number__register() {
    /****** tp_int & tp_float ******/
    py_bindmagic(tp_int, __add__, int__add__);
    py_bindmagic(tp_float, __add__, float__add__);
    py_bindmagic(tp_int, __sub__, int__sub__);
    py_bindmagic(tp_float, __sub__, float__sub__);
    py_bindmagic(tp_int, __mul__, int__mul__);
    py_bindmagic(tp_float, __mul__, float__mul__);

    py_bindmagic(tp_int, __eq__, int__eq__);
    py_bindmagic(tp_float, __eq__, float__eq__);
    py_bindmagic(tp_int, __ne__, int__ne__);
    py_bindmagic(tp_float, __ne__, float__ne__);
    py_bindmagic(tp_int, __lt__, int__lt__);
    py_bindmagic(tp_float, __lt__, float__lt__);
    py_bindmagic(tp_int, __le__, int__le__);
    py_bindmagic(tp_float, __le__, float__le__);
    py_bindmagic(tp_int, __gt__, int__gt__);
    py_bindmagic(tp_float, __gt__, float__gt__);
    py_bindmagic(tp_int, __ge__, int__ge__);
    py_bindmagic(tp_float, __ge__, float__ge__);

    // __neg__
    py_bindmagic(tp_int, __neg__, int__neg__);
    py_bindmagic(tp_float, __neg__, float__neg__);

    // __repr__
    py_bindmagic(tp_int, __repr__, int__repr__);
    py_bindmagic(tp_float, __repr__, float__repr__);

    // __hash__
    py_bindmagic(tp_int, __hash__, int__hash__);
    py_bindmagic(tp_float, __hash__, float__hash__);

    // __abs__
    py_bindmagic(tp_int, __abs__, int__abs__);
    py_bindmagic(tp_float, __abs__, float__abs__);

    // __new__
    py_bindmagic(tp_int, __new__, int__new__);
    py_bindmagic(tp_float, __new__, float__new__);

    // __truediv__
    py_bindmagic(tp_int, __truediv__, int__truediv__);
    py_bindmagic(tp_float, __truediv__, float__truediv__);

    // __pow__
    py_bindmagic(tp_int, __pow__, number__pow__);
    py_bindmagic(tp_float, __pow__, number__pow__);

    // __floordiv__ & __mod__ & __divmod__
    py_bindmagic(tp_int, __floordiv__, int__floordiv__);
    py_bindmagic(tp_int, __mod__, int__mod__);
    py_bindmagic(tp_int, __divmod__, int__divmod__);

    // int.__invert__ & int.<BITWISE OP>
    py_bindmagic(tp_int, __invert__, int__invert__);

    py_bindmagic(tp_int, __and__, int__and__);
    py_bindmagic(tp_int, __or__, int__or__);
    py_bindmagic(tp_int, __xor__, int__xor__);
    py_bindmagic(tp_int, __lshift__, int__lshift__);
    py_bindmagic(tp_int, __rshift__, int__rshift__);

    // int.bit_length
    py_bindmethod(tp_int, "bit_length", int_bit_length);

    /* tp_bool */
    py_bindmagic(tp_bool, __new__, bool__new__);
    py_bindmagic(tp_bool, __hash__, bool__hash__);
    py_bindmagic(tp_bool, __repr__, bool__repr__);
    py_bindmagic(tp_bool, __eq__, bool__eq__);
    py_bindmagic(tp_bool, __ne__, bool__ne__);
    py_bindmagic(tp_bool, __and__, bool__and__);
    py_bindmagic(tp_bool, __or__, bool__or__);
    py_bindmagic(tp_bool, __xor__, bool__xor__);
    py_bindmagic(tp_bool, __invert__, bool__invert__);
}

#undef DEF_NUM_BINARY_OP
#undef DEF_INT_BITWISE_OP
#undef DEF_BOOL_BITWISE
// src/public/py_object.c
bool pk__object_new(int argc, py_Ref argv) {
    if(argc == 0) return TypeError("object.__new__(): not enough arguments");
    py_Type cls = py_totype(py_arg(0));
    py_TypeInfo* ti = pk__type_info(cls);
    if(!ti->is_python) {
        return TypeError("object.__new__(%t) is not safe, use %t.__new__() instead", cls, cls);
    }
    py_newobject(py_retval(), cls, -1, 0);
    return true;
}

static bool object__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    assert(argv->is_ptr);
    py_newint(py_retval(), (intptr_t)argv->_obj);
    return true;
}

static bool object__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    bool res = py_isidentical(py_arg(0), py_arg(1));
    py_newbool(py_retval(), res);
    return true;
}

static bool object__ne__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    bool res = py_isidentical(py_arg(0), py_arg(1));
    py_newbool(py_retval(), !res);
    return true;
}

static bool object__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    assert(argv->is_ptr);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    pk_sprintf(&buf, "<%t object at %p>", argv->type, argv->_obj);
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool object__dict__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    if(argv->is_ptr && argv->_obj->slots == -1) {
        pk_mappingproxy__namedict(py_retval(), argv);
    } else {
        py_newnone(py_retval());
    }
    return true;
}

static bool type__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    pk_sprintf(&buf, "<class '%t'>", py_totype(argv));
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool type__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_Type type = py_typeof(py_arg(1));
    py_assign(py_retval(), py_tpobject(type));
    return true;
}

static bool type__base__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_TypeInfo* ti = pk__type_info(py_totype(argv));
    if(ti->base) {
        py_assign(py_retval(), &ti->base_ti->self);
    } else {
        py_newnone(py_retval());
    }
    return true;
}

static bool type__name__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_TypeInfo* ti = pk__type_info(py_totype(argv));
    py_assign(py_retval(), py_name2ref(ti->name));
    return true;
}

static bool type__getitem__(int argc, py_Ref argv) {
    py_assign(py_retval(), argv);
    return true;
}

static bool type__or__(int argc, py_Ref argv) {
    py_assign(py_retval(), argv);
    return true;
}

static bool type__module__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_TypeInfo* ti = pk__type_info(py_totype(argv));
    if(py_isnil(&ti->module)) {
        py_newnone(py_retval());
    } else {
        py_Ref path = py_getdict(&ti->module, __path__);
        py_assign(py_retval(), path);
    }
    return true;
}

static bool type__annotations__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_TypeInfo* ti = pk__type_info(py_totype(argv));
    if(py_isnil(&ti->annotations)) {
        py_newdict(py_retval());
    } else {
        py_assign(py_retval(), &ti->annotations);
    }
    return true;
}

void pk_object__register() {
    py_bindmagic(tp_object, __new__, pk__object_new);

    py_bindmagic(tp_object, __hash__, object__hash__);
    py_bindmagic(tp_object, __eq__, object__eq__);
    py_bindmagic(tp_object, __ne__, object__ne__);
    py_bindmagic(tp_object, __repr__, object__repr__);

    py_bindmagic(tp_type, __repr__, type__repr__);
    py_bindmagic(tp_type, __new__, type__new__);
    py_bindmagic(tp_type, __getitem__, type__getitem__);
    py_bindmagic(tp_type, __or__, type__or__);
    py_bindproperty(tp_type, "__module__", type__module__, NULL);

    py_bindproperty(tp_type, "__base__", type__base__, NULL);
    py_bindproperty(tp_type, "__name__", type__name__, NULL);
    py_bindproperty(tp_object, "__dict__", object__dict__, NULL);
    py_bindproperty(tp_type, "__annotations__", type__annotations__, NULL);
}
// src/public/py_ops.c
bool py_isidentical(py_Ref lhs, py_Ref rhs) {
    if(lhs->type != rhs->type) return false;
    switch(lhs->type) {
        case tp_int: return lhs->_i64 == rhs->_i64;
        case tp_float: return lhs->_f64 == rhs->_f64;
        case tp_bool: return lhs->_bool == rhs->_bool;
        case tp_nativefunc: return lhs->_cfunc == rhs->_cfunc;
        case tp_NoneType: return true;
        case tp_NotImplementedType: return true;
        case tp_ellipsis: return true;
        // fallback to pointer comparison
        default: return lhs->is_ptr && rhs->is_ptr && lhs->_obj == rhs->_obj;
    }
}

int py_bool(py_Ref val) {
    switch(val->type) {
        case tp_bool: return val->_bool;
        case tp_int: return val->_i64 != 0;
        case tp_float: return val->_f64 != 0;
        case tp_NoneType: return 0;
        default: {
            py_Ref tmp = py_tpfindmagic(val->type, __bool__);
            if(tmp) {
                if(!py_call(tmp, 1, val)) return -1;
                if(!py_checkbool(py_retval())) return -1;
                return py_tobool(py_retval());
            } else {
                tmp = py_tpfindmagic(val->type, __len__);
                if(tmp) {
                    if(!py_call(tmp, 1, val)) return -1;
                    if(!py_checkint(py_retval())) return -1;
                    return py_toint(py_retval());
                } else {
                    return 1;  // True
                }
            }
        }
    }
}

bool py_hash(py_Ref val, int64_t* out) {
    py_TypeInfo* ti = pk__type_info(val->type);
    do {
        py_Ref slot_hash = TypeList__magic_common(ti, __hash__);
        if(py_isnone(slot_hash)) break;
        py_Ref slot_eq = TypeList__magic_common(ti, __eq__);
        if(!py_isnil(slot_eq)) {
            if(py_isnil(slot_hash)) break;
            if(!py_call(slot_hash, 1, val)) return false;
            if(!py_checkint(py_retval())) return false;
            *out = py_toint(py_retval());
            return true;
        }
        ti = ti->base_ti;
    } while(ti);
    return TypeError("unhashable type: '%t'", val->type);
}

bool py_iter(py_Ref val) {
    py_Ref tmp = py_tpfindmagic(val->type, __iter__);
    if(!tmp) return TypeError("'%t' object is not iterable", val->type);
    return py_call(tmp, 1, val);
}

int py_next(py_Ref val) {
    VM* vm = pk_current_vm;
    py_Ref tmp = py_tpfindmagic(val->type, __next__);
    if(!tmp) {
        TypeError("'%t' object is not an iterator", val->type);
        return -1;
    }
    if(py_call(tmp, 1, val)) return 1;
    if(vm->curr_exception.type == tp_StopIteration) {
        vm->last_retval = vm->curr_exception;
        py_clearexc(NULL);
        return 0;
    }
    return -1;
}

bool py_getattr(py_Ref self, py_Name name) {
    // https://docs.python.org/3/howto/descriptor.html#invocation-from-an-instance
    py_Type type = self->type;
    py_Ref cls_var = py_tpfindname(type, name);
    if(cls_var) {
        // handle descriptor
        if(py_istype(cls_var, tp_property)) {
            py_Ref getter = py_getslot(cls_var, 0);
            return py_call(getter, 1, self);
        }
    }
    // handle instance __dict__
    if(self->is_ptr && self->_obj->slots == -1) {
        if(!py_istype(self, tp_type)) {
            py_Ref res = py_getdict(self, name);
            if(res) {
                py_assign(py_retval(), res);
                return true;
            }
        } else {
            py_Type* inner_type = py_touserdata(self);
            py_Ref res = py_tpfindname(*inner_type, name);
            if(res) {
                if(py_istype(res, tp_staticmethod)) {
                    res = py_getslot(res, 0);
                } else if(py_istype(res, tp_classmethod)) {
                    res = py_getslot(res, 0);
                    py_newboundmethod(py_retval(), self, res);
                    return true;
                }
                py_assign(py_retval(), res);
                return true;
            }
        }
    }

    if(cls_var) {
        // bound method is non-data descriptor
        switch(cls_var->type) {
            case tp_function: {
                if(name == __new__) goto __STATIC_NEW;
                py_newboundmethod(py_retval(), self, cls_var);
                return true;
            }
            case tp_nativefunc: {
                if(name == __new__) goto __STATIC_NEW;
                py_newboundmethod(py_retval(), self, cls_var);
                return true;
            }
            case tp_staticmethod: {
                py_assign(py_retval(), py_getslot(cls_var, 0));
                return true;
            }
            case tp_classmethod: {
                py_newboundmethod(py_retval(), py_tpobject(type), py_getslot(cls_var, 0));
                return true;
            }
            default: {
            __STATIC_NEW:
                py_assign(py_retval(), cls_var);
                return true;
            }
        }
    }

    py_Ref fallback = py_tpfindmagic(type, __getattr__);
    if(fallback) {
        py_push(fallback);
        py_push(self);
        py_assign(py_pushtmp(), py_name2ref(name));
        return py_vectorcall(1, 0);
    }

    if(self->type == tp_module) {
        py_Ref path = py_getdict(self, __path__);
        c11_sbuf buf;
        c11_sbuf__ctor(&buf);
        pk_sprintf(&buf, "%v.%n", py_tosv(path), name);
        c11_string* new_path = c11_sbuf__submit(&buf);
        int res = py_import(new_path->data);
        c11_string__delete(new_path);
        if(res == -1) {
            return false;
        } else if(res == 1) {
            return true;
        }
    }

    return AttributeError(self, name);
}

bool py_setattr(py_Ref self, py_Name name, py_Ref val) {
    py_Type type = self->type;
    py_Ref cls_var = py_tpfindname(type, name);
    if(cls_var) {
        // handle descriptor
        if(py_istype(cls_var, tp_property)) {
            py_Ref setter = py_getslot(cls_var, 1);
            if(!py_isnone(setter)) {
                py_push(setter);
                py_push(self);
                py_push(val);
                return py_vectorcall(1, 0);
            } else {
                return TypeError("readonly attribute: '%n'", name);
            }
        }
    }

    // handle instance __dict__
    if(self->is_ptr && self->_obj->slots == -1) {
        py_setdict(self, name, val);
        return true;
    }

    return TypeError("cannot set attribute");
}

bool py_delattr(py_Ref self, py_Name name) {
    if(self->is_ptr && self->_obj->slots == -1) {
        if(py_deldict(self, name)) return true;
        return AttributeError(self, name);
    }
    return TypeError("cannot delete attribute");
}

bool py_getitem(py_Ref self, py_Ref key) {
    py_push(self);
    py_push(key);
    bool ok = pk_callmagic(__getitem__, 2, py_peek(-2));
    py_shrink(2);
    return ok;
}

bool py_setitem(py_Ref self, py_Ref key, py_Ref val) {
    py_push(self);
    py_push(key);
    py_push(val);
    bool ok = pk_callmagic(__setitem__, 3, py_peek(-3));
    py_shrink(3);
    return ok;
}

bool py_delitem(py_Ref self, py_Ref key) {
    py_push(self);
    py_push(key);
    bool ok = pk_callmagic(__delitem__, 2, py_peek(-2));
    py_shrink(2);
    return ok;
}

int py_equal(py_Ref lhs, py_Ref rhs) {
    if(py_isidentical(lhs, rhs)) return 1;
    if(!py_eq(lhs, rhs)) return -1;
    return py_bool(py_retval());
}

int py_less(py_Ref lhs, py_Ref rhs) {
    if(!py_lt(lhs, rhs)) return -1;
    return py_bool(py_retval());
}
// src/public/py_str.c
void py_newstr(py_Ref out, const char* data) { py_newstrv(out, (c11_sv){data, strlen(data)}); }

char* py_newstrn(py_Ref out, int size) {
    ManagedHeap* heap = &pk_current_vm->heap;
    int total_size = sizeof(c11_string) + size + 1;
    PyObject* obj = ManagedHeap__gcnew(heap, tp_str, 0, total_size);
    c11_string* ud = PyObject__userdata(obj);
    c11_string__ctor3(ud, size);
    out->type = tp_str;
    out->is_ptr = true;
    out->_obj = obj;
    return ud->data;
}

void py_newstrv(py_OutRef out, c11_sv sv) {
    if(sv.size == 0) {
        *out = pk_current_vm->ascii_literals[128];
        return;
    }
    if(sv.size == 1) {
        int c = sv.data[0];
        if(c >= 0 && c < 128) {
            *out = pk_current_vm->ascii_literals[c];
            return;
        }
    }
    char* data = py_newstrn(out, sv.size);
    memcpy(data, sv.data, sv.size);
}

void py_newfstr(py_OutRef out, const char* fmt, ...) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    va_list args;
    va_start(args, fmt);
    pk_vsprintf(&buf, fmt, args);
    va_end(args);
    c11_sbuf__py_submit(&buf, out);
}

unsigned char* py_newbytes(py_Ref out, int size) {
    ManagedHeap* heap = &pk_current_vm->heap;
    // 4 bytes size + data
    PyObject* obj = ManagedHeap__gcnew(heap, tp_bytes, 0, sizeof(c11_bytes) + size);
    c11_bytes* ud = PyObject__userdata(obj);
    ud->size = size;
    out->type = tp_bytes;
    out->is_ptr = true;
    out->_obj = obj;
    return ud->data;
}

const char* py_tostr(py_Ref self) {
    assert(self->type == tp_str);
    c11_string* ud = PyObject__userdata(self->_obj);
    return ud->data;
}

const char* py_tostrn(py_Ref self, int* size) {
    assert(self->type == tp_str);
    c11_string* ud = PyObject__userdata(self->_obj);
    *size = ud->size;
    return ud->data;
}

c11_sv py_tosv(py_Ref self) {
    assert(self->type == tp_str);
    c11_string* ud = PyObject__userdata(self->_obj);
    return c11_string__sv(ud);
}

unsigned char* py_tobytes(py_Ref self, int* size) {
    assert(self->type == tp_bytes);
    c11_bytes* ud = PyObject__userdata(self->_obj);
    *size = ud->size;
    return ud->data;
}

void py_bytes_resize(py_Ref self, int size) {
    assert(self->type == tp_bytes);
    c11_bytes* ud = PyObject__userdata(self->_obj);
    if(size > ud->size) c11__abort("bytes can only be resized down: %d > %d", ud->size, size);
    ud->size = size;
}

////////////////////////////////
static bool str__new__(int argc, py_Ref argv) {
    assert(argc >= 1);
    if(argc == 1) {
        py_newstr(py_retval(), "");
        return true;
    }
    if(argc > 2) return TypeError("str() takes at most 1 argument");
    return py_str(py_arg(1));
}

static bool str__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int size;
    const char* data = py_tostrn(&argv[0], &size);
    uint64_t res = 0;
    for(int i = 0; i < size; i++) {
        res = res * 31 + data[i];
    }
    py_newint(py_retval(), res);
    return true;
}

static bool str__len__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_string* self = py_touserdata(&argv[0]);
    py_newint(py_retval(), c11_sv__u8_length((c11_sv){self->data, self->size}));
    return true;
}

static bool str__add__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    if(py_arg(1)->type != tp_str) {
        py_newnotimplemented(py_retval());
    } else {
        c11_string* other = py_touserdata(&argv[1]);
        int total_size = sizeof(c11_string) + self->size + other->size + 1;
        c11_string* res = py_newobject(py_retval(), tp_str, 0, total_size);
        res->size = self->size + other->size;
        char* p = res->data;
        memcpy(p, self->data, self->size);
        memcpy(p + self->size, other->data, other->size);
        p[res->size] = '\0';
    }
    return true;
}

static bool str__mul__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    if(py_arg(1)->type != tp_int) {
        py_newnotimplemented(py_retval());
    } else {
        py_i64 n = py_toint(py_arg(1));
        if(n <= 0) {
            py_newstr(py_retval(), "");
        } else {
            int total_size = sizeof(c11_string) + self->size * n + 1;
            c11_string* res = py_newobject(py_retval(), tp_str, 0, total_size);
            res->size = self->size * n;
            char* p = res->data;
            for(int i = 0; i < n; i++) {
                memcpy(p + i * self->size, self->data, self->size);
            }
            p[res->size] = '\0';
        }
    }
    return true;
}

static bool str__rmul__(int argc, py_Ref argv) { return str__mul__(argc, argv); }

static bool str__contains__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    if(py_arg(1)->type != tp_str) {
        py_newnotimplemented(py_retval());
    } else {
        c11_string* other = py_touserdata(&argv[1]);
        const char* p = strstr(self->data, other->data);
        py_newbool(py_retval(), p != NULL);
    }
    return true;
}

static bool str__str__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    *py_retval() = argv[0];
    return true;
}

static bool str__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_quoted(&buf, py_tosv(&argv[0]), '\'');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool str__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int* ud = py_newobject(py_retval(), tp_str_iterator, 1, sizeof(int));
    *ud = 0;
    py_setslot(py_retval(), 0, argv);  // keep a reference to the string
    return true;
}

static bool str__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_sv self = c11_string__sv(py_touserdata(&argv[0]));
    py_Ref _1 = py_arg(1);
    if(_1->type == tp_int) {
        int index = py_toint(py_arg(1));
        if(!pk__normalize_index(&index, self.size)) return false;
        c11_sv res = c11_sv__u8_getitem(self, index);
        py_newstrv(py_retval(), res);
        return true;
    } else if(_1->type == tp_slice) {
        int start, stop, step;
        bool ok = pk__parse_int_slice(_1, c11_sv__u8_length(self), &start, &stop, &step);
        if(!ok) return false;
        c11_string* res = c11_sv__u8_slice(self, start, stop, step);
        py_newstrv(py_retval(), (c11_sv){res->data, res->size});
        c11_string__delete(res);
        return true;
    } else {
        return TypeError("string indices must be integers");
    }
}

#define DEF_STR_CMP_OP(op, __f, __cond)                                                            \
    static bool str##op(int argc, py_Ref argv) {                                                   \
        PY_CHECK_ARGC(2);                                                                          \
        c11_string* self = py_touserdata(&argv[0]);                                                \
        if(py_arg(1)->type != tp_str) {                                                            \
            py_newnotimplemented(py_retval());                                                     \
        } else {                                                                                   \
            c11_string* other = py_touserdata(&argv[1]);                                           \
            int res = __f(c11_string__sv(self), c11_string__sv(other));                            \
            py_newbool(py_retval(), __cond);                                                       \
        }                                                                                          \
        return true;                                                                               \
    }

DEF_STR_CMP_OP(__eq__, c11__sveq, res)
DEF_STR_CMP_OP(__ne__, c11__sveq, !res)
DEF_STR_CMP_OP(__lt__, c11_sv__cmp, res < 0)
DEF_STR_CMP_OP(__le__, c11_sv__cmp, res <= 0)
DEF_STR_CMP_OP(__gt__, c11_sv__cmp, res > 0)
DEF_STR_CMP_OP(__ge__, c11_sv__cmp, res >= 0)

#undef DEF_STR_CMP_OP

static bool str_lower(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_string* self = py_touserdata(&argv[0]);
    int total_size = sizeof(c11_string) + self->size + 1;
    c11_string* res = py_newobject(py_retval(), tp_str, 0, total_size);
    res->size = self->size;
    char* p = res->data;
    for(int i = 0; i < self->size; i++) {
        char c = self->data[i];
        p[i] = c >= 'A' && c <= 'Z' ? c + 32 : c;
    }
    p[res->size] = '\0';
    return true;
}

static bool str_upper(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_string* self = py_touserdata(&argv[0]);
    int total_size = sizeof(c11_string) + self->size + 1;
    c11_string* res = py_newobject(py_retval(), tp_str, 0, total_size);
    res->size = self->size;
    char* p = res->data;
    for(int i = 0; i < self->size; i++) {
        char c = self->data[i];
        p[i] = c >= 'a' && c <= 'z' ? c - 32 : c;
    }
    p[res->size] = '\0';
    return true;
}

static bool str_startswith(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    PY_CHECK_ARG_TYPE(1, tp_str);
    c11_string* other = py_touserdata(&argv[1]);
    py_newbool(py_retval(), c11_sv__startswith(c11_string__sv(self), c11_string__sv(other)));
    return true;
}

static bool str_endswith(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    PY_CHECK_ARG_TYPE(1, tp_str);
    c11_string* other = py_touserdata(&argv[1]);
    py_newbool(py_retval(), c11_sv__endswith(c11_string__sv(self), c11_string__sv(other)));
    return true;
}

static bool str_join(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_sv self = c11_string__sv(py_touserdata(argv));

    if(!py_iter(py_arg(1))) return false;
    py_push(py_retval());  // iter

    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    bool first = true;
    while(true) {
        int res = py_next(py_peek(-1));
        if(res == -1) {
            c11_sbuf__dtor(&buf);
            return false;
        }

        if(res == 0) break;

        if(!first) c11_sbuf__write_sv(&buf, self);
        if(!py_checkstr(py_retval())) {
            c11_sbuf__dtor(&buf);
            return false;
        }
        c11_string* item = py_touserdata(py_retval());
        c11_sbuf__write_cstrn(&buf, item->data, item->size);
        first = false;
    }

    py_pop();  // iter
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool str_replace(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    c11_string* self = py_touserdata(&argv[0]);
    PY_CHECK_ARG_TYPE(1, tp_str);
    PY_CHECK_ARG_TYPE(2, tp_str);
    c11_string* old = py_touserdata(&argv[1]);
    c11_string* new_ = py_touserdata(&argv[2]);
    c11_string* res =
        c11_sv__replace2(c11_string__sv(self), c11_string__sv(old), c11_string__sv(new_));
    py_newstrv(py_retval(), (c11_sv){res->data, res->size});
    c11_string__delete(res);
    return true;
}

static bool str_split(int argc, py_Ref argv) {
    c11_sv self = c11_string__sv(py_touserdata(&argv[0]));
    c11_vector res;
    bool discard_empty = false;
    if(argc > 2) return TypeError("split() takes at most 2 arguments");
    if(argc == 1) {
        // sep = None
        res = c11_sv__split(self, ' ');
        discard_empty = true;
    }
    if(argc == 2) {
        // sep = argv[1]
        if(!py_checkstr(&argv[1])) return false;
        c11_sv sep = c11_string__sv(py_touserdata(&argv[1]));
        if(sep.size == 0) return ValueError("empty separator");
        res = c11_sv__split2(self, sep);
    }
    py_newlist(py_retval());
    for(int i = 0; i < res.length; i++) {
        c11_sv part = c11__getitem(c11_sv, &res, i);
        if(discard_empty && part.size == 0) continue;
        py_newstrv(py_list_emplace(py_retval()), part);
    }
    c11_vector__dtor(&res);
    return true;
}

static bool str_count(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_string* self = py_touserdata(&argv[0]);
    PY_CHECK_ARG_TYPE(1, tp_str);
    c11_string* sub = py_touserdata(&argv[1]);
    int res = c11_sv__count(c11_string__sv(self), c11_string__sv(sub));
    py_newint(py_retval(), res);
    return true;
}

static bool str__strip_impl(bool left, bool right, int argc, py_Ref argv) {
    c11_sv self = c11_string__sv(py_touserdata(&argv[0]));
    c11_sv chars;
    if(argc == 1) {
        chars = (c11_sv){" \t\n\r", 4};
    } else if(argc == 2) {
        if(!py_checkstr(&argv[1])) return false;
        chars = c11_string__sv(py_touserdata(&argv[1]));
    } else {
        return TypeError("strip() takes at most 2 arguments");
    }
    c11_sv res = c11_sv__strip(self, chars, left, right);
    py_newstrv(py_retval(), res);
    return true;
}

static bool str_strip(int argc, py_Ref argv) { return str__strip_impl(true, true, argc, argv); }

static bool str_lstrip(int argc, py_Ref argv) { return str__strip_impl(true, false, argc, argv); }

static bool str_rstrip(int argc, py_Ref argv) { return str__strip_impl(false, true, argc, argv); }

static bool str_zfill(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_sv self = c11_string__sv(py_touserdata(&argv[0]));
    PY_CHECK_ARG_TYPE(1, tp_int);
    int width = py_toint(py_arg(1));
    int delta = width - c11_sv__u8_length(self);
    if(delta <= 0) {
        *py_retval() = argv[0];
        return true;
    }
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    for(int i = 0; i < delta; i++) {
        c11_sbuf__write_char(&buf, '0');
    }
    c11_sbuf__write_sv(&buf, self);
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool str__widthjust_impl(bool left, int argc, py_Ref argv) {
    if(argc > 1 + 2) return TypeError("expected at most 2 arguments");
    char pad;
    if(argc == 1 + 1) {
        pad = ' ';
    } else {
        if(!py_checkstr(&argv[2])) return false;
        c11_string* padstr = py_touserdata(&argv[2]);
        if(padstr->size != 1)
            return TypeError("The fill character must be exactly one character long");
        pad = padstr->data[0];
    }
    c11_sv self = c11_string__sv(py_touserdata(&argv[0]));
    PY_CHECK_ARG_TYPE(1, tp_int);
    int width = py_toint(py_arg(1));
    if(width <= self.size) {
        *py_retval() = argv[0];
        return true;
    }
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    if(left) {
        c11_sbuf__write_sv(&buf, self);
        for(int i = 0; i < width - self.size; i++) {
            c11_sbuf__write_char(&buf, pad);
        }
    } else {
        for(int i = 0; i < width - self.size; i++) {
            c11_sbuf__write_char(&buf, pad);
        }
        c11_sbuf__write_sv(&buf, self);
    }
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool str_ljust(int argc, py_Ref argv) { return str__widthjust_impl(true, argc, argv); }

static bool str_rjust(int argc, py_Ref argv) { return str__widthjust_impl(false, argc, argv); }

static bool str_find(int argc, py_Ref argv) {
    if(argc > 3) return TypeError("find() takes at most 3 arguments");
    int start = 0;
    if(argc == 3) {
        PY_CHECK_ARG_TYPE(2, tp_int);
        start = py_toint(py_arg(2));
    }
    c11_string* self = py_touserdata(&argv[0]);
    PY_CHECK_ARG_TYPE(1, tp_str);
    c11_string* sub = py_touserdata(&argv[1]);
    int res = c11_sv__index2(c11_string__sv(self), c11_string__sv(sub), start);
    py_newint(py_retval(), res);
    return true;
}

static bool str_index(int argc, py_Ref argv) {
    bool ok = str_find(argc, argv);
    if(!ok) return false;
    if(py_toint(py_retval()) == -1) return ValueError("substring not found");
    return true;
}

static bool str_encode(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int size;
    const char* data = py_tostrn(argv, &size);
    unsigned char* p = py_newbytes(py_retval(), size);
    memcpy(p, data, size);
    return true;
}

py_Type pk_str__register() {
    py_Type type = pk_newtype("str", tp_object, NULL, NULL, false, true);
    // no need to dtor because the memory is controlled by the object

    py_bindmagic(tp_str, __new__, str__new__);
    py_bindmagic(tp_str, __hash__, str__hash__);
    py_bindmagic(tp_str, __len__, str__len__);
    py_bindmagic(tp_str, __add__, str__add__);
    py_bindmagic(tp_str, __mul__, str__mul__);
    py_bindmagic(tp_str, __rmul__, str__rmul__);
    py_bindmagic(tp_str, __contains__, str__contains__);
    py_bindmagic(tp_str, __str__, str__str__);
    py_bindmagic(tp_str, __repr__, str__repr__);
    py_bindmagic(tp_str, __iter__, str__iter__);
    py_bindmagic(tp_str, __getitem__, str__getitem__);

    py_bindmagic(tp_str, __eq__, str__eq__);
    py_bindmagic(tp_str, __ne__, str__ne__);
    py_bindmagic(tp_str, __lt__, str__lt__);
    py_bindmagic(tp_str, __le__, str__le__);
    py_bindmagic(tp_str, __gt__, str__gt__);
    py_bindmagic(tp_str, __ge__, str__ge__);

    py_bindmethod(tp_str, "lower", str_lower);
    py_bindmethod(tp_str, "upper", str_upper);
    py_bindmethod(tp_str, "startswith", str_startswith);
    py_bindmethod(tp_str, "endswith", str_endswith);
    py_bindmethod(tp_str, "join", str_join);
    py_bindmethod(tp_str, "replace", str_replace);
    py_bindmethod(tp_str, "split", str_split);
    py_bindmethod(tp_str, "count", str_count);
    py_bindmethod(tp_str, "strip", str_strip);
    py_bindmethod(tp_str, "lstrip", str_lstrip);
    py_bindmethod(tp_str, "rstrip", str_rstrip);
    py_bindmethod(tp_str, "zfill", str_zfill);
    py_bindmethod(tp_str, "ljust", str_ljust);
    py_bindmethod(tp_str, "rjust", str_rjust);
    py_bindmethod(tp_str, "find", str_find);
    py_bindmethod(tp_str, "index", str_index);
    py_bindmethod(tp_str, "encode", str_encode);
    return type;
}

static bool str_iterator__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int* ud = py_touserdata(&argv[0]);
    int size;
    const char* data = py_tostrn(py_getslot(argv, 0), &size);
    if(*ud == size) return StopIteration();
    int start = *ud;
    int len = c11__u8_header(data[*ud], false);
    *ud += len;
    py_newstrv(py_retval(), (c11_sv){data + start, len});
    return true;
}

py_Type pk_str_iterator__register() {
    py_Type type = pk_newtype("str_iterator", tp_object, NULL, NULL, false, true);

    py_bindmagic(type, __iter__, pk_wrapper__self);
    py_bindmagic(type, __next__, str_iterator__next__);
    return type;
}

static bool bytes__new__(int argc, py_Ref argv) {
    if(argc == 1) {
        py_newbytes(py_retval(), 0);
        return true;
    }
    if(argc > 2) return TypeError("bytes() takes at most 1 argument");
    py_TValue* p;
    int length = pk_arrayview(&argv[1], &p);
    if(length == -1) return TypeError("bytes() argument must be a list or tuple");
    unsigned char* data = py_newbytes(py_retval(), length);
    for(int i = 0; i < length; i++) {
        if(!py_checktype(&p[i], tp_int)) return false;
        py_i64 v = py_toint(&p[i]);
        if(v < 0 || v > 255) return ValueError("bytes must be in range(0, 256)");
        data[i] = v;
    }
    return true;
}

static bool bytes__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_bytes* self = py_touserdata(&argv[0]);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_char(&buf, 'b');
    c11_sbuf__write_quoted(&buf, (c11_sv){(const char*)self->data, self->size}, '\'');
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool bytes__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    int size;
    unsigned char* data = py_tobytes(&argv[0], &size);
    py_Ref _1 = py_arg(1);
    if(_1->type == tp_int) {
        int index = py_toint(_1);
        if(!pk__normalize_index(&index, size)) return false;
        py_newint(py_retval(), data[index]);
        return true;
    } else if(_1->type == tp_slice) {
        int start, stop, step;
        bool ok = pk__parse_int_slice(_1, size, &start, &stop, &step);
        if(!ok) return false;
        c11_vector res;
        c11_vector__ctor(&res, sizeof(unsigned char));
        for(int i = start; step > 0 ? i < stop : i > stop; i += step) {
            c11_vector__push(unsigned char, &res, data[i]);
        }
        unsigned char* p = py_newbytes(py_retval(), res.length);
        memcpy(p, res.data, res.length);
        c11_vector__dtor(&res);
        return true;
    } else {
        return TypeError("bytes indices must be integers");
    }
}

static bool bytes__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_bytes* self = py_touserdata(&argv[0]);
    if(!py_istype(&argv[1], tp_bytes)) {
        py_newnotimplemented(py_retval());
    } else {
        c11_bytes* other = py_touserdata(&argv[1]);
        py_newbool(py_retval(), c11_bytes__eq(self, other));
    }
    return true;
}

static bool bytes__ne__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_bytes* self = py_touserdata(&argv[0]);
    if(!py_istype(&argv[1], tp_bytes)) {
        py_newnotimplemented(py_retval());
    } else {
        c11_bytes* other = py_touserdata(&argv[1]);
        py_newbool(py_retval(), !c11_bytes__eq(self, other));
    }
    return true;
}

static bool bytes__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_bytes* self = py_touserdata(&argv[0]);
    uint64_t res = 0;
    for(int i = 0; i < self->size; i++) {
        res = res * 31 + self->data[i];
    }
    py_newint(py_retval(), res);
    return true;
}

static bool bytes__add__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_bytes* self = py_touserdata(&argv[0]);
    if(py_arg(1)->type != tp_bytes) {
        py_newnotimplemented(py_retval());
    } else {
        c11_bytes* other = py_touserdata(&argv[1]);
        unsigned char* p = py_newbytes(py_retval(), self->size + other->size);
        memcpy(p, self->data, self->size);
        memcpy(p + self->size, other->data, other->size);
    }
    return true;
}

static bool bytes_decode(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int size;
    unsigned char* data = py_tobytes(&argv[0], &size);
    py_newstrv(py_retval(), (c11_sv){(const char*)data, size});
    return true;
}

static bool bytes__len__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_bytes* self = py_touserdata(&argv[0]);
    py_newint(py_retval(), self->size);
    return true;
}

py_Type pk_bytes__register() {
    py_Type type = pk_newtype("bytes", tp_object, NULL, NULL, false, true);
    // no need to dtor because the memory is controlled by the object

    py_bindmagic(tp_bytes, __new__, bytes__new__);
    py_bindmagic(tp_bytes, __repr__, bytes__repr__);
    py_bindmagic(tp_bytes, __getitem__, bytes__getitem__);
    py_bindmagic(tp_bytes, __eq__, bytes__eq__);
    py_bindmagic(tp_bytes, __ne__, bytes__ne__);
    py_bindmagic(tp_bytes, __add__, bytes__add__);
    py_bindmagic(tp_bytes, __hash__, bytes__hash__);
    py_bindmagic(tp_bytes, __len__, bytes__len__);

    py_bindmethod(tp_bytes, "decode", bytes_decode);
    return type;
}

bool py_str(py_Ref val) {
    if(val->type == tp_str) {
        py_assign(py_retval(), val);
        return true;
    }
    py_Ref tmp = py_tpfindmagic(val->type, __str__);
    if(!tmp) return py_repr(val);
    return py_call(tmp, 1, val);
}

bool py_repr(py_Ref val) { return pk_callmagic(__repr__, 1, val); }

bool py_len(py_Ref val) { return pk_callmagic(__len__, 1, val); }

#undef DEF_STR_CMP_OP
// src/modules/json.c
#include <math.h>

static bool json_loads(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    const char* source = py_tostr(argv);
    return py_json_loads(source);
}

static bool json_dumps(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_int);
    int indent = py_toint(&argv[1]);
    return py_json_dumps(argv, indent);
}

void pk__add_module_json() {
    py_Ref mod = py_newmodule("json");

    py_setdict(mod, py_name("null"), py_None());
    py_setdict(mod, py_name("true"), py_True());
    py_setdict(mod, py_name("false"), py_False());
    py_TValue tmp;
    py_newfloat(&tmp, NAN);
    py_setdict(mod, py_name("NaN"), &tmp);
    py_newfloat(&tmp, INFINITY);
    py_setdict(mod, py_name("Infinity"), &tmp);

    py_bindfunc(mod, "loads", json_loads);
    py_bind(mod, "dumps(obj, indent=0)", json_dumps);
}

typedef struct {
    c11_sbuf* buf;
    bool first;
    int indent;
    int depth;
} json__write_dict_kv_ctx;

static bool json__write_object(c11_sbuf* buf, py_TValue* obj, int indent, int depth);

static void json__write_indent(c11_sbuf* buf, int n_spaces) {
    for(int i = 0; i < n_spaces; i++) {
        c11_sbuf__write_char(buf, ' ');
    }
}

static bool json__write_array(c11_sbuf* buf, py_TValue* arr, int length, int indent, int depth) {
    c11_sbuf__write_char(buf, '[');
    if(length == 0) {
        c11_sbuf__write_char(buf, ']');
        return true;
    }
    if(indent > 0) c11_sbuf__write_char(buf, '\n');
    int n_spaces = indent * depth;
    const char* sep = indent > 0 ? ",\n" : ", ";
    for(int i = 0; i < length; i++) {
        if(i != 0) c11_sbuf__write_cstr(buf, sep);
        json__write_indent(buf, n_spaces);
        bool ok = json__write_object(buf, arr + i, indent, depth);
        if(!ok) return false;
    }
    if(indent > 0) {
        c11_sbuf__write_char(buf, '\n');
        json__write_indent(buf, n_spaces - indent);
    }
    c11_sbuf__write_char(buf, ']');
    return true;
}

static bool json__write_dict_kv(py_Ref k, py_Ref v, void* ctx_) {
    json__write_dict_kv_ctx* ctx = ctx_;
    int n_spaces = ctx->indent * ctx->depth;
    const char* sep = ctx->indent > 0 ? ",\n" : ", ";
    if(!ctx->first) c11_sbuf__write_cstr(ctx->buf, sep);
    ctx->first = false;
    if(!py_isstr(k)) return TypeError("keys must be strings");
    json__write_indent(ctx->buf, n_spaces);
    c11_sbuf__write_quoted(ctx->buf, py_tosv(k), '"');
    c11_sbuf__write_cstr(ctx->buf, ": ");
    return json__write_object(ctx->buf, v, ctx->indent, ctx->depth);
}

static bool json__write_namedict_kv(py_Name k, py_Ref v, void* ctx_) {
    json__write_dict_kv_ctx* ctx = ctx_;
    int n_spaces = ctx->indent * ctx->depth;
    const char* sep = ctx->indent > 0 ? ",\n" : ", ";
    if(!ctx->first) c11_sbuf__write_cstr(ctx->buf, sep);
    ctx->first = false;
    json__write_indent(ctx->buf, n_spaces);
    c11_sbuf__write_quoted(ctx->buf, py_name2sv(k), '"');
    c11_sbuf__write_cstr(ctx->buf, ": ");
    return json__write_object(ctx->buf, v, ctx->indent, ctx->depth);
}

static bool json__write_object(c11_sbuf* buf, py_TValue* obj, int indent, int depth) {
    switch(obj->type) {
        case tp_NoneType: c11_sbuf__write_cstr(buf, "null"); return true;
        case tp_int: c11_sbuf__write_int(buf, obj->_i64); return true;
        case tp_float: {
            if(isnan(obj->_f64)) {
                c11_sbuf__write_cstr(buf, "NaN");
            } else if(isinf(obj->_f64)) {
                c11_sbuf__write_cstr(buf, obj->_f64 < 0 ? "-Infinity" : "Infinity");
            } else {
                c11_sbuf__write_f64(buf, obj->_f64, -1);
            }
            return true;
        }
        case tp_bool: {
            c11_sbuf__write_cstr(buf, py_tobool(obj) ? "true" : "false");
            return true;
        }
        case tp_str: {
            c11_sbuf__write_quoted(buf, py_tosv(obj), '"');
            return true;
        }
        case tp_list: {
            return json__write_array(buf, py_list_data(obj), py_list_len(obj), indent, depth + 1);
        }
        case tp_tuple: {
            return json__write_array(buf, py_tuple_data(obj), py_tuple_len(obj), indent, depth + 1);
        }
        case tp_dict: {
            c11_sbuf__write_char(buf, '{');
            if(py_dict_len(obj) == 0) {
                c11_sbuf__write_char(buf, '}');
                return true;
            }
            if(indent > 0) c11_sbuf__write_char(buf, '\n');
            json__write_dict_kv_ctx ctx = {.buf = buf,
                                           .first = true,
                                           .indent = indent,
                                           .depth = depth + 1};
            bool ok = py_dict_apply(obj, json__write_dict_kv, &ctx);
            if(!ok) return false;
            if(indent > 0) {
                c11_sbuf__write_char(buf, '\n');
                json__write_indent(buf, indent * depth);
            }
            c11_sbuf__write_char(buf, '}');
            return true;
        }
        case tp_namedict: {
            py_Ref original = py_getslot(obj, 0);
            c11_sbuf__write_char(buf, '{');
            if(PyObject__dict(original->_obj)->length == 0) {
                c11_sbuf__write_char(buf, '}');
                return true;
            }
            if(indent > 0) c11_sbuf__write_char(buf, '\n');
            json__write_dict_kv_ctx ctx = {.buf = buf,
                                           .first = true,
                                           .indent = indent,
                                           .depth = depth + 1};
            bool ok = py_applydict(original, json__write_namedict_kv, &ctx);
            if(!ok) return false;
            if(indent > 0) {
                c11_sbuf__write_char(buf, '\n');
                json__write_indent(buf, indent * depth);
            }
            c11_sbuf__write_char(buf, '}');
            return true;
        }
        default: return TypeError("'%t' object is not JSON serializable", obj->type);
    }
}

bool py_json_dumps(py_Ref val, int indent) {
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    bool ok = json__write_object(&buf, val, indent, 0);
    if(!ok) {
        c11_sbuf__dtor(&buf);
        return false;
    }
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

bool py_json_loads(const char* source) {
    py_GlobalRef mod = py_getmodule("json");
    return py_exec(source, "<json>", EVAL_MODE, mod);
}

bool py_pusheval(const char* expr, py_GlobalRef module) {
    bool ok = py_exec(expr, "<string>", EVAL_MODE, module);
    if(!ok) return false;
    py_push(py_retval());
    return true;
}

// src/modules/pkpy.c
#define DEF_TVALUE_METHODS(T, Field)                                                               \
    static bool TValue_##T##__new__(int argc, py_Ref argv) {                                       \
        PY_CHECK_ARGC(2);                                                                          \
        PY_CHECK_ARG_TYPE(0, tp_type);                                                             \
        PY_CHECK_ARG_TYPE(1, tp_##T);                                                              \
        *py_retval() = (py_TValue){                                                                \
            .type = py_totype(&argv[0]),                                                           \
            .is_ptr = false,                                                                       \
            .Field = py_to##T(&argv[1]),                                                           \
        };                                                                                         \
        return true;                                                                               \
    }                                                                                              \
    static bool TValue_##T##_value(int argc, py_Ref argv) {                                        \
        PY_CHECK_ARGC(1);                                                                          \
        py_new##T(py_retval(), argv->Field);                                                       \
        return true;                                                                               \
    }                                                                                              \
    static bool TValue_##T##__repr__(int argc, py_Ref argv) {                                      \
        PY_CHECK_ARGC(1);                                                                          \
        py_newstr(py_retval(), "<TValue_" #T " object>");                                          \
        return true;                                                                               \
    }

DEF_TVALUE_METHODS(int, _i64)
DEF_TVALUE_METHODS(float, _f64)
DEF_TVALUE_METHODS(vec2, _vec2)
DEF_TVALUE_METHODS(vec2i, _vec2i)

static bool pkpy_memory_usage(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    ManagedHeap* heap = &pk_current_vm->heap;
    c11_string* small_objects_usage = MultiPool__summary(&heap->small_objects);
    int large_object_count = heap->large_objects.length;
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_cstr(&buf, "== heap.small_objects ==\n");
    c11_sbuf__write_cstr(&buf, small_objects_usage->data);
    c11_sbuf__write_cstr(&buf, "== heap.large_objects ==\n");
    pk_sprintf(&buf, "len(large_objects)=%d\n", large_object_count);
    c11_sbuf__write_cstr(&buf, "== heap.gc ==\n");
    pk_sprintf(&buf, "gc_counter=%d\n", heap->gc_counter);
    pk_sprintf(&buf, "gc_threshold=%d", heap->gc_threshold);
    // c11_sbuf__write_cstr(&buf, "== vm.pool_frame ==\n");
    c11_sbuf__py_submit(&buf, py_retval());
    c11_string__delete(small_objects_usage);
    return true;
}

static bool pkpy_is_user_defined_type(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_type);
    py_TypeInfo* ti = pk__type_info(py_totype(argv));
    py_newbool(py_retval(), ti->is_python);
    return true;
}

void pk__add_module_pkpy() {
    py_Ref mod = py_newmodule("pkpy");

    py_Type ttype;
    py_Ref TValue_dict = py_pushtmp();
    py_newdict(TValue_dict);

    ttype = pk_newtype("TValue_int", tp_object, mod, NULL, false, false);
    py_bindmagic(ttype, __new__, TValue_int__new__);
    py_bindmagic(ttype, __repr__, TValue_int__repr__);
    py_bindproperty(ttype, "value", TValue_int_value, NULL);
    py_dict_setitem(TValue_dict, py_tpobject(tp_int), py_tpobject(ttype));

    ttype = pk_newtype("TValue_float", tp_object, mod, NULL, false, false);
    py_bindmagic(ttype, __new__, TValue_float__new__);
    py_bindmagic(ttype, __repr__, TValue_float__repr__);
    py_bindproperty(ttype, "value", TValue_float_value, NULL);
    py_dict_setitem(TValue_dict, py_tpobject(tp_float), py_tpobject(ttype));

    ttype = pk_newtype("TValue_vec2", tp_object, mod, NULL, false, false);
    py_bindmagic(ttype, __new__, TValue_vec2__new__);
    py_bindmagic(ttype, __repr__, TValue_vec2__repr__);
    py_bindproperty(ttype, "value", TValue_vec2_value, NULL);
    py_dict_setitem(TValue_dict, py_tpobject(tp_vec2), py_tpobject(ttype));

    ttype = pk_newtype("TValue_vec2i", tp_object, mod, NULL, false, false);
    py_bindmagic(ttype, __new__, TValue_vec2i__new__);
    py_bindmagic(ttype, __repr__, TValue_vec2i__repr__);
    py_bindproperty(ttype, "value", TValue_vec2i_value, NULL);
    py_dict_setitem(TValue_dict, py_tpobject(tp_vec2i), py_tpobject(ttype));

    py_setdict(mod, py_name("TValue"), TValue_dict);
    py_pop();

    py_bindfunc(mod, "memory_usage", pkpy_memory_usage);
    py_bindfunc(mod, "is_user_defined_type", pkpy_is_user_defined_type);
}

#undef DEF_TVALUE_METHODS
// src/modules/math.c
#include <math.h>

#define ONE_ARG_FUNC(name, func)                                                                   \
    static bool math_##name(int argc, py_Ref argv) {                                               \
        PY_CHECK_ARGC(1);                                                                          \
        double x;                                                                                  \
        if(!py_castfloat(py_arg(0), &x)) return false;                                             \
        py_newfloat(py_retval(), func(x));                                                         \
        return true;                                                                               \
    }

#define TWO_ARG_FUNC(name, func)                                                                   \
    static bool math_##name(int argc, py_Ref argv) {                                               \
        PY_CHECK_ARGC(2);                                                                          \
        double x, y;                                                                               \
        if(!py_castfloat(py_arg(0), &x)) return false;                                             \
        if(!py_castfloat(py_arg(1), &y)) return false;                                             \
        py_newfloat(py_retval(), func(x, y));                                                      \
        return true;                                                                               \
    }

ONE_ARG_FUNC(ceil, ceil)
ONE_ARG_FUNC(fabs, fabs)
ONE_ARG_FUNC(floor, floor)
ONE_ARG_FUNC(trunc, trunc)

static bool math_fsum(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_list);
    py_Ref list = py_arg(0);
    double sum = 0;
    double c = 0;
    for(int i = 0; i < py_list_len(list); i++) {
        py_Ref item = py_list_getitem(list, i);
        double x;
        if(!py_castfloat(item, &x)) return false;
        double y = x - c;
        double t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    py_newfloat(py_retval(), sum);
    return true;
}

static bool math_gcd(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(0, tp_int);
    PY_CHECK_ARG_TYPE(1, tp_int);
    py_i64 a = py_toint(py_arg(0));
    py_i64 b = py_toint(py_arg(1));
    if(a < 0) a = -a;
    if(b < 0) b = -b;
    while(b != 0) {
        py_i64 t = b;
        b = a % b;
        a = t;
    }
    py_newint(py_retval(), a);
    return true;
}

ONE_ARG_FUNC(isfinite, isfinite)
ONE_ARG_FUNC(isinf, isinf)
ONE_ARG_FUNC(isnan, isnan)

static bool math_isclose(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    double a, b;
    if(!py_castfloat(py_arg(0), &a)) return false;
    if(!py_castfloat(py_arg(1), &b)) return false;
    py_newbool(py_retval(), fabs(a - b) < 1e-9);
    return true;
}

ONE_ARG_FUNC(exp, exp)

static bool math_log(int argc, py_Ref argv) {
    double x;
    if(!py_castfloat(py_arg(0), &x)) return false;
    if(argc == 1) {
        py_newfloat(py_retval(), log(x));
    } else if(argc == 2) {
        double base;
        if(!py_castfloat(py_arg(1), &base)) return false;
        py_newfloat(py_retval(), log(x) / log(base));
    } else {
        return TypeError("log() takes 1 or 2 arguments");
    }
    return true;
}

ONE_ARG_FUNC(log2, log2)
ONE_ARG_FUNC(log10, log10)

TWO_ARG_FUNC(pow, pow)

ONE_ARG_FUNC(sqrt, sqrt)

ONE_ARG_FUNC(acos, acos)
ONE_ARG_FUNC(asin, asin)
ONE_ARG_FUNC(atan, atan)

ONE_ARG_FUNC(cos, cos)
ONE_ARG_FUNC(sin, sin)
ONE_ARG_FUNC(tan, tan)

TWO_ARG_FUNC(atan2, atan2)

static bool math_degrees(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    double x;
    if(!py_castfloat(py_arg(0), &x)) return false;
    py_newfloat(py_retval(), x * PK_M_RAD2DEG);
    return true;
}

static bool math_radians(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    double x;
    if(!py_castfloat(py_arg(0), &x)) return false;
    py_newfloat(py_retval(), x * PK_M_DEG2RAD);
    return true;
}

TWO_ARG_FUNC(fmod, fmod)

static bool math_modf(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    double i;
    double f = modf(py_tofloat(py_arg(0)), &i);
    py_Ref p = py_newtuple(py_retval(), 2);
    py_newfloat(&p[0], f);
    py_newfloat(&p[1], i);
    return true;
}

static bool math_factorial(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_int);
    py_i64 n = py_toint(py_arg(0));
    if(n < 0) return ValueError("factorial() not defined for negative values");
    py_i64 r = 1;
    for(py_i64 i = 2; i <= n; i++)
        r *= i;
    py_newint(py_retval(), r);
    return true;
}

void pk__add_module_math() {
    py_Ref mod = py_newmodule("math");

    py_newfloat(py_emplacedict(mod, py_name("pi")), PK_M_PI);
    py_newfloat(py_emplacedict(mod, py_name("e")), PK_M_E);
    py_newfloat(py_emplacedict(mod, py_name("inf")), INFINITY);
    py_newfloat(py_emplacedict(mod, py_name("nan")), NAN);

    py_bindfunc(mod, "ceil", math_ceil);
    py_bindfunc(mod, "fabs", math_fabs);
    py_bindfunc(mod, "floor", math_floor);
    py_bindfunc(mod, "trunc", math_trunc);

    py_bindfunc(mod, "fsum", math_fsum);
    py_bindfunc(mod, "gcd", math_gcd);

    py_bindfunc(mod, "isfinite", math_isfinite);
    py_bindfunc(mod, "isinf", math_isinf);
    py_bindfunc(mod, "isnan", math_isnan);
    py_bindfunc(mod, "isclose", math_isclose);

    py_bindfunc(mod, "exp", math_exp);
    py_bindfunc(mod, "log", math_log);
    py_bindfunc(mod, "log2", math_log2);
    py_bindfunc(mod, "log10", math_log10);

    py_bindfunc(mod, "pow", math_pow);
    py_bindfunc(mod, "sqrt", math_sqrt);

    py_bindfunc(mod, "acos", math_acos);
    py_bindfunc(mod, "asin", math_asin);
    py_bindfunc(mod, "atan", math_atan);

    py_bindfunc(mod, "cos", math_cos);
    py_bindfunc(mod, "sin", math_sin);
    py_bindfunc(mod, "tan", math_tan);

    py_bindfunc(mod, "atan2", math_atan2);

    py_bindfunc(mod, "degrees", math_degrees);
    py_bindfunc(mod, "radians", math_radians);

    py_bindfunc(mod, "fmod", math_fmod);
    py_bindfunc(mod, "modf", math_modf);
    py_bindfunc(mod, "factorial", math_factorial);
}

#undef ONE_ARG_FUNC
#undef TWO_ARG_FUNC
// src/modules/linalg.c
#include <math.h>

static bool isclose(float a, float b) { return fabs(a - b) < 1e-4; }

#define DEFINE_VEC_FIELD(name, T, Tc, field)                                                       \
    static bool name##__##field(int argc, py_Ref argv) {                                           \
        PY_CHECK_ARGC(1);                                                                          \
        py_new##T(py_retval(), py_to##name(argv).field);                                           \
        return true;                                                                               \
    }                                                                                              \
    static bool name##__with_##field(int argc, py_Ref argv) {                                      \
        PY_CHECK_ARGC(2);                                                                          \
        Tc val;                                                                                    \
        if(!py_cast##T(&argv[1], &val)) return false;                                              \
        c11_##name v = py_to##name(argv);                                                          \
        v.field = val;                                                                             \
        py_new##name(py_retval(), v);                                                              \
        return true;                                                                               \
    }

#define DEFINE_BOOL_NE(name, f_eq)                                                                 \
    static bool name##__ne__(int argc, py_Ref argv) {                                              \
        f_eq(argc, argv);                                                                          \
        py_Ref ret = py_retval();                                                                  \
        if(ret->type == tp_NotImplementedType) return true;                                        \
        ret->_bool = !ret->_bool;                                                                  \
        return true;                                                                               \
    }

void py_newvec2(py_OutRef out, c11_vec2 v) {
    out->type = tp_vec2;
    out->is_ptr = false;
    out->_vec2 = v;
}

c11_vec2 py_tovec2(py_Ref self) {
    assert(self->type == tp_vec2);
    return self->_vec2;
}

void py_newvec2i(py_OutRef out, c11_vec2i v) {
    out->type = tp_vec2i;
    out->is_ptr = false;
    out->_vec2i = v;
}

c11_vec2i py_tovec2i(py_Ref self) {
    assert(self->type == tp_vec2i);
    return self->_vec2i;
}

void py_newvec3(py_OutRef out, c11_vec3 v) {
    out->type = tp_vec3;
    out->is_ptr = false;
    c11_vec3* data = (c11_vec3*)(&out->extra);
    *data = v;
}

c11_vec3 py_tovec3(py_Ref self) {
    assert(self->type == tp_vec3);
    return *(c11_vec3*)(&self->extra);
}

void py_newvec3i(py_OutRef out, c11_vec3i v) {
    out->type = tp_vec3i;
    out->is_ptr = false;
    c11_vec3i* data = (c11_vec3i*)(&out->extra);
    *data = v;
}

c11_vec3i py_tovec3i(py_Ref self) {
    assert(self->type == tp_vec3i);
    return *(c11_vec3i*)(&self->extra);
}

c11_mat3x3* py_newmat3x3(py_OutRef out) {
    return py_newobject(out, tp_mat3x3, 0, sizeof(c11_mat3x3));
}

c11_mat3x3* py_tomat3x3(py_Ref self) {
    assert(self->type == tp_mat3x3);
    return py_touserdata(self);
}

static py_Ref _const(py_Type type, const char* name) {
    return py_emplacedict(py_tpobject(type), py_name(name));
}

#define DEF_VECTOR_ELEMENT_WISE(D, T, name, op)                                                    \
    static bool T##name(int argc, py_Ref argv) {                                                   \
        PY_CHECK_ARGC(2);                                                                          \
        if(argv[1].type != tp_##T) {                                                               \
            py_newnotimplemented(py_retval());                                                     \
            return true;                                                                           \
        }                                                                                          \
        c11_##T a = py_to##T(&argv[0]);                                                            \
        c11_##T b = py_to##T(&argv[1]);                                                            \
        c11_##T res;                                                                               \
        for(int i = 0; i < D; i++)                                                                 \
            res.data[i] = a.data[i] op b.data[i];                                                  \
        py_new##T(py_retval(), res);                                                               \
        return true;                                                                               \
    }

#define DEF_VECTOR_OPS(D)                                                                          \
    static bool vec##D##__new__(int argc, py_Ref argv) {                                           \
        c11_vec##D res;                                                                            \
        if(argc == 2) {                                                                            \
            PY_CHECK_ARG_TYPE(1, tp_vec##D##i);                                                    \
            c11_vec##D##i v = py_tovec##D##i(&argv[1]);                                            \
            for(int i = 0; i < D; i++)                                                             \
                res.data[i] = v.data[i];                                                           \
        } else {                                                                                   \
            PY_CHECK_ARGC(D + 1);                                                                  \
            for(int i = 0; i < D; i++) {                                                           \
                if(!py_castfloat32(&argv[i + 1], &res.data[i])) return false;                      \
            }                                                                                      \
        }                                                                                          \
        py_newvec##D(py_retval(), res);                                                            \
        return true;                                                                               \
    }                                                                                              \
    DEF_VECTOR_ELEMENT_WISE(D, vec##D, __add__, +)                                                 \
    DEF_VECTOR_ELEMENT_WISE(D, vec##D, __sub__, -)                                                 \
    static bool vec##D##__mul__(int argc, py_Ref argv) {                                           \
        PY_CHECK_ARGC(2);                                                                          \
        c11_vec##D res;                                                                            \
        switch(argv[1].type) {                                                                     \
            case tp_vec##D: {                                                                      \
                c11_vec##D a = py_tovec##D(&argv[0]);                                              \
                c11_vec##D b = py_tovec##D(&argv[1]);                                              \
                for(int i = 0; i < D; i++)                                                         \
                    res.data[i] = a.data[i] * b.data[i];                                           \
                py_newvec##D(py_retval(), res);                                                    \
                return true;                                                                       \
            }                                                                                      \
            case tp_int: {                                                                         \
                c11_vec##D a = py_tovec##D(&argv[0]);                                              \
                py_i64 b = argv[1]._i64;                                                           \
                for(int i = 0; i < D; i++)                                                         \
                    res.data[i] = a.data[i] * b;                                                   \
                py_newvec##D(py_retval(), res);                                                    \
                return true;                                                                       \
            }                                                                                      \
            case tp_float: {                                                                       \
                c11_vec##D a = py_tovec##D(&argv[0]);                                              \
                py_f64 b = argv[1]._f64;                                                           \
                for(int i = 0; i < D; i++)                                                         \
                    res.data[i] = a.data[i] * b;                                                   \
                py_newvec##D(py_retval(), res);                                                    \
                return true;                                                                       \
            }                                                                                      \
            default: py_newnotimplemented(py_retval()); return true;                               \
        }                                                                                          \
    }                                                                                              \
    static bool vec##D##__truediv__(int argc, py_Ref argv) {                                       \
        PY_CHECK_ARGC(2);                                                                          \
        float divisor;                                                                             \
        if(!py_castfloat32(&argv[1], &divisor)) {                                                  \
            py_clearexc(NULL);                                                                     \
            py_newnotimplemented(py_retval());                                                     \
            return true;                                                                           \
        }                                                                                          \
        c11_vec##D res;                                                                            \
        c11_vec##D a = py_tovec##D(&argv[0]);                                                      \
        for(int i = 0; i < D; i++)                                                                 \
            res.data[i] = a.data[i] / divisor;                                                     \
        py_newvec##D(py_retval(), res);                                                            \
        return true;                                                                               \
    }                                                                                              \
    static bool vec##D##__eq__(int argc, py_Ref argv) {                                            \
        PY_CHECK_ARGC(2);                                                                          \
        if(argv[1].type != tp_vec##D) {                                                            \
            py_newnotimplemented(py_retval());                                                     \
            return true;                                                                           \
        }                                                                                          \
        c11_vec##D lhs = py_tovec##D(&argv[0]);                                                    \
        c11_vec##D rhs = py_tovec##D(&argv[1]);                                                    \
        bool ok = true;                                                                            \
        for(int i = 0; i < D; i++) {                                                               \
            if(!isclose(lhs.data[i], rhs.data[i])) ok = false;                                     \
        }                                                                                          \
        py_newbool(py_retval(), ok);                                                               \
        return true;                                                                               \
    }                                                                                              \
    DEFINE_BOOL_NE(vec##D, vec##D##__eq__)                                                         \
    static bool vec##D##_length(int argc, py_Ref argv) {                                           \
        PY_CHECK_ARGC(1);                                                                          \
        c11_vec##D v = py_tovec##D(argv);                                                          \
        float sum = 0;                                                                             \
        for(int i = 0; i < D; i++)                                                                 \
            sum += v.data[i] * v.data[i];                                                          \
        py_newfloat(py_retval(), sqrtf(sum));                                                      \
        return true;                                                                               \
    }                                                                                              \
    static bool vec##D##_length_squared(int argc, py_Ref argv) {                                   \
        PY_CHECK_ARGC(1);                                                                          \
        c11_vec##D v = py_tovec##D(argv);                                                          \
        float sum = 0;                                                                             \
        for(int i = 0; i < D; i++)                                                                 \
            sum += v.data[i] * v.data[i];                                                          \
        py_newfloat(py_retval(), sum);                                                             \
        return true;                                                                               \
    }                                                                                              \
    static bool vec##D##_dot(int argc, py_Ref argv) {                                              \
        PY_CHECK_ARGC(2);                                                                          \
        PY_CHECK_ARG_TYPE(1, tp_vec##D);                                                           \
        c11_vec##D a = py_tovec##D(&argv[0]);                                                      \
        c11_vec##D b = py_tovec##D(&argv[1]);                                                      \
        float sum = 0;                                                                             \
        for(int i = 0; i < D; i++)                                                                 \
            sum += a.data[i] * b.data[i];                                                          \
        py_newfloat(py_retval(), sum);                                                             \
        return true;                                                                               \
    }                                                                                              \
    static bool vec##D##_normalize(int argc, py_Ref argv) {                                        \
        PY_CHECK_ARGC(1);                                                                          \
        c11_vec##D self = py_tovec##D(argv);                                                       \
        float len = 0;                                                                             \
        for(int i = 0; i < D; i++)                                                                 \
            len += self.data[i] * self.data[i];                                                    \
        if(isclose(len, 0)) return ZeroDivisionError("cannot normalize zero vector");              \
        len = sqrtf(len);                                                                          \
        c11_vec##D res;                                                                            \
        for(int i = 0; i < D; i++)                                                                 \
            res.data[i] = self.data[i] / len;                                                      \
        py_newvec##D(py_retval(), res);                                                            \
        return true;                                                                               \
    }

DEF_VECTOR_OPS(2)
DEF_VECTOR_OPS(3)

#define DEF_VECTOR_INT_OPS(D)                                                                      \
    static bool vec##D##i__new__(int argc, py_Ref argv) {                                          \
        PY_CHECK_ARGC(D + 1);                                                                      \
        c11_vec##D##i res;                                                                         \
        for(int i = 0; i < D; i++) {                                                               \
            if(!py_checkint(&argv[i + 1])) return false;                                           \
            res.data[i] = py_toint(&argv[i + 1]);                                                  \
        }                                                                                          \
        py_newvec##D##i(py_retval(), res);                                                         \
        return true;                                                                               \
    }                                                                                              \
    DEF_VECTOR_ELEMENT_WISE(D, vec##D##i, __add__, +)                                              \
    DEF_VECTOR_ELEMENT_WISE(D, vec##D##i, __sub__, -)                                              \
    static bool vec##D##i__mul__(int argc, py_Ref argv) {                                          \
        PY_CHECK_ARGC(2);                                                                          \
        c11_vec##D##i res;                                                                         \
        switch(argv[1].type) {                                                                     \
            case tp_vec##D##i: {                                                                   \
                c11_vec##D##i a = py_tovec##D##i(&argv[0]);                                        \
                c11_vec##D##i b = py_tovec##D##i(&argv[1]);                                        \
                for(int i = 0; i < D; i++)                                                         \
                    res.data[i] = a.data[i] * b.data[i];                                           \
                py_newvec##D##i(py_retval(), res);                                                 \
                return true;                                                                       \
            }                                                                                      \
            case tp_int: {                                                                         \
                c11_vec##D##i a = py_tovec##D##i(&argv[0]);                                        \
                py_i64 b = argv[1]._i64;                                                           \
                for(int i = 0; i < D; i++)                                                         \
                    res.data[i] = a.data[i] * b;                                                   \
                py_newvec##D##i(py_retval(), res);                                                 \
                return true;                                                                       \
            }                                                                                      \
            default: py_newnotimplemented(py_retval()); return true;                               \
        }                                                                                          \
    }                                                                                              \
    static bool vec##D##i__eq__(int argc, py_Ref argv) {                                           \
        PY_CHECK_ARGC(2);                                                                          \
        if(argv[1].type != tp_vec##D##i) {                                                         \
            py_newnotimplemented(py_retval());                                                     \
            return true;                                                                           \
        }                                                                                          \
        c11_vec##D##i lhs = py_tovec##D##i(&argv[0]);                                              \
        c11_vec##D##i rhs = py_tovec##D##i(&argv[1]);                                              \
        bool ok = true;                                                                            \
        for(int i = 0; i < D; i++) {                                                               \
            if(lhs.data[i] != rhs.data[i]) ok = false;                                             \
        }                                                                                          \
        py_newbool(py_retval(), ok);                                                               \
        return true;                                                                               \
    }                                                                                              \
    DEFINE_BOOL_NE(vec##D##i, vec##D##i__eq__)                                                     \
    static bool vec##D##i##_dot(int argc, py_Ref argv) {                                           \
        PY_CHECK_ARGC(2);                                                                          \
        PY_CHECK_ARG_TYPE(1, tp_vec##D##i);                                                        \
        c11_vec##D##i a = py_tovec##D##i(&argv[0]);                                                \
        c11_vec##D##i b = py_tovec##D##i(&argv[1]);                                                \
        py_i64 sum = 0;                                                                            \
        for(int i = 0; i < D; i++)                                                                 \
            sum += a.data[i] * b.data[i];                                                          \
        py_newint(py_retval(), sum);                                                               \
        return true;                                                                               \
    }                                                                                              \
    static bool vec##D##i##__floordiv__(int argc, py_Ref argv) {                                   \
        PY_CHECK_ARGC(2);                                                                          \
        PY_CHECK_ARG_TYPE(1, tp_int);                                                              \
        c11_vec##D##i a = py_tovec##D##i(&argv[0]);                                                \
        py_i64 b = py_toint(&argv[1]);                                                             \
        for(int i = 0; i < D; i++)                                                                 \
            a.data[i] /= b;                                                                        \
        py_newvec##D##i(py_retval(), a);                                                           \
        return true;                                                                               \
    }

DEF_VECTOR_INT_OPS(2)
DEF_VECTOR_INT_OPS(3)

static bool vec2i__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec2i v = py_tovec2i(argv);
    uint64_t x_part = (uint32_t)v.x & 0xFFFFFFFF;
    uint64_t y_part = (uint32_t)v.y & 0xFFFFFFFF;
    uint64_t hash = (x_part << 32) | y_part;
    py_newint(py_retval(), (py_i64)hash);
    return true;
}

static bool vec3i__hash__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec3i v = py_tovec3i(argv);
    uint64_t x_part = (uint32_t)v.x & 0xFFFFFF;
    uint64_t y_part = (uint32_t)v.y & 0xFFFFFF;
    uint64_t z_part = (uint32_t)v.z & 0xFFFF;
    uint64_t hash = (x_part << 40) | (y_part << 16) | z_part;
    py_newint(py_retval(), (py_i64)hash);
    return true;
}

static bool vec2__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    char buf[64];
    int size = snprintf(buf, 64, "vec2(%.4f, %.4f)", argv[0]._vec2.x, argv[0]._vec2.y);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

static bool vec2_rotate(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    py_f64 radians;
    if(!py_castfloat(&argv[1], &radians)) return false;
    float cr = cosf(radians);
    float sr = sinf(radians);
    c11_vec2 res;
    res.x = argv[0]._vec2.x * cr - argv[0]._vec2.y * sr;
    res.y = argv[0]._vec2.x * sr + argv[0]._vec2.y * cr;
    py_newvec2(py_retval(), res);
    return true;
}

static bool vec2_angle_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(0, tp_vec2);
    PY_CHECK_ARG_TYPE(1, tp_vec2);
    float val = atan2f(argv[1]._vec2.y, argv[1]._vec2.x) - atan2f(argv[0]._vec2.y, argv[0]._vec2.x);
    if(val > PK_M_PI) val -= 2 * (float)PK_M_PI;
    if(val < -PK_M_PI) val += 2 * (float)PK_M_PI;
    py_newfloat(py_retval(), val);
    return true;
}

static bool vec2_smoothdamp_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(6);
    PY_CHECK_ARG_TYPE(0, tp_vec2);  // current: vec2
    PY_CHECK_ARG_TYPE(1, tp_vec2);  // target: vec2
    PY_CHECK_ARG_TYPE(2, tp_vec2);  // current_velocity: vec2

    float smoothTime;
    if(!py_castfloat32(&argv[3], &smoothTime)) return false;
    float maxSpeed;
    if(!py_castfloat32(&argv[4], &maxSpeed)) return false;
    float deltaTime;
    if(!py_castfloat32(&argv[5], &deltaTime)) return false;
    c11_vec2 current = argv[0]._vec2;
    c11_vec2 target = argv[1]._vec2;
    c11_vec2 currentVelocity = argv[2]._vec2;

    // https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Math/Vector2.cs#L289
    // Based on Game Programming Gems 4 Chapter 1.10
    smoothTime = c11__max(0.0001F, smoothTime);
    float omega = 2.0F / smoothTime;

    float x = omega * deltaTime;
    float exp = 1.0F / (1.0F + x + 0.48F * x * x + 0.235F * x * x * x);

    float change_x = current.x - target.x;
    float change_y = current.y - target.y;
    c11_vec2 originalTo = target;

    // Clamp maximum speed
    float maxChange = maxSpeed * smoothTime;

    float maxChangeSq = maxChange * maxChange;
    float sqDist = change_x * change_x + change_y * change_y;
    if(sqDist > maxChangeSq) {
        float mag = sqrtf(sqDist);
        change_x = change_x / mag * maxChange;
        change_y = change_y / mag * maxChange;
    }

    target.x = current.x - change_x;
    target.y = current.y - change_y;

    float temp_x = (currentVelocity.x + omega * change_x) * deltaTime;
    float temp_y = (currentVelocity.y + omega * change_y) * deltaTime;

    currentVelocity.x = (currentVelocity.x - omega * temp_x) * exp;
    currentVelocity.y = (currentVelocity.y - omega * temp_y) * exp;

    float output_x = target.x + (change_x + temp_x) * exp;
    float output_y = target.y + (change_y + temp_y) * exp;

    // Prevent overshooting
    float origMinusCurrent_x = originalTo.x - current.x;
    float origMinusCurrent_y = originalTo.y - current.y;
    float outMinusOrig_x = output_x - originalTo.x;
    float outMinusOrig_y = output_y - originalTo.y;

    if(origMinusCurrent_x * outMinusOrig_x + origMinusCurrent_y * outMinusOrig_y > 0) {
        output_x = originalTo.x;
        output_y = originalTo.y;

        currentVelocity.x = (output_x - originalTo.x) / deltaTime;
        currentVelocity.y = (output_y - originalTo.y) / deltaTime;
    }

    py_Ref ret = py_retval();
    py_Ref p = py_newtuple(ret, 2);
    py_newvec2(&p[0],
               (c11_vec2){
                   {output_x, output_y}
    });
    py_newvec2(&p[1], currentVelocity);
    return true;
}

DEFINE_VEC_FIELD(vec2, float, py_f64, x)
DEFINE_VEC_FIELD(vec2, float, py_f64, y)

static bool vec2__with_z(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    float z;
    if(!py_castfloat32(&argv[1], &z)) return false;
    c11_vec3 v = {
        {argv->_vec2.x, argv->_vec2.y, z}
    };
    py_newvec3(py_retval(), v);
    return true;
}

/* mat3x3 */
static bool mat3x3__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(10);
    c11_mat3x3* m = py_newmat3x3(py_retval());
    for(int i = 0; i < 9; i++) {
        py_f64 val;
        if(!py_castfloat(&argv[i + 1], &val)) return false;
        m->data[i] = val;
    }
    return true;
}

static bool mat3x3__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* m = py_tomat3x3(argv);
    char buf[256];
    const char* fmt =
        "mat3x3(%.4f, %.4f, %.4f,\n       %.4f, %.4f, %.4f,\n      "
        " %.4f, %.4f, %.4f)";
    int size = snprintf(buf,
                        256,
                        fmt,
                        m->data[0],
                        m->data[1],
                        m->data[2],
                        m->data[3],
                        m->data[4],
                        m->data[5],
                        m->data[6],
                        m->data[7],
                        m->data[8]);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

static bool mat3x3__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_tuple);
    c11_mat3x3* ud = py_tomat3x3(argv);
    if(py_tuple_len(&argv[1]) != 2) return IndexError("expected a tuple of length 2");
    py_Ref i = py_tuple_getitem(&argv[1], 0);
    py_Ref j = py_tuple_getitem(&argv[1], 1);
    if(!py_checktype(i, tp_int) || !py_checktype(j, tp_int)) return false;
    if(i->_i64 < 0 || i->_i64 >= 3 || j->_i64 < 0 || j->_i64 >= 3) {
        return IndexError("index out of range");
    }
    py_newfloat(py_retval(), ud->m[i->_i64][j->_i64]);
    return true;
}

static bool mat3x3__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_tuple);
    c11_mat3x3* ud = py_tomat3x3(argv);
    if(py_tuple_len(&argv[1]) != 2) return IndexError("expected a tuple of length 2");
    py_Ref i = py_tuple_getitem(&argv[1], 0);
    py_Ref j = py_tuple_getitem(&argv[1], 1);
    if(!py_checktype(i, tp_int) || !py_checktype(j, tp_int)) return false;
    py_f64 val;
    if(!py_castfloat(&argv[2], &val)) return false;
    if(i->_i64 < 0 || i->_i64 >= 3 || j->_i64 < 0 || j->_i64 >= 3) {
        return IndexError("index out of range");
    }
    ud->m[i->_i64][j->_i64] = val;
    py_newnone(py_retval());
    return true;
}

static bool mat3x3__eq__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    if(argv[1].type != tp_mat3x3) {
        py_newnotimplemented(py_retval());
        return true;
    }
    c11_mat3x3* lhs = py_tomat3x3(argv);
    c11_mat3x3* rhs = py_tomat3x3(&argv[1]);
    for(int i = 0; i < 9; i++) {
        if(!isclose(lhs->data[i], rhs->data[i])) {
            py_newbool(py_retval(), false);
            return true;
        }
    }
    py_newbool(py_retval(), true);
    return true;
}

DEFINE_BOOL_NE(mat3x3, mat3x3__eq__)

static void matmul(const c11_mat3x3* lhs, const c11_mat3x3* rhs, c11_mat3x3* out) {
    out->_11 = lhs->_11 * rhs->_11 + lhs->_12 * rhs->_21 + lhs->_13 * rhs->_31;
    out->_12 = lhs->_11 * rhs->_12 + lhs->_12 * rhs->_22 + lhs->_13 * rhs->_32;
    out->_13 = lhs->_11 * rhs->_13 + lhs->_12 * rhs->_23 + lhs->_13 * rhs->_33;
    out->_21 = lhs->_21 * rhs->_11 + lhs->_22 * rhs->_21 + lhs->_23 * rhs->_31;
    out->_22 = lhs->_21 * rhs->_12 + lhs->_22 * rhs->_22 + lhs->_23 * rhs->_32;
    out->_23 = lhs->_21 * rhs->_13 + lhs->_22 * rhs->_23 + lhs->_23 * rhs->_33;
    out->_31 = lhs->_31 * rhs->_11 + lhs->_32 * rhs->_21 + lhs->_33 * rhs->_31;
    out->_32 = lhs->_31 * rhs->_12 + lhs->_32 * rhs->_22 + lhs->_33 * rhs->_32;
    out->_33 = lhs->_31 * rhs->_13 + lhs->_32 * rhs->_23 + lhs->_33 * rhs->_33;
}

static float determinant(const c11_mat3x3* m) {
    return m->_11 * (m->_22 * m->_33 - m->_23 * m->_32) -
           m->_12 * (m->_21 * m->_33 - m->_23 * m->_31) +
           m->_13 * (m->_21 * m->_32 - m->_22 * m->_31);
}

static bool inverse(const c11_mat3x3* m, c11_mat3x3* out) {
    float det = determinant(m);
    if(isclose(det, 0)) return false;
    float invdet = 1.0f / det;
    out->_11 = (m->_22 * m->_33 - m->_23 * m->_32) * invdet;
    out->_12 = (m->_13 * m->_32 - m->_12 * m->_33) * invdet;
    out->_13 = (m->_12 * m->_23 - m->_13 * m->_22) * invdet;
    out->_21 = (m->_23 * m->_31 - m->_21 * m->_33) * invdet;
    out->_22 = (m->_11 * m->_33 - m->_13 * m->_31) * invdet;
    out->_23 = (m->_13 * m->_21 - m->_11 * m->_23) * invdet;
    out->_31 = (m->_21 * m->_32 - m->_22 * m->_31) * invdet;
    out->_32 = (m->_12 * m->_31 - m->_11 * m->_32) * invdet;
    out->_33 = (m->_11 * m->_22 - m->_12 * m->_21) * invdet;
    return true;
}

static void trs(c11_vec2 t, float r, c11_vec2 s, c11_mat3x3* out) {
    float cr = cosf(r);
    float sr = sinf(r);
    // clang-format off
    *out = (c11_mat3x3){
        ._11 = s.x * cr, ._12 = -s.y * sr, ._13 = t.x,
        ._21 = s.x * sr, ._22 = s.y * cr, ._23 = t.y,
        ._31 = 0, ._32 = 0, ._33 = 1,
    };
    // clang-format on
}

static bool mat3x3__matmul__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_mat3x3* lhs = py_tomat3x3(argv);
    if(argv[1].type == tp_mat3x3) {
        c11_mat3x3* rhs = py_tomat3x3(&argv[1]);
        c11_mat3x3* out = py_newmat3x3(py_retval());
        matmul(lhs, rhs, out);
    } else if(argv[1].type == tp_vec3) {
        c11_vec3 rhs = py_tovec3(&argv[1]);
        c11_vec3 res;
        res.x = lhs->_11 * rhs.x + lhs->_12 * rhs.y + lhs->_13 * rhs.z;
        res.y = lhs->_21 * rhs.x + lhs->_22 * rhs.y + lhs->_23 * rhs.z;
        res.z = lhs->_31 * rhs.x + lhs->_32 * rhs.y + lhs->_33 * rhs.z;
        py_newvec3(py_retval(), res);
    } else {
        py_newnotimplemented(py_retval());
    }
    return true;
}

static bool mat3x3__invert__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    if(inverse(ud, out)) return true;
    return ZeroDivisionError("matrix is not invertible");
}

static bool mat3x3_matmul(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(0, tp_mat3x3);
    PY_CHECK_ARG_TYPE(1, tp_mat3x3);
    PY_CHECK_ARG_TYPE(2, tp_mat3x3);
    c11_mat3x3* lhs = py_tomat3x3(&argv[0]);
    c11_mat3x3* rhs = py_tomat3x3(&argv[1]);
    c11_mat3x3* out = py_tomat3x3(&argv[2]);
    matmul(lhs, rhs, out);
    py_newnone(py_retval());
    return true;
}

static bool mat3x3_determinant(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    py_newfloat(py_retval(), determinant(ud));
    return true;
}

static bool mat3x3_copy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    *out = *ud;
    return true;
}

static bool mat3x3_inverse(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    if(inverse(ud, out)) return true;
    return ZeroDivisionError("matrix is not invertible");
}

static bool mat3x3_copy_(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_mat3x3);
    c11_mat3x3* self = py_tomat3x3(argv);
    c11_mat3x3* other = py_tomat3x3(&argv[1]);
    *self = *other;
    py_newnone(py_retval());
    return true;
}

static bool mat3x3_inverse_(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_mat3x3 res;
    if(inverse(ud, &res)) {
        *ud = res;
        py_newnone(py_retval());
        return true;
    }
    return ZeroDivisionError("matrix is not invertible");
}

static bool mat3x3_zeros_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    memset(out, 0, sizeof(c11_mat3x3));
    return true;
}

static bool mat3x3_identity_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    // clang-format off
    *out = (c11_mat3x3){
        ._11 = 1, ._12 = 0, ._13 = 0,
        ._21 = 0, ._22 = 1, ._23 = 0,
        ._31 = 0, ._32 = 0, ._33 = 1,
    };
    // clang-format on
    return true;
}

static bool mat3x3_trs_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    py_f64 r;
    if(!py_checktype(&argv[0], tp_vec2)) return false;
    if(!py_castfloat(&argv[1], &r)) return false;
    if(!py_checktype(&argv[2], tp_vec2)) return false;
    c11_vec2 t = py_tovec2(&argv[0]);
    c11_vec2 s = py_tovec2(&argv[2]);
    c11_mat3x3* out = py_newmat3x3(py_retval());
    trs(t, r, s, out);
    return true;
}

static bool mat3x3_copy_trs_(int argc, py_Ref argv) {
    PY_CHECK_ARGC(4);
    c11_mat3x3* ud = py_tomat3x3(&argv[0]);
    py_f64 r;
    if(!py_checktype(&argv[1], tp_vec2)) return false;
    if(!py_castfloat(&argv[2], &r)) return false;
    if(!py_checktype(&argv[3], tp_vec2)) return false;
    c11_vec2 t = py_tovec2(&argv[1]);
    c11_vec2 s = py_tovec2(&argv[3]);
    trs(t, r, s, ud);
    py_newnone(py_retval());
    return true;
}

static bool mat3x3_t(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_vec2 res;
    res.x = ud->_13;
    res.y = ud->_23;
    py_newvec2(py_retval(), res);
    return true;
}

static bool mat3x3_r(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    float r = atan2f(ud->_21, ud->_11);
    py_newfloat(py_retval(), r);
    return true;
}

static bool mat3x3_s(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_mat3x3* ud = py_tomat3x3(argv);
    c11_vec2 res;
    res.x = sqrtf(ud->_11 * ud->_11 + ud->_21 * ud->_21);
    res.y = sqrtf(ud->_12 * ud->_12 + ud->_22 * ud->_22);
    py_newvec2(py_retval(), res);
    return true;
}

static bool mat3x3_transform_point(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2);
    c11_mat3x3* ud = py_tomat3x3(&argv[0]);
    c11_vec2 p = py_tovec2(&argv[1]);
    c11_vec2 res;
    res.x = ud->_11 * p.x + ud->_12 * p.y + ud->_13;
    res.y = ud->_21 * p.x + ud->_22 * p.y + ud->_23;
    py_newvec2(py_retval(), res);
    return true;
}

static bool mat3x3_transform_vector(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2);
    c11_mat3x3* ud = py_tomat3x3(&argv[0]);
    c11_vec2 p = py_tovec2(&argv[1]);
    c11_vec2 res;
    res.x = ud->_11 * p.x + ud->_12 * p.y;
    res.y = ud->_21 * p.x + ud->_22 * p.y;
    py_newvec2(py_retval(), res);
    return true;
}

/* vec2i */
DEFINE_VEC_FIELD(vec2i, int, py_i64, x)
DEFINE_VEC_FIELD(vec2i, int, py_i64, y)

static bool vec2i__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec2i data = py_tovec2i(argv);
    char buf[64];
    int size = snprintf(buf, 64, "vec2i(%d, %d)", data.x, data.y);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

/* vec3i */
static bool vec3i__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec3i data = py_tovec3i(argv);
    char buf[64];
    int size = snprintf(buf, 64, "vec3i(%d, %d, %d)", data.x, data.y, data.z);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

DEFINE_VEC_FIELD(vec3i, int, py_i64, x)
DEFINE_VEC_FIELD(vec3i, int, py_i64, y)
DEFINE_VEC_FIELD(vec3i, int, py_i64, z)

/* vec3 */
static bool vec3__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec3 data = py_tovec3(argv);
    char buf[64];
    int size = snprintf(buf, 64, "vec3(%.4f, %.4f, %.4f)", data.x, data.y, data.z);
    py_newstrv(py_retval(), (c11_sv){buf, size});
    return true;
}

DEFINE_VEC_FIELD(vec3, float, py_f64, x)
DEFINE_VEC_FIELD(vec3, float, py_f64, y)
DEFINE_VEC_FIELD(vec3, float, py_f64, z)

static bool vec3__xy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_vec3 data = py_tovec3(argv);
    c11_vec2 res = {
        {data.x, data.y}
    };
    py_newvec2(py_retval(), res);
    return true;
}

static bool vec3__with_xy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2);
    c11_vec2 xy = py_tovec2(&argv[1]);
    c11_vec3 res = {
        {xy.x, xy.y, py_tovec3(argv).z}
    };
    py_newvec3(py_retval(), res);
    return true;
}

void pk__add_module_linalg() {
    py_Ref mod = py_newmodule("linalg");

    py_Type vec2 = pk_newtype("vec2", tp_object, mod, NULL, false, true);
    py_Type vec3 = pk_newtype("vec3", tp_object, mod, NULL, false, true);
    py_Type vec2i = pk_newtype("vec2i", tp_object, mod, NULL, false, true);
    py_Type vec3i = pk_newtype("vec3i", tp_object, mod, NULL, false, true);
    py_Type mat3x3 = pk_newtype("mat3x3", tp_object, mod, NULL, false, true);

    py_setdict(mod, py_name("vec2"), py_tpobject(vec2));
    py_setdict(mod, py_name("vec3"), py_tpobject(vec3));
    py_setdict(mod, py_name("vec2i"), py_tpobject(vec2i));
    py_setdict(mod, py_name("vec3i"), py_tpobject(vec3i));
    py_setdict(mod, py_name("mat3x3"), py_tpobject(mat3x3));

    assert(vec2 == tp_vec2);
    assert(vec3 == tp_vec3);
    assert(vec2i == tp_vec2i);
    assert(vec3i == tp_vec3i);
    assert(mat3x3 == tp_mat3x3);

    /* vec2 */
    py_bindmagic(vec2, __new__, vec2__new__);
    py_bindmagic(vec2, __add__, vec2__add__);
    py_bindmagic(vec2, __sub__, vec2__sub__);
    py_bindmagic(vec2, __mul__, vec2__mul__);
    py_bindmagic(vec2, __truediv__, vec2__truediv__);
    py_bindmagic(vec2, __repr__, vec2__repr__);
    py_bindmagic(vec2, __eq__, vec2__eq__);
    py_bindmagic(vec2, __ne__, vec2__ne__);
    py_bindmethod(vec2, "dot", vec2_dot);
    py_bindmethod(vec2, "length", vec2_length);
    py_bindmethod(vec2, "length_squared", vec2_length_squared);
    py_bindmethod(vec2, "normalize", vec2_normalize);
    py_bindmethod(vec2, "rotate", vec2_rotate);

    // clang-format off
    py_newvec2(_const(vec2, "ZERO"), (c11_vec2){{0, 0}});
    py_newvec2(_const(vec2, "ONE"), (c11_vec2){{1, 1}});
    py_newvec2(_const(vec2, "LEFT"), (c11_vec2){{-1, 0}});
    py_newvec2(_const(vec2, "RIGHT"), (c11_vec2){{1, 0}});
    py_newvec2(_const(vec2, "UP"), (c11_vec2){{0, -1}});
    py_newvec2(_const(vec2, "DOWN"), (c11_vec2){{0, 1}});
    // clang-format on

    py_bindstaticmethod(vec2, "angle", vec2_angle_STATIC);
    py_bindstaticmethod(vec2, "smooth_damp", vec2_smoothdamp_STATIC);

    py_bindproperty(vec2, "x", vec2__x, NULL);
    py_bindproperty(vec2, "y", vec2__y, NULL);
    py_bindmethod(vec2, "with_x", vec2__with_x);
    py_bindmethod(vec2, "with_y", vec2__with_y);
    py_bindmethod(vec2, "with_z", vec2__with_z);

    /* mat3x3 */
    py_bindmagic(mat3x3, __new__, mat3x3__new__);
    py_bindmagic(mat3x3, __repr__, mat3x3__repr__);
    py_bindmagic(mat3x3, __getitem__, mat3x3__getitem__);
    py_bindmagic(mat3x3, __setitem__, mat3x3__setitem__);
    py_bindmagic(mat3x3, __matmul__, mat3x3__matmul__);
    py_bindmagic(mat3x3, __invert__, mat3x3__invert__);
    py_bindmagic(mat3x3, __eq__, mat3x3__eq__);
    py_bindmagic(mat3x3, __ne__, mat3x3__ne__);
    py_bindmethod(mat3x3, "matmul", mat3x3_matmul);
    py_bindmethod(mat3x3, "determinant", mat3x3_determinant);
    py_bindmethod(mat3x3, "copy", mat3x3_copy);
    py_bindmethod(mat3x3, "inverse", mat3x3_inverse);
    py_bindmethod(mat3x3, "copy_", mat3x3_copy_);
    py_bindmethod(mat3x3, "inverse_", mat3x3_inverse_);
    py_bindstaticmethod(mat3x3, "zeros", mat3x3_zeros_STATIC);
    py_bindstaticmethod(mat3x3, "identity", mat3x3_identity_STATIC);
    py_bindstaticmethod(mat3x3, "trs", mat3x3_trs_STATIC);
    py_bindmethod(mat3x3, "copy_trs_", mat3x3_copy_trs_);
    py_bindmethod(mat3x3, "t", mat3x3_t);
    py_bindmethod(mat3x3, "r", mat3x3_r);
    py_bindmethod(mat3x3, "s", mat3x3_s);
    py_bindmethod(mat3x3, "transform_point", mat3x3_transform_point);
    py_bindmethod(mat3x3, "transform_vector", mat3x3_transform_vector);

    /* vec2i */
    py_bindmagic(vec2i, __new__, vec2i__new__);
    py_bindmagic(vec2i, __repr__, vec2i__repr__);
    py_bindmagic(vec2i, __add__, vec2i__add__);
    py_bindmagic(vec2i, __sub__, vec2i__sub__);
    py_bindmagic(vec2i, __mul__, vec2i__mul__);
    py_bindmagic(vec2i, __floordiv__, vec2i__floordiv__);
    py_bindmagic(vec2i, __eq__, vec2i__eq__);
    py_bindmagic(vec2i, __ne__, vec2i__ne__);
    py_bindmagic(vec2i, __hash__, vec2i__hash__);
    py_bindproperty(vec2i, "x", vec2i__x, NULL);
    py_bindproperty(vec2i, "y", vec2i__y, NULL);
    py_bindmethod(vec2i, "with_x", vec2i__with_x);
    py_bindmethod(vec2i, "with_y", vec2i__with_y);
    py_bindmethod(vec2i, "dot", vec2i_dot);

    // clang-format off
    py_newvec2i(_const(vec2i, "ZERO"), (c11_vec2i){{0, 0}});
    py_newvec2i(_const(vec2i, "ONE"), (c11_vec2i){{1, 1}});
    py_newvec2i(_const(vec2i, "LEFT"), (c11_vec2i){{-1, 0}});
    py_newvec2i(_const(vec2i, "RIGHT"), (c11_vec2i){{1, 0}});
    py_newvec2i(_const(vec2i, "UP"), (c11_vec2i){{0, -1}});
    py_newvec2i(_const(vec2i, "DOWN"), (c11_vec2i){{0, 1}});
    // clang-format on

    /* vec3i */
    py_bindmagic(vec3i, __new__, vec3i__new__);
    py_bindmagic(vec3i, __repr__, vec3i__repr__);
    py_bindmagic(vec3i, __add__, vec3i__add__);
    py_bindmagic(vec3i, __sub__, vec3i__sub__);
    py_bindmagic(vec3i, __mul__, vec3i__mul__);
    py_bindmagic(vec3i, __floordiv__, vec3i__floordiv__);
    py_bindmagic(vec3i, __eq__, vec3i__eq__);
    py_bindmagic(vec3i, __ne__, vec3i__ne__);
    py_bindmagic(vec3i, __hash__, vec3i__hash__);
    py_bindproperty(vec3i, "x", vec3i__x, NULL);
    py_bindproperty(vec3i, "y", vec3i__y, NULL);
    py_bindproperty(vec3i, "z", vec3i__z, NULL);
    py_bindmethod(vec3i, "with_x", vec3i__with_x);
    py_bindmethod(vec3i, "with_y", vec3i__with_y);
    py_bindmethod(vec3i, "with_z", vec3i__with_z);
    py_bindmethod(vec3i, "dot", vec3i_dot);

    py_newvec3i(_const(vec3i, "ZERO"),
                (c11_vec3i){
                    {0, 0, 0}
    });
    py_newvec3i(_const(vec3i, "ONE"),
                (c11_vec3i){
                    {1, 1, 1}
    });

    /* vec3 */
    py_bindmagic(vec3, __new__, vec3__new__);
    py_bindmagic(vec3, __add__, vec3__add__);
    py_bindmagic(vec3, __sub__, vec3__sub__);
    py_bindmagic(vec3, __mul__, vec3__mul__);
    py_bindmagic(vec3, __truediv__, vec3__truediv__);
    py_bindmagic(vec3, __repr__, vec3__repr__);
    py_bindmagic(vec3, __eq__, vec3__eq__);
    py_bindmagic(vec3, __ne__, vec3__ne__);
    py_bindmethod(vec3, "dot", vec3_dot);
    py_bindmethod(vec3, "length", vec3_length);
    py_bindmethod(vec3, "length_squared", vec3_length_squared);
    py_bindmethod(vec3, "normalize", vec3_normalize);
    py_bindproperty(vec3, "x", vec3__x, NULL);
    py_bindproperty(vec3, "y", vec3__y, NULL);
    py_bindproperty(vec3, "z", vec3__z, NULL);
    py_bindproperty(vec3, "xy", vec3__xy, NULL);
    py_bindmethod(vec3, "with_x", vec3__with_x);
    py_bindmethod(vec3, "with_y", vec3__with_y);
    py_bindmethod(vec3, "with_z", vec3__with_z);
    py_bindmethod(vec3, "with_xy", vec3__with_xy);

    py_newvec3(_const(vec3, "ZERO"),
               (c11_vec3){
                   {0, 0, 0}
    });
    py_newvec3(_const(vec3, "ONE"),
               (c11_vec3){
                   {1, 1, 1}
    });
}

#undef DEFINE_VEC_FIELD
#undef DEFINE_BOOL_NE
#undef DEF_VECTOR_ELEMENT_WISE
#undef DEF_VECTOR_OPS
#undef DEF_VECTOR_INT_OPS
// src/modules/pickle.c
#include <stdint.h>

typedef enum {
    // clang-format off
    PKL_MEMO_GET,
    PKL_MEMO_SET,
    PKL_NIL, PKL_NONE, PKL_ELLIPSIS,
    PKL_INT_0, PKL_INT_1, PKL_INT_2, PKL_INT_3, PKL_INT_4, PKL_INT_5, PKL_INT_6, PKL_INT_7,
    PKL_INT_8, PKL_INT_9, PKL_INT_10, PKL_INT_11, PKL_INT_12, PKL_INT_13, PKL_INT_14, PKL_INT_15,
    PKL_INT8, PKL_INT16, PKL_INT32, PKL_INT64,
    PKL_FLOAT32, PKL_FLOAT64,
    PKL_TRUE, PKL_FALSE,
    PKL_STRING, PKL_BYTES,
    PKL_BUILD_LIST,
    PKL_BUILD_TUPLE,
    PKL_BUILD_DICT,
    PKL_VEC2, PKL_VEC3,
    PKL_VEC2I, PKL_VEC3I,
    PKL_TYPE,
    PKL_ARRAY2D,
    PKL_TVALUE,
    PKL_CALL,
    PKL_OBJECT,
    PKL_EOF,
    // clang-format on
} PickleOp;

typedef struct {
    bool* used_types;
    int used_types_length;
    c11_smallmap_p2i memo;
    c11_vector /*T=char*/ codes;
} PickleObject;

static void PickleObject__ctor(PickleObject* self) {
    self->used_types_length = pk_current_vm->types.length;
    self->used_types = PK_MALLOC(self->used_types_length);
    memset(self->used_types, 0, self->used_types_length);
    c11_smallmap_p2i__ctor(&self->memo);
    c11_vector__ctor(&self->codes, sizeof(char));
}

static void PickleObject__dtor(PickleObject* self) {
    PK_FREE(self->used_types);
    c11_smallmap_p2i__dtor(&self->memo);
    c11_vector__dtor(&self->codes);
}

static bool PickleObject__py_submit(PickleObject* self, py_OutRef out);

static void PickleObject__write_bytes(PickleObject* buf, const void* data, int size) {
    c11_vector__extend(char, &buf->codes, data, size);
}

static void c11_sbuf__write_type_path(c11_sbuf* path_buf, py_Type type) {
    py_TypeInfo* ti = pk__type_info(type);
    if(py_isnil(&ti->module)) {
        c11_sbuf__write_cstr(path_buf, py_name2str(ti->name));
        return;
    }
    const char* mod_path = py_tostr(py_getdict(&ti->module, __path__));
    c11_sbuf__write_cstr(path_buf, mod_path);
    c11_sbuf__write_char(path_buf, '.');
    c11_sbuf__write_cstr(path_buf, py_name2str(ti->name));
}

static void pkl__emit_op(PickleObject* buf, PickleOp op) {
    c11_vector__push(char, &buf->codes, op);
}

static void pkl__emit_int(PickleObject* buf, py_i64 val) {
    if(val >= 0 && val <= 15) {
        pkl__emit_op(buf, PKL_INT_0 + val);
        return;
    }
    if(INT8_MIN <= val && val <= INT8_MAX) {
        pkl__emit_op(buf, PKL_INT8);
        PickleObject__write_bytes(buf, &val, 1);
    } else if(INT16_MIN <= val && val <= INT16_MAX) {
        pkl__emit_op(buf, PKL_INT16);
        PickleObject__write_bytes(buf, &val, 2);
    } else if(INT32_MIN <= val && val <= INT32_MAX) {
        pkl__emit_op(buf, PKL_INT32);
        PickleObject__write_bytes(buf, &val, 4);
    } else {
        pkl__emit_op(buf, PKL_INT64);
        PickleObject__write_bytes(buf, &val, 8);
    }
}

#define UNALIGNED_READ(p_val, p_buf)                                                               \
    do {                                                                                           \
        memcpy((p_val), (p_buf), sizeof(*(p_val)));                                                \
        (p_buf) += sizeof(*(p_val));                                                               \
    } while(0)

static py_i64 pkl__read_int(const unsigned char** p) {
    PickleOp op = (PickleOp) * *p;
    (*p)++;
    switch(op) {
            // clang-format off
        case PKL_INT_0: return 0; case PKL_INT_1: return 1; case PKL_INT_2: return 2; case PKL_INT_3: return 3;
        case PKL_INT_4: return 4; case PKL_INT_5: return 5; case PKL_INT_6: return 6; case PKL_INT_7: return 7;
        case PKL_INT_8: return 8; case PKL_INT_9: return 9; case PKL_INT_10: return 10; case PKL_INT_11: return 11;
        case PKL_INT_12: return 12; case PKL_INT_13: return 13; case PKL_INT_14: return 14; case PKL_INT_15: return 15;
        // clang-format on
        case PKL_INT8: {
            int8_t val;
            UNALIGNED_READ(&val, *p);
            return val;
        }
        case PKL_INT16: {
            int16_t val;
            UNALIGNED_READ(&val, *p);
            return val;
        }
        case PKL_INT32: {
            int32_t val;
            UNALIGNED_READ(&val, *p);
            return val;
        }
        case PKL_INT64: {
            int64_t val;
            UNALIGNED_READ(&val, *p);
            return val;
        }
        default: c11__abort("pkl__read_int(): invalid op: %d", op);
    }
}

static bool pickle_loads(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_bytes);
    int size;
    const unsigned char* data = py_tobytes(argv, &size);
    return py_pickle_loads(data, size);
}

static bool pickle_dumps(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    return py_pickle_dumps(argv);
}

void pk__add_module_pickle() {
    py_Ref mod = py_newmodule("pickle");

    py_bindfunc(mod, "loads", pickle_loads);
    py_bindfunc(mod, "dumps", pickle_dumps);
}

static bool pkl__write_object(PickleObject* buf, py_TValue* obj);

static bool pkl__write_array(PickleObject* buf, PickleOp op, py_TValue* arr, int length) {
    for(int i = 0; i < length; i++) {
        bool ok = pkl__write_object(buf, arr + i);
        if(!ok) return false;
    }
    pkl__emit_op(buf, op);
    pkl__emit_int(buf, length);
    return true;
}

static bool pkl__write_dict_kv(py_Ref k, py_Ref v, void* ctx) {
    PickleObject* buf = (PickleObject*)ctx;
    if(!pkl__write_object(buf, k)) return false;
    if(!pkl__write_object(buf, v)) return false;
    return true;
}

static bool pkl__try_memo(PickleObject* buf, PyObject* memo_key) {
    int index = c11_smallmap_p2i__get(&buf->memo, memo_key, -1);
    if(index != -1) {
        pkl__emit_op(buf, PKL_MEMO_GET);
        pkl__emit_int(buf, index);
        return true;
    }
    return false;
}

static void pkl__store_memo(PickleObject* buf, PyObject* memo_key) {
    int index = buf->memo.length;
    c11_smallmap_p2i__set(&buf->memo, memo_key, index);
    pkl__emit_op(buf, PKL_MEMO_SET);
    pkl__emit_int(buf, index);
}

static bool pkl__write_object(PickleObject* buf, py_TValue* obj) {
    switch(obj->type) {
        case tp_nil: {
            return ValueError("'nil' object is not picklable");
        }
        case tp_NoneType: {
            pkl__emit_op(buf, PKL_NONE);
            return true;
        }
        case tp_ellipsis: {
            pkl__emit_op(buf, PKL_ELLIPSIS);
            return true;
        }
        case tp_int: {
            py_i64 val = obj->_i64;
            pkl__emit_int(buf, val);
            return true;
        }
        case tp_float: {
            py_f64 val = obj->_f64;
            float val32 = (float)val;
            if(val == val32) {
                pkl__emit_op(buf, PKL_FLOAT32);
                PickleObject__write_bytes(buf, &val32, 4);
            } else {
                pkl__emit_op(buf, PKL_FLOAT64);
                PickleObject__write_bytes(buf, &val, 8);
            }
            return true;
        }
        case tp_bool: {
            bool val = obj->_bool;
            pkl__emit_op(buf, val ? PKL_TRUE : PKL_FALSE);
            return true;
        }
        case tp_str: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                pkl__emit_op(buf, PKL_STRING);
                c11_sv sv = py_tosv(obj);
                pkl__emit_int(buf, sv.size);
                PickleObject__write_bytes(buf, sv.data, sv.size);
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        case tp_bytes: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                pkl__emit_op(buf, PKL_BYTES);
                int size;
                unsigned char* data = py_tobytes(obj, &size);
                pkl__emit_int(buf, size);
                PickleObject__write_bytes(buf, data, size);
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        case tp_list: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                bool ok =
                    pkl__write_array(buf, PKL_BUILD_LIST, py_list_data(obj), py_list_len(obj));
                if(!ok) return false;
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        case tp_tuple: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                bool ok =
                    pkl__write_array(buf, PKL_BUILD_TUPLE, py_tuple_data(obj), py_tuple_len(obj));
                if(!ok) return false;
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        case tp_dict: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                bool ok = py_dict_apply(obj, pkl__write_dict_kv, (void*)buf);
                if(!ok) return false;
                pkl__emit_op(buf, PKL_BUILD_DICT);
                pkl__emit_int(buf, py_dict_len(obj));
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        case tp_vec2: {
            c11_vec2 val = py_tovec2(obj);
            pkl__emit_op(buf, PKL_VEC2);
            PickleObject__write_bytes(buf, &val, sizeof(c11_vec2));
            return true;
        }
        case tp_vec3: {
            c11_vec3 val = py_tovec3(obj);
            pkl__emit_op(buf, PKL_VEC3);
            PickleObject__write_bytes(buf, &val, sizeof(c11_vec3));
            return true;
        }
        case tp_vec2i: {
            c11_vec2i val = py_tovec2i(obj);
            pkl__emit_op(buf, PKL_VEC2I);
            pkl__emit_int(buf, val.x);
            pkl__emit_int(buf, val.y);
            return true;
        }
        case tp_vec3i: {
            c11_vec3i val = py_tovec3i(obj);
            pkl__emit_op(buf, PKL_VEC3I);
            pkl__emit_int(buf, val.x);
            pkl__emit_int(buf, val.y);
            pkl__emit_int(buf, val.z);
            return true;
        }
        case tp_type: {
            pkl__emit_op(buf, PKL_TYPE);
            py_Type type = py_totype(obj);
            buf->used_types[type] = true;
            pkl__emit_int(buf, type);
            return true;
        }
        case tp_array2d: {
            if(pkl__try_memo(buf, obj->_obj))
                return true;
            else {
                c11_array2d* arr = py_touserdata(obj);
                for(int i = 0; i < arr->header.numel; i++) {
                    if(arr->data[i].is_ptr)
                        return TypeError(
                            "'array2d' object is not picklable because it contains heap-allocated objects");
                    buf->used_types[arr->data[i].type] = true;
                }
                pkl__emit_op(buf, PKL_ARRAY2D);
                pkl__emit_int(buf, arr->header.n_cols);
                pkl__emit_int(buf, arr->header.n_rows);
                PickleObject__write_bytes(buf, arr->data, arr->header.numel * sizeof(py_TValue));
            }
            pkl__store_memo(buf, obj->_obj);
            return true;
        }
        default: {
            if(!obj->is_ptr) {
                pkl__emit_op(buf, PKL_TVALUE);
                PickleObject__write_bytes(buf, obj, sizeof(py_TValue));
                buf->used_types[obj->type] = true;
                return true;
            }
            // try memo for `is_ptr=true` objects
            if(pkl__try_memo(buf, obj->_obj)) return true;

            py_TypeInfo* ti = pk__type_info(obj->type);
            py_Ref f_reduce = py_tpfindmagic(obj->type, __reduce__);
            if(f_reduce != NULL) {
                if(!py_call(f_reduce, 1, obj)) return false;
                // expected: (callable, args)
                py_Ref reduced = py_retval();
                if(!py_istuple(reduced)) { return TypeError("__reduce__ must return a tuple"); }
                if(py_tuple_len(reduced) != 2) {
                    return TypeError("__reduce__ must return a tuple of length 2");
                }
                if(!pkl__write_object(buf, py_tuple_getitem(reduced, 0))) return false;
                pkl__emit_op(buf, PKL_NIL);
                py_Ref args_tuple = py_tuple_getitem(reduced, 1);
                int args_length = py_tuple_len(args_tuple);
                for(int i = 0; i < args_length; i++) {
                    if(!pkl__write_object(buf, py_tuple_getitem(args_tuple, i))) return false;
                }
                pkl__emit_op(buf, PKL_CALL);
                pkl__emit_int(buf, args_length);
                // store memo
                pkl__store_memo(buf, obj->_obj);
                return true;
            }
            if(ti->is_python) {
                NameDict* dict = PyObject__dict(obj->_obj);
                for(int i = dict->length - 1; i >= 0; i--) {
                    NameDict_KV* kv = c11__at(NameDict_KV, dict, i);
                    if(!pkl__write_object(buf, &kv->value)) return false;
                }
                pkl__emit_op(buf, PKL_OBJECT);
                pkl__emit_int(buf, obj->type);
                buf->used_types[obj->type] = true;
                pkl__emit_int(buf, dict->length);
                for(int i = 0; i < dict->length; i++) {
                    NameDict_KV* kv = c11__at(NameDict_KV, dict, i);
                    c11_sv field = py_name2sv(kv->key);
                    // include '\0'
                    PickleObject__write_bytes(buf, field.data, field.size + 1);
                }

                // store memo
                pkl__store_memo(buf, obj->_obj);
                return true;
            }
            return TypeError("'%t' object is not picklable", obj->type);
        }
    }
    c11__unreachable();
}

bool py_pickle_dumps(py_Ref val) {
    PickleObject buf;
    PickleObject__ctor(&buf);
    bool ok = pkl__write_object(&buf, val);
    if(!ok) {
        PickleObject__dtor(&buf);
        return false;
    }
    pkl__emit_op(&buf, PKL_EOF);
    return PickleObject__py_submit(&buf, py_retval());
}

static py_Type pkl__header_find_type(c11_sv path) {
    int sep_index = c11_sv__rindex(path, '.');
    if(sep_index == -1) return py_gettype(NULL, py_namev(path));
    c11_sv mod_name = c11_sv__slice2(path, 0, sep_index);
    c11_sv name = c11_sv__slice(path, sep_index + 1);
    char buf[PK_MAX_MODULE_PATH_LEN + 1];
    memcpy(buf, mod_name.data, mod_name.size);
    buf[mod_name.size] = '\0';
    return py_gettype(buf, py_namev(name));
}

static c11_sv pkl__header_read_sv(const unsigned char** p, char sep) {
    c11_sv text;
    text.data = (const char*)*p;
    const char* p_end = strchr(text.data, sep);
    assert(p_end != NULL);
    text.size = p_end - text.data;
    *p = (const unsigned char*)p_end + 1;
    return text;
}

static py_i64 pkl__header_read_int(const unsigned char** p, char sep) {
    c11_sv text = pkl__header_read_sv(p, sep);
    py_i64 out;
    IntParsingResult res = c11__parse_uint(text, &out, 10);
    assert(res == IntParsing_SUCCESS);
    return out;
}

bool py_pickle_loads_body(const unsigned char* p, int memo_length, c11_smallmap_n2i* type_mapping);

bool py_pickle_loads(const unsigned char* data, int size) {
    const unsigned char* p = data;

    // \xf0\x9f\xa5\x95
    if(size < 4 || p[0] != 240 || p[1] != 159 || p[2] != 165 || p[3] != 149)
        return ValueError("invalid pickle data");
    p += 4;

    c11_smallmap_n2i type_mapping;
    c11_smallmap_n2i__ctor(&type_mapping);

    while(true) {
        if(*p == '\n') {
            p++;
            break;
        }
        py_Type type = pkl__header_read_int(&p, '(');
        c11_sv path = pkl__header_read_sv(&p, ')');
        py_Type new_type = pkl__header_find_type(path);
        if(new_type == 0) {
            c11_smallmap_n2i__dtor(&type_mapping);
            return ImportError("cannot find type '%v'", path);
        }
        if(type != new_type) c11_smallmap_n2i__set(&type_mapping, type, new_type);
    }

    int memo_length = pkl__header_read_int(&p, '\n');
    bool ok = py_pickle_loads_body(p, memo_length, &type_mapping);
    c11_smallmap_n2i__dtor(&type_mapping);
    return ok;
}

static py_Type pkl__fix_type(py_Type type, c11_smallmap_n2i* type_mapping) {
    int new_type = c11_smallmap_n2i__get(type_mapping, type, -1);
    if(new_type != -1) return (py_Type)new_type;
    return type;
}

bool py_pickle_loads_body(const unsigned char* p, int memo_length, c11_smallmap_n2i* type_mapping) {
    py_StackRef p0 = py_peek(0);
    py_Ref p_memo = py_newtuple(py_pushtmp(), memo_length);
    while(true) {
        PickleOp op = (PickleOp)*p;
        p++;
        switch(op) {
            case PKL_MEMO_GET: {
                int index = pkl__read_int(&p);
                py_Ref val = &p_memo[index];
                assert(!py_isnil(val));
                py_push(val);
                break;
            }
            case PKL_MEMO_SET: {
                int index = pkl__read_int(&p);
                p_memo[index] = *py_peek(-1);
                break;
            }
            case PKL_NIL: {
                py_pushnil();
                break;
            }
            case PKL_NONE: {
                py_pushnone();
                break;
            }
            case PKL_ELLIPSIS: {
                py_newellipsis(py_pushtmp());
                break;
            }
                // clang-format off
            case PKL_INT_0: case PKL_INT_1: case PKL_INT_2: case PKL_INT_3:
            case PKL_INT_4: case PKL_INT_5: case PKL_INT_6: case PKL_INT_7:
            case PKL_INT_8: case PKL_INT_9: case PKL_INT_10: case PKL_INT_11:
            case PKL_INT_12: case PKL_INT_13: case PKL_INT_14: case PKL_INT_15: {
                py_newint(py_pushtmp(), op - PKL_INT_0);
                break;
            }
            // clang-format on
            case PKL_INT8: {
                int8_t val;
                UNALIGNED_READ(&val, p);
                py_newint(py_pushtmp(), val);
                break;
            }
            case PKL_INT16: {
                int16_t val;
                UNALIGNED_READ(&val, p);
                py_newint(py_pushtmp(), val);
                break;
            }
            case PKL_INT32: {
                int32_t val;
                UNALIGNED_READ(&val, p);
                py_newint(py_pushtmp(), val);
                break;
            }
            case PKL_INT64: {
                int64_t val;
                UNALIGNED_READ(&val, p);
                py_newint(py_pushtmp(), val);
                break;
            }
            case PKL_FLOAT32: {
                float val;
                UNALIGNED_READ(&val, p);
                py_newfloat(py_pushtmp(), val);
                break;
            }
            case PKL_FLOAT64: {
                double val;
                UNALIGNED_READ(&val, p);
                py_newfloat(py_pushtmp(), val);
                break;
            }
            case PKL_TRUE: {
                py_newbool(py_pushtmp(), true);
                break;
            }
            case PKL_FALSE: {
                py_newbool(py_pushtmp(), false);
                break;
            }
            case PKL_STRING: {
                int size = pkl__read_int(&p);
                char* dst = py_newstrn(py_pushtmp(), size);
                memcpy(dst, p, size);
                p += size;
                break;
            }
            case PKL_BYTES: {
                int size = pkl__read_int(&p);
                unsigned char* dst = py_newbytes(py_pushtmp(), size);
                memcpy(dst, p, size);
                p += size;
                break;
            }
            case PKL_BUILD_LIST: {
                int length = pkl__read_int(&p);
                py_OutRef val = py_retval();
                py_newlistn(val, length);
                for(int i = length - 1; i >= 0; i--) {
                    py_StackRef item = py_peek(-1);
                    py_list_setitem(val, i, item);
                    py_pop();
                }
                py_push(val);
                break;
            }
            case PKL_BUILD_TUPLE: {
                int length = pkl__read_int(&p);
                py_OutRef val = py_retval();
                py_Ref p = py_newtuple(val, length);
                for(int i = length - 1; i >= 0; i--) {
                    p[i] = *py_peek(-1);
                    py_pop();
                }
                py_push(val);
                break;
            }
            case PKL_BUILD_DICT: {
                int length = pkl__read_int(&p);
                py_OutRef val = py_pushtmp();
                py_newdict(val);
                py_StackRef begin = py_peek(-1) - 2 * length;
                py_StackRef end = py_peek(-1);
                for(py_StackRef i = begin; i < end; i += 2) {
                    py_StackRef k = i;
                    py_StackRef v = i + 1;
                    bool ok = py_dict_setitem(val, k, v);
                    if(!ok) return false;
                }
                py_assign(py_retval(), val);
                py_shrink(2 * length + 1);
                py_push(py_retval());
                break;
            }
            case PKL_VEC2: {
                c11_vec2 val;
                UNALIGNED_READ(&val, p);
                py_newvec2(py_pushtmp(), val);
                break;
            }
            case PKL_VEC3: {
                c11_vec3 val;
                UNALIGNED_READ(&val, p);
                py_newvec3(py_pushtmp(), val);
                break;
            }
            case PKL_VEC2I: {
                c11_vec2i val;
                val.x = pkl__read_int(&p);
                val.y = pkl__read_int(&p);
                py_newvec2i(py_pushtmp(), val);
                break;
            }
            case PKL_VEC3I: {
                c11_vec3i val;
                val.x = pkl__read_int(&p);
                val.y = pkl__read_int(&p);
                val.z = pkl__read_int(&p);
                py_newvec3i(py_pushtmp(), val);
                break;
            }
            case PKL_TYPE: {
                py_Type type = (py_Type)pkl__read_int(&p);
                type = pkl__fix_type(type, type_mapping);
                py_push(py_tpobject(type));
                break;
            }
            case PKL_ARRAY2D: {
                int n_cols = pkl__read_int(&p);
                int n_rows = pkl__read_int(&p);
                c11_array2d* arr = py_newarray2d(py_pushtmp(), n_cols, n_rows);
                int total_size = arr->header.numel * sizeof(py_TValue);
                memcpy(arr->data, p, total_size);
                for(int i = 0; i < arr->header.numel; i++) {
                    arr->data[i].type = pkl__fix_type(arr->data[i].type, type_mapping);
                }
                p += total_size;
                break;
            }
            case PKL_TVALUE: {
                py_TValue* tmp = py_pushtmp();
                memcpy(tmp, p, sizeof(py_TValue));
                tmp->type = pkl__fix_type(tmp->type, type_mapping);
                p += sizeof(py_TValue);
                break;
            }
            case PKL_CALL: {
                int argc = pkl__read_int(&p);
                if(!py_vectorcall(argc, 0)) return false;
                py_push(py_retval());
                break;
            }
            case PKL_OBJECT: {
                py_Type type = (py_Type)pkl__read_int(&p);
                type = pkl__fix_type(type, type_mapping);
                py_newobject(py_retval(), type, -1, 0);
                NameDict* dict = PyObject__dict(py_retval()->_obj);
                int dict_length = pkl__read_int(&p);
                for(int i = 0; i < dict_length; i++) {
                    py_StackRef value = py_peek(-1);
                    c11_sv field = {(const char*)p, strlen((const char*)p)};
                    NameDict__set(dict, py_namev(field), *value);
                    py_pop();
                    p += field.size + 1;
                }
                py_push(py_retval());
                break;
            }
            case PKL_EOF: {
                // [memo, obj]
                if(py_peek(0) - p0 != 2) return ValueError("invalid pickle data");
                py_assign(py_retval(), py_peek(-1));
                py_shrink(2);
                return true;
            }
            default: c11__unreachable();
        }
    }
    c11__unreachable();
}

static bool PickleObject__py_submit(PickleObject* self, py_OutRef out) {
    c11_sbuf cleartext;
    c11_sbuf__ctor(&cleartext);
    c11_sbuf__write_cstr(&cleartext, "\xf0\x9f\xa5\x95");
    // line 1: type mapping
    for(py_Type type = 0; type < self->used_types_length; type++) {
        if(self->used_types[type]) {
            c11_sbuf__write_int(&cleartext, type);
            c11_sbuf__write_char(&cleartext, '(');
            c11_sbuf__write_type_path(&cleartext, type);
            c11_sbuf__write_char(&cleartext, ')');
        }
    }
    c11_sbuf__write_char(&cleartext, '\n');
    // line 2: memo length
    c11_sbuf__write_int(&cleartext, self->memo.length);
    c11_sbuf__write_char(&cleartext, '\n');
    // -------------------------------------------------- //
    c11_string* header = c11_sbuf__submit(&cleartext);
    int total_size = header->size + self->codes.length;
    unsigned char* p = py_newbytes(py_retval(), total_size);
    memcpy(p, header->data, header->size);
    memcpy(p + header->size, self->codes.data, self->codes.length);
    c11_string__delete(header);
    PickleObject__dtor(self);
    return true;
}

#undef UNALIGNED_READ

// src/modules/traceback.c
#include <stdlib.h>

static bool traceback_format_exc(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    char* s = py_formatexc();
    if(!s) {
        py_newnone(py_retval());
    } else {
        py_newstr(py_retval(), s);
        PK_FREE(s);
    }
    return true;
}

static bool traceback_print_exc(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    py_printexc();
    py_newnone(py_retval());
    return true;
}

void pk__add_module_traceback() {
    py_Ref mod = py_newmodule("traceback");

    py_bindfunc(mod, "format_exc", traceback_format_exc);
    py_bindfunc(mod, "print_exc", traceback_print_exc);
}
// src/modules/inspect.c
static bool inspect_isgeneratorfunction(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_Ref obj = argv;
    if(py_istype(argv, tp_boundmethod)) {
        py_TValue* slots = PyObject__slots(argv->_obj);
        obj = &slots[1];  // callable
    }
    if(py_istype(obj, tp_function)) {
        Function* fn = py_touserdata(obj);
        py_newbool(py_retval(), fn->decl->type == FuncType_GENERATOR);
    } else {
        py_newbool(py_retval(), false);
    }
    return true;
}

void pk__add_module_inspect() {
    py_Ref mod = py_newmodule("inspect");

    py_bindfunc(mod, "isgeneratorfunction", inspect_isgeneratorfunction);
}
// src/modules/random.c
#include <time.h>

int64_t time_ns();  // from random.c

/* https://github.com/clibs/mt19937ar

Copyright (c) 2011 Mutsuo Saito, Makoto Matsumoto, Hiroshima
University and The University of Tokyo. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of the Hiroshima University nor the names of
      its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

typedef struct mt19937 {
    uint32_t mt[N]; /* the array for the state vector  */
    int mti;        /* mti==N+1 means mt[N] is not initialized */
} mt19937;

/* initializes mt[N] with a seed */
static void mt19937__seed(mt19937* self, uint32_t s) {
    self->mt[0] = s & 0xffffffffUL;
    for(self->mti = 1; self->mti < N; self->mti++) {
        self->mt[self->mti] =
            (1812433253UL * (self->mt[self->mti - 1] ^ (self->mt[self->mti - 1] >> 30)) +
             self->mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        self->mt[self->mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

static void mt19937__ctor(mt19937* self) { self->mti = N + 1; }

/* generates a random number on [0,0xffffffff]-interval */
static uint32_t mt19937__next_uint32(mt19937* self) {
    uint32_t* mt = self->mt;
    uint32_t y;
    static uint32_t mag01[2] = {0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if(self->mti >= N) { /* generate N words at one time */
        int kk;

        if(self->mti == N + 1) { /* if init_genrand() has not been called, */
            int64_t seed = time_ns();
            mt19937__seed(self, (uint32_t)seed);
            // seed(5489UL); /* a default initial seed is used */
        }

        for(kk = 0; kk < N - M; kk++) {
            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
            mt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for(; kk < N - 1; kk++) {
            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
            mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
        mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        self->mti = 0;
    }

    y = mt[self->mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

static uint64_t mt19937__next_uint64(mt19937* self) {
    return (uint64_t)mt19937__next_uint32(self) << 32 | mt19937__next_uint32(self);
}

static double mt19937__random(mt19937* self) {
    // from cpython
    uint32_t a = mt19937__next_uint32(self) >> 5;
    uint32_t b = mt19937__next_uint32(self) >> 6;
    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
}

static double mt19937__uniform(mt19937* self, double a, double b) {
    if(a > b) { return b + mt19937__random(self) * (a - b); }
    return a + mt19937__random(self) * (b - a);
}

/* generates a random number on [a, b]-interval */
int64_t mt19937__randint(mt19937* self, int64_t a, int64_t b) {
    uint64_t delta = b - a + 1;
    if(delta < 0x80000000UL) {
        return a + mt19937__next_uint32(self) % delta;
    } else {
        return a + mt19937__next_uint64(self) % delta;
    }
}

static bool Random__new__(int argc, py_Ref argv) {
    mt19937* ud = py_newobject(py_retval(), py_totype(argv), 0, sizeof(mt19937));
    mt19937__ctor(ud);
    return true;
}

static bool Random__init__(int argc, py_Ref argv) {
    if(argc == 1) {
        // do nothing
    } else if(argc == 2) {
        mt19937* ud = py_touserdata(py_arg(0));
        if(!py_isnone(&argv[1])){
            PY_CHECK_ARG_TYPE(1, tp_int);
            py_i64 seed = py_toint(py_arg(1));
            mt19937__seed(ud, (uint32_t)seed);
        }
    } else {
        return TypeError("Random(): expected 1 or 2 arguments, got %d");
    }
    py_newnone(py_retval());
    return true;
}

static bool Random_seed(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_int);
    mt19937* ud = py_touserdata(py_arg(0));
    py_i64 seed = py_toint(py_arg(1));
    mt19937__seed(ud, seed);
    py_newnone(py_retval());
    return true;
}

static bool Random_random(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    mt19937* ud = py_touserdata(py_arg(0));
    py_f64 res = mt19937__random(ud);
    py_newfloat(py_retval(), res);
    return true;
}

static bool Random_uniform(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    mt19937* ud = py_touserdata(py_arg(0));
    py_f64 a, b;
    if(!py_castfloat(py_arg(1), &a)) return false;
    if(!py_castfloat(py_arg(2), &b)) return false;
    py_f64 res = mt19937__uniform(ud, a, b);
    py_newfloat(py_retval(), res);
    return true;
}

static bool Random_shuffle(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_list);
    mt19937* ud = py_touserdata(py_arg(0));
    py_Ref L = py_arg(1);
    int length = py_list_len(L);
    for(int i = length - 1; i > 0; i--) {
        int j = mt19937__randint(ud, 0, i);
        py_list_swap(L, i, j);
    }
    py_newnone(py_retval());
    return true;
}

static bool Random_randint(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_int);
    PY_CHECK_ARG_TYPE(2, tp_int);
    mt19937* ud = py_touserdata(py_arg(0));
    py_i64 a = py_toint(py_arg(1));
    py_i64 b = py_toint(py_arg(2));
    if(a > b) return ValueError("randint(a, b): a must be less than or equal to b");
    py_i64 res = mt19937__randint(ud, a, b);
    py_newint(py_retval(), res);
    return true;
}

static bool Random_choice(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    mt19937* ud = py_touserdata(py_arg(0));
    py_TValue* p;
    int length = pk_arrayview(py_arg(1), &p);
    if(length == -1) return TypeError("choice(): argument must be a list or tuple");
    if(length == 0) return IndexError("cannot choose from an empty sequence");
    int index = mt19937__randint(ud, 0, length - 1);
    py_assign(py_retval(), p + index);
    return true;
}

static bool Random_choices(int argc, py_Ref argv) {
    mt19937* ud = py_touserdata(py_arg(0));
    py_TValue* p;
    int length = pk_arrayview(py_arg(1), &p);
    if(length == -1) return TypeError("choices(): argument must be a list or tuple");
    if(length == 0) return IndexError("cannot choose from an empty sequence");
    py_Ref weights = py_arg(2);
    if(!py_checktype(py_arg(3), tp_int)) return false;
    py_i64 k = py_toint(py_arg(3));

    py_f64* cum_weights = PK_MALLOC(sizeof(py_f64) * length);
    if(py_isnone(weights)) {
        for(int i = 0; i < length; i++)
            cum_weights[i] = i + 1;
    } else {
        py_TValue* w;
        int wlen = pk_arrayview(weights, &w);
        if(wlen == -1) {
            PK_FREE(cum_weights);
            return TypeError("choices(): weights must be a list or tuple");
        }
        if(wlen != length) {
            PK_FREE(cum_weights);
            return ValueError("len(weights) != len(population)");
        }
        if(!py_castfloat(&w[0], &cum_weights[0])) {
            PK_FREE(cum_weights);
            return false;
        }
        for(int i = 1; i < length; i++) {
            py_f64 tmp;
            if(!py_castfloat(&w[i], &tmp)) {
                PK_FREE(cum_weights);
                return false;
            }
            cum_weights[i] = cum_weights[i - 1] + tmp;
        }
    }

    py_f64 total = cum_weights[length - 1];
    if(total <= 0) {
        PK_FREE(cum_weights);
        return ValueError("total of weights must be greater than zero");
    }

    py_newlistn(py_retval(), k);
    for(int i = 0; i < k; i++) {
        py_f64 key = mt19937__random(ud) * total;
        int index;
        c11__lower_bound(py_f64, cum_weights, length, key, c11__less, &index);
        assert(index != length);
        py_list_setitem(py_retval(), i, p + index);
    }

    PK_FREE(cum_weights);
    return true;
}

void pk__add_module_random() {
    py_Ref mod = py_newmodule("random");
    py_Type type = py_newtype("Random", tp_object, mod, NULL);

    py_bindmagic(type, __new__, Random__new__);
    py_bindmagic(type, __init__, Random__init__);
    py_bindmethod(type, "seed", Random_seed);
    py_bindmethod(type, "random", Random_random);
    py_bindmethod(type, "uniform", Random_uniform);
    py_bindmethod(type, "randint", Random_randint);
    py_bindmethod(type, "shuffle", Random_shuffle);
    py_bindmethod(type, "choice", Random_choice);
    py_bind(py_tpobject(type), "choices(self, population, weights=None, k=1)", Random_choices);

    py_Ref inst = py_pushtmp();
    if(!py_tpcall(type, 0, NULL)) goto __ERROR;
    py_assign(inst, py_retval());

#define ADD_INST_BOUNDMETHOD(name)                                                                 \
    if(!py_getattr(inst, py_name(name))) goto __ERROR;                                             \
    py_setdict(mod, py_name(name), py_retval());

    ADD_INST_BOUNDMETHOD("seed");
    ADD_INST_BOUNDMETHOD("random");
    ADD_INST_BOUNDMETHOD("uniform");
    ADD_INST_BOUNDMETHOD("randint");
    ADD_INST_BOUNDMETHOD("shuffle");
    ADD_INST_BOUNDMETHOD("choice");
    ADD_INST_BOUNDMETHOD("choices");

#undef ADD_INST_BOUNDMETHOD

    py_pop();  // pop inst
    return;

__ERROR:
    py_printexc();
    c11__abort("failed to add module random");
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK
#undef ADD_INST_BOUNDMETHOD
// src/modules/array2d.c
#include <limits.h>

static bool c11_array2d_like_is_valid(c11_array2d_like* self, int col, int row) {
    return col >= 0 && col < self->n_cols && row >= 0 && row < self->n_rows;
}

static py_Ref c11_array2d__get(c11_array2d* self, int col, int row) {
    return self->data + row * self->header.n_cols + col;
}

static bool c11_array2d__set(c11_array2d* self, int col, int row, py_Ref value) {
    self->data[row * self->header.n_cols + col] = *value;
    return true;
}

c11_array2d* py_newarray2d(py_OutRef out, int n_cols, int n_rows) {
    int numel = n_cols * n_rows;
    c11_array2d* ud = py_newobject(out, tp_array2d, numel, sizeof(c11_array2d));
    ud->header.n_cols = n_cols;
    ud->header.n_rows = n_rows;
    ud->header.numel = numel;
    ud->header.f_get = (py_Ref(*)(c11_array2d_like*, int, int))c11_array2d__get;
    ud->header.f_set = (bool (*)(c11_array2d_like*, int, int, py_Ref))c11_array2d__set;
    ud->data = py_getslot(out, 0);
    return ud;
}

/* array2d_like bindings */
static bool array2d_like_n_cols(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    py_newint(py_retval(), self->n_cols);
    return true;
}

static bool array2d_like_n_rows(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    py_newint(py_retval(), self->n_rows);
    return true;
}

static bool array2d_like_shape(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    c11_vec2i shape;
    shape.x = self->n_cols;
    shape.y = self->n_rows;
    py_newvec2i(py_retval(), shape);
    return true;
}

static bool array2d_like_numel(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    py_newint(py_retval(), self->numel);
    return true;
}

static bool array2d_like_is_valid(int argc, py_Ref argv) {
    c11_array2d_like* self = py_touserdata(argv);
    int col, row;
    if(argc == 2) {
        PY_CHECK_ARG_TYPE(1, tp_vec2i);
        c11_vec2i pos = py_tovec2i(py_arg(1));
        col = pos.x;
        row = pos.y;
    } else if(argc == 3) {
        PY_CHECK_ARG_TYPE(1, tp_int);
        PY_CHECK_ARG_TYPE(2, tp_int);
        col = py_toint(py_arg(1));
        row = py_toint(py_arg(2));
    } else {
        return TypeError("is_valid() expected 2 or 3 arguments");
    }
    py_newbool(py_retval(), c11_array2d_like_is_valid(self, col, row));
    return true;
}

static bool array2d_like_get(int argc, py_Ref argv) {
    PY_CHECK_ARG_TYPE(1, tp_int);
    PY_CHECK_ARG_TYPE(2, tp_int);
    py_Ref default_;
    c11_array2d_like* self = py_touserdata(argv);
    if(argc == 3) {
        default_ = py_None();
    } else if(argc == 4) {
        default_ = py_arg(3);
    } else {
        return TypeError("get() expected 2 or 3 arguments");
    }
    int col = py_toint(py_arg(1));
    int row = py_toint(py_arg(2));
    if(c11_array2d_like_is_valid(self, col, row)) {
        py_assign(py_retval(), self->f_get(self, col, row));
    } else {
        py_assign(py_retval(), default_);
    }
    return true;
}

static bool array2d_like_render(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_array2d_like* self = py_touserdata(argv);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!py_str(item)) return false;
            c11_sbuf__write_sv(&buf, py_tosv(py_retval()));
        }
        if(j < self->n_rows - 1) c11_sbuf__write_char(&buf, '\n');
    }
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool array2d_like_all(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!py_checkbool(item)) return false;
            if(!py_tobool(item)) {
                py_newbool(py_retval(), false);
                return true;
            }
        }
    }
    py_newbool(py_retval(), true);
    return true;
}

static bool array2d_like_any(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!py_checkbool(item)) return false;
            if(py_tobool(item)) {
                py_newbool(py_retval(), true);
                return true;
            }
        }
    }
    py_newbool(py_retval(), false);
    return true;
}

static bool array2d_like_map(int argc, py_Ref argv) {
    // def map(self, f: Callable[[T], Any]) -> 'array2d': ...
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    py_Ref f = py_arg(1);
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!py_call(f, 1, item)) return false;
            res->data[j * self->n_cols + i] = *py_retval();
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

static bool array2d_like_apply(int argc, py_Ref argv) {
    // def apply_(self, f: Callable[[T], T]) -> None: ...
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    py_Ref f = py_arg(1);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!py_call(f, 1, item)) return false;
            bool ok = self->f_set(self, i, j, py_retval());
            if(!ok) return false;
        }
    }
    py_newnone(py_retval());
    return true;
}

static bool _check_same_shape(int colA, int rowA, int colB, int rowB) {
    if(colA != colB || rowA != rowB) {
        const char* fmt = "expected the same shape: (%d, %d) != (%d, %d)";
        return ValueError(fmt, colA, rowA, colB, rowB);
    }
    return true;
}

static bool _array2d_like_check_same_shape(c11_array2d_like* self, c11_array2d_like* other) {
    return _check_same_shape(self->n_cols, self->n_rows, other->n_cols, other->n_rows);
}

static bool _array2d_like_broadcasted_zip_with(int argc, py_Ref argv, py_Name op, py_Name rop) {
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    c11_array2d_like* other;
    if(py_isinstance(py_arg(1), tp_array2d_like)) {
        other = py_touserdata(py_arg(1));
        if(!_array2d_like_check_same_shape(self, other)) return false;
    } else {
        other = NULL;
    }
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref lhs = self->f_get(self, i, j);
            py_Ref rhs;
            if(other != NULL) {
                rhs = other->f_get(other, i, j);
            } else {
                rhs = py_arg(1);  // broadcast
            }
            if(!py_binaryop(lhs, rhs, op, rop)) return false;
            c11_array2d__set(res, i, j, py_retval());
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

static bool array2d_like_zip_with(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    c11_array2d_like* self = py_touserdata(argv);
    if(!py_checkinstance(py_arg(1), tp_array2d_like)) return false;
    c11_array2d_like* other = py_touserdata(py_arg(1));
    py_Ref f = py_arg(2);
    if(!_array2d_like_check_same_shape(self, other)) return false;
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_push(f);
            py_pushnil();
            py_push(self->f_get(self, i, j));
            py_push(other->f_get(other, i, j));
            if(!py_vectorcall(2, 0)) return false;
            c11_array2d__set(res, i, j, py_retval());
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

#define DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(name, op, rop)                                            \
    static bool array2d_like##name(int argc, py_Ref argv) {                                        \
        return _array2d_like_broadcasted_zip_with(argc, argv, op, rop);                            \
    }

DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__le__, __le__, __ge__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__lt__, __lt__, __gt__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__ge__, __ge__, __le__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__gt__, __gt__, __lt__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__eq__, __eq__, __eq__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__ne__, __ne__, __ne__)

DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__add__, __add__, __radd__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__sub__, __sub__, __rsub__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__mul__, __mul__, __rmul__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__truediv__, __truediv__, __rtruediv__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__floordiv__, __floordiv__, __rfloordiv__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__mod__, __mod__, __rmod__)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__pow__, __pow__, __rpow__)

DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__and__, __and__, 0)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__or__, __or__, 0)
DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH(__xor__, __xor__, 0)

#undef DEF_ARRAY2D_LIKE__MAGIC_ZIP_WITH

static bool array2d_like__invert__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            if(!pk_callmagic(__invert__, 1, item)) return false;
            c11_array2d__set(res, i, j, py_retval());
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

static bool array2d_like_copy(int argc, py_Ref argv) {
    // def copy(self) -> 'array2d': ...
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    c11_array2d* res = py_newarray2d(py_retval(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            res->data[j * self->n_cols + i] = *item;
        }
    }
    return true;
}

static bool array2d_like_tolist(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    py_newlistn(py_retval(), self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        py_Ref row_j = py_list_getitem(py_retval(), j);
        py_newlistn(row_j, self->n_cols);
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            py_list_setitem(row_j, i, item);
        }
    }
    return true;
}

static bool array2d_like__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    c11_array2d_like_iterator* ud =
        py_newobject(py_retval(), tp_array2d_like_iterator, 1, sizeof(c11_array2d_like_iterator));
    py_setslot(py_retval(), 0, argv);  // keep the array alive
    ud->array = self;
    ud->j = 0;
    ud->i = 0;
    return true;
}

static bool array2d_like__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like* self = py_touserdata(argv);
    char buf[256];
    snprintf(buf,
             sizeof(buf),
             "%s(%d, %d)",
             py_tpname(py_typeof(argv)),
             self->n_cols,
             self->n_rows);
    py_newstr(py_retval(), buf);
    return true;
}

#define HANDLE_SLICE()                                                                             \
    int start_col, stop_col, step_col;                                                             \
    int start_row, stop_row, step_row;                                                             \
    if(!pk__parse_int_slice(x, self->n_cols, &start_col, &stop_col, &step_col)) return false;      \
    if(!pk__parse_int_slice(y, self->n_rows, &start_row, &stop_row, &step_row)) return false;      \
    if(step_col != 1 || step_row != 1) return ValueError("slice step must be 1");                  \
    int slice_width = stop_col - start_col;                                                        \
    int slice_height = stop_row - start_row;

static bool _array2d_like_IndexError(c11_array2d_like* self, int col, int row) {
    return IndexError("(%d, %d) is not a valid index of array2d_like(%d, %d)",
                      col,
                      row,
                      self->n_cols,
                      self->n_rows);
}

static py_Ref c11_array2d_view__get(c11_array2d_view* self, int col, int row) {
    return self->f_get(self->ctx, col + self->origin.x, row + self->origin.y);
}

static bool c11_array2d_view__set(c11_array2d_view* self, int col, int row, py_Ref value) {
    return self->f_set(self->ctx, col + self->origin.x, row + self->origin.y, value);
}

static c11_array2d_view* _array2d_view__new(py_OutRef out,
                                            py_Ref keepalive,
                                            int start_col,
                                            int start_row,
                                            int width,
                                            int height) {
    c11_array2d_view* res = py_newobject(out, tp_array2d_view, 1, sizeof(c11_array2d_view));
    if(width <= 0 || height <= 0) {
        ValueError("width and height must be positive");
        return NULL;
    }
    res->header.n_cols = width;
    res->header.n_rows = height;
    res->header.numel = width * height;
    res->header.f_get = (py_Ref(*)(c11_array2d_like*, int, int))c11_array2d_view__get;
    res->header.f_set = (bool (*)(c11_array2d_like*, int, int, py_Ref))c11_array2d_view__set;
    res->origin.x = start_col;
    res->origin.y = start_row;
    py_setslot(out, 0, keepalive);
    return res;
}

static bool _array2d_view(py_OutRef out,
                          py_Ref keepalive,
                          c11_array2d_like* array,
                          int start_col,
                          int start_row,
                          int width,
                          int height) {
    c11_array2d_view* res = _array2d_view__new(out, keepalive, start_col, start_row, width, height);
    if(res == NULL) return false;
    res->ctx = array;
    res->f_get = (py_Ref(*)(void*, int, int))array->f_get;
    res->f_set = (bool (*)(void*, int, int, py_Ref))array->f_set;
    return true;
}

static bool _chunked_array2d_view(py_OutRef out,
                                  py_Ref keepalive,
                                  c11_chunked_array2d* array,
                                  int start_col,
                                  int start_row,
                                  int width,
                                  int height) {
    c11_array2d_view* res = _array2d_view__new(out, keepalive, start_col, start_row, width, height);
    if(res == NULL) return false;
    res->ctx = array;
    res->f_get = (py_Ref(*)(void*, int, int))c11_chunked_array2d__get;
    res->f_set = (bool (*)(void*, int, int, py_Ref))c11_chunked_array2d__set;
    return true;
}

static bool array2d_like__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    if(argv[1].type == tp_vec2i) {
        c11_vec2i pos = py_tovec2i(&argv[1]);
        if(c11_array2d_like_is_valid(self, pos.x, pos.y)) {
            py_assign(py_retval(), self->f_get(self, pos.x, pos.y));
            return true;
        }
        return _array2d_like_IndexError(self, pos.x, pos.y);
    }

    if(py_isinstance(&argv[1], tp_array2d_like)) {
        c11_array2d_like* mask = py_touserdata(&argv[1]);
        if(!_array2d_like_check_same_shape(self, mask)) return false;
        py_newlist(py_retval());
        for(int j = 0; j < self->n_rows; j++) {
            for(int i = 0; i < self->n_cols; i++) {
                py_Ref item = self->f_get(self, i, j);
                py_Ref cond = mask->f_get(mask, i, j);
                if(!py_checkbool(cond)) return false;
                if(py_tobool(cond)) py_list_append(py_retval(), item);
            }
        }
        return true;
    }

    PY_CHECK_ARG_TYPE(1, tp_tuple);
    if(py_tuple_len(&argv[1]) != 2) return TypeError("expected a tuple of 2 elements");
    py_Ref x = py_tuple_getitem(&argv[1], 0);
    py_Ref y = py_tuple_getitem(&argv[1], 1);
    if(py_isint(x) && py_isint(y)) {
        int col = py_toint(x);
        int row = py_toint(y);
        if(c11_array2d_like_is_valid(self, col, row)) {
            py_assign(py_retval(), self->f_get(self, col, row));
            return true;
        }
        return _array2d_like_IndexError(self, col, row);
    }

    bool _1 = py_istype(x, tp_slice) && py_istype(y, tp_slice);
    bool _2 = py_istype(x, tp_int) && py_istype(y, tp_slice);
    bool _3 = py_istype(x, tp_slice) && py_istype(y, tp_int);
    if(_1 || _2 || _3) {
        HANDLE_SLICE();
        return _array2d_view(py_retval(),
                             argv,
                             self,
                             start_col,
                             start_row,
                             slice_width,
                             slice_height);
    }

    return TypeError("expected tuple[int, int] or tuple[slice, slice]");
}

static bool array2d_like__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    c11_array2d_like* self = py_touserdata(argv);
    py_Ref value = &argv[2];
    if(argv[1].type == tp_vec2i) {
        c11_vec2i pos = py_tovec2i(&argv[1]);
        if(c11_array2d_like_is_valid(self, pos.x, pos.y)) {
            bool ok = self->f_set(self, pos.x, pos.y, value);
            if(!ok) return false;
            py_newnone(py_retval());
            return true;
        }
        return _array2d_like_IndexError(self, pos.x, pos.y);
    }

    if(py_isinstance(&argv[1], tp_array2d_like)) {
        c11_array2d_like* mask = py_touserdata(&argv[1]);
        if(!_array2d_like_check_same_shape(self, mask)) return false;
        for(int j = 0; j < self->n_rows; j++) {
            for(int i = 0; i < self->n_cols; i++) {
                py_Ref cond = mask->f_get(mask, i, j);
                if(!py_checkbool(cond)) return false;
                if(py_tobool(cond)) {
                    bool ok = self->f_set(self, i, j, value);
                    if(!ok) return false;
                }
            }
        }
        py_newnone(py_retval());
        return true;
    }

    PY_CHECK_ARG_TYPE(1, tp_tuple);
    if(py_tuple_len(py_arg(1)) != 2) return TypeError("expected a tuple of 2 elements");
    py_Ref x = py_tuple_getitem(py_arg(1), 0);
    py_Ref y = py_tuple_getitem(py_arg(1), 1);
    if(py_isint(x) && py_isint(y)) {
        int col = py_toint(x);
        int row = py_toint(y);
        if(c11_array2d_like_is_valid(self, col, row)) {
            bool ok = self->f_set(self, col, row, value);
            if(!ok) return false;
            py_newnone(py_retval());
            return true;
        }
        return _array2d_like_IndexError(self, col, row);
    }

    bool _1 = py_istype(x, tp_slice) && py_istype(y, tp_slice);
    bool _2 = py_istype(x, tp_int) && py_istype(y, tp_slice);
    bool _3 = py_istype(x, tp_slice) && py_istype(y, tp_int);
    if(_1 || _2 || _3) {
        HANDLE_SLICE();
        if(py_isinstance(value, tp_array2d_like)) {
            c11_array2d_like* values = py_touserdata(value);
            if(!_check_same_shape(slice_width, slice_height, values->n_cols, values->n_rows))
                return false;
            for(int j = 0; j < slice_height; j++) {
                for(int i = 0; i < slice_width; i++) {
                    py_Ref item = values->f_get(values, i, j);
                    bool ok = self->f_set(self, start_col + i, start_row + j, item);
                    if(!ok) return false;
                }
            }
        } else {
            for(int j = 0; j < slice_height; j++) {
                for(int i = 0; i < slice_width; i++) {
                    bool ok = self->f_set(self, start_col + i, start_row + j, value);
                    if(!ok) return false;
                }
            }
        }
        py_newnone(py_retval());
        return true;
    }

    return TypeError("expected tuple[int, int] or tuple[slice, slice]");
}

// count(self, value: T) -> int
static bool array2d_like_count(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    int count = 0;
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            int code = py_equal(self->f_get(self, i, j), py_arg(1));
            if(code == -1) return false;
            count += code;
        }
    }
    py_newint(py_retval(), count);
    return true;
}

// get_bounding_rect(self, value: T) -> tuple[int, int, int, int]
static bool array2d_like_get_bounding_rect(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    c11_array2d_like* self = py_touserdata(argv);
    py_Ref value = py_arg(1);
    int left = self->n_cols;
    int top = self->n_rows;
    int right = 0;
    int bottom = 0;
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_Ref item = self->f_get(self, i, j);
            int res = py_equal(item, value);
            if(res == -1) return false;
            if(res == 1) {
                left = c11__min(left, i);
                top = c11__min(top, j);
                right = c11__max(right, i);
                bottom = c11__max(bottom, j);
            }
        }
    }
    int width = right - left + 1;
    int height = bottom - top + 1;
    if(width <= 0 || height <= 0) {
        return ValueError("value not found");
    } else {
        py_TValue* data = py_newtuple(py_retval(), 4);
        py_newint(&data[0], left);
        py_newint(&data[1], top);
        py_newint(&data[2], width);
        py_newint(&data[3], height);
    }
    return true;
}

// count_neighbors(self, value: T, neighborhood: Neighborhood) -> array2d[int]
static bool array2d_like_count_neighbors(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    c11_array2d_like* self = py_touserdata(argv);
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    py_Ref value = py_arg(1);
    const char* neighborhood = py_tostr(py_arg(2));

    const static c11_vec2i Moore[] = {
        {{-1, -1}},
        {{0, -1}},
        {{1, -1}},
        {{-1, 0}},
        {{1, 0}},
        {{-1, 1}},
        {{0, 1}},
        {{1, 1}},
    };

    const static c11_vec2i von_Neumann[] = {
        {{0, -1}},
        {{-1, 0}},
        {{1, 0}},
        {{0, 1}},
    };

    const c11_vec2i* offsets;
    int n_offsets;
    if(strcmp(neighborhood, "Moore") == 0) {
        offsets = Moore;
        n_offsets = c11__count_array(Moore);
    } else if(strcmp(neighborhood, "von Neumann") == 0) {
        offsets = von_Neumann;
        n_offsets = c11__count_array(von_Neumann);
    } else {
        return ValueError("neighborhood must be 'Moore' or 'von Neumann'");
    }
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_i64 count = 0;
            for(int k = 0; k < n_offsets; k++) {
                int x = i + offsets[k].x;
                int y = j + offsets[k].y;
                if(x >= 0 && x < self->n_cols && y >= 0 && y < self->n_rows) {
                    py_Ref item = self->f_get(self, x, y);
                    int code = py_equal(item, value);
                    if(code == -1) return false;
                    count += code;
                }
            }
            py_newint(c11_array2d__get(res, i, j), count);
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

// convolve(self: array2d_like[int], kernel: array2d_like[int], padding: int) -> array2d[int]
static bool array2d_like_convolve(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    if(!py_checkinstance(&argv[1], tp_array2d_like)) return false;
    PY_CHECK_ARG_TYPE(2, tp_int);
    c11_array2d_like* self = py_touserdata(&argv[0]);
    c11_array2d_like* kernel = py_touserdata(&argv[1]);
    int padding = py_toint(py_arg(2));
    if(kernel->n_cols != kernel->n_rows) return ValueError("kernel must be square");
    int ksize = kernel->n_cols;
    if(ksize % 2 == 0) return ValueError("kernel size must be odd");
    int ksize_half = ksize / 2;
    c11_array2d* res = py_newarray2d(py_pushtmp(), self->n_cols, self->n_rows);
    for(int j = 0; j < self->n_rows; j++) {
        for(int i = 0; i < self->n_cols; i++) {
            py_i64 sum = 0;
            for(int jj = 0; jj < ksize; jj++) {
                for(int ii = 0; ii < ksize; ii++) {
                    int x = i + ii - ksize_half;
                    int y = j + jj - ksize_half;
                    py_i64 _0, _1;
                    if(x < 0 || x >= self->n_cols || y < 0 || y >= self->n_rows) {
                        _0 = padding;
                    } else {
                        py_Ref item = self->f_get(self, x, y);
                        if(!py_checkint(item)) return false;
                        _0 = py_toint(item);
                    }
                    py_Ref kitem = kernel->f_get(kernel, ii, jj);
                    if(!py_checkint(kitem)) return false;
                    _1 = py_toint(kitem);
                    sum += _0 * _1;
                }
            }
            py_newint(c11_array2d__get(res, i, j), sum);
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

#undef HANDLE_SLICE

static void register_array2d_like(py_Ref mod) {
    py_Type type = py_newtype("array2d_like", tp_object, mod, NULL);
    assert(type == tp_array2d_like);

    py_bindproperty(type, "n_cols", array2d_like_n_cols, NULL);
    py_bindproperty(type, "n_rows", array2d_like_n_rows, NULL);
    py_bindproperty(type, "width", array2d_like_n_cols, NULL);
    py_bindproperty(type, "height", array2d_like_n_rows, NULL);
    py_bindproperty(type, "shape", array2d_like_shape, NULL);
    py_bindproperty(type, "numel", array2d_like_numel, NULL);

    py_bindmethod(type, "is_valid", array2d_like_is_valid);
    py_bindmethod(type, "get", array2d_like_get);

    py_bindmethod(type, "render", array2d_like_render);

    py_bindmethod(type, "all", array2d_like_all);
    py_bindmethod(type, "any", array2d_like_any);

    py_bindmethod(type, "map", array2d_like_map);
    py_bindmethod(type, "apply", array2d_like_apply);
    py_bindmethod(type, "zip_with", array2d_like_zip_with);
    py_bindmethod(type, "copy", array2d_like_copy);
    py_bindmethod(type, "tolist", array2d_like_tolist);

    py_bindmagic(type, __le__, array2d_like__le__);
    py_bindmagic(type, __lt__, array2d_like__lt__);
    py_bindmagic(type, __ge__, array2d_like__ge__);
    py_bindmagic(type, __gt__, array2d_like__gt__);
    py_bindmagic(type, __eq__, array2d_like__eq__);
    py_bindmagic(type, __ne__, array2d_like__ne__);

    py_bindmagic(type, __add__, array2d_like__add__);
    py_bindmagic(type, __sub__, array2d_like__sub__);
    py_bindmagic(type, __mul__, array2d_like__mul__);
    py_bindmagic(type, __truediv__, array2d_like__truediv__);
    py_bindmagic(type, __floordiv__, array2d_like__floordiv__);
    py_bindmagic(type, __mod__, array2d_like__mod__);
    py_bindmagic(type, __pow__, array2d_like__pow__);

    py_bindmagic(type, __and__, array2d_like__and__);
    py_bindmagic(type, __or__, array2d_like__or__);
    py_bindmagic(type, __xor__, array2d_like__xor__);
    py_bindmagic(type, __invert__, array2d_like__invert__);

    py_bindmagic(type, __iter__, array2d_like__iter__);
    py_bindmagic(type, __repr__, array2d_like__repr__);

    py_bindmagic(type, __getitem__, array2d_like__getitem__);
    py_bindmagic(type, __setitem__, array2d_like__setitem__);

    py_bindmethod(type, "count", array2d_like_count);
    py_bindmethod(type, "get_bounding_rect", array2d_like_get_bounding_rect);
    py_bindmethod(type, "count_neighbors", array2d_like_count_neighbors);
    py_bindmethod(type, "convolve", array2d_like_convolve);

    const char* scc =
        "\ndef get_connected_components(self, value: T, neighborhood: Neighborhood) -> tuple[array2d[int], int]:\n    from collections import deque\n    from linalg import vec2i\n\n    DIRS = [vec2i.LEFT, vec2i.RIGHT, vec2i.UP, vec2i.DOWN]\n    assert neighborhood in ['Moore', 'von Neumann']\n\n    if neighborhood == 'Moore':\n        DIRS.extend([\n            vec2i.LEFT+vec2i.UP,\n            vec2i.RIGHT+vec2i.UP,\n            vec2i.LEFT+vec2i.DOWN,\n            vec2i.RIGHT+vec2i.DOWN\n            ])\n\n    visited = array2d[int](self.width, self.height, default=0)\n    queue = deque()\n    count = 0\n    for y in range(self.height):\n        for x in range(self.width):\n            if visited[x, y] or self[x, y] != value:\n                continue\n            count += 1\n            queue.append((x, y))\n            visited[x, y] = count\n            while queue:\n                cx, cy = queue.popleft()\n                for dx, dy in DIRS:\n                    nx, ny = cx+dx, cy+dy\n                    if self.is_valid(nx, ny) and not visited[nx, ny] and self[nx, ny] == value:\n                        queue.append((nx, ny))\n                        visited[nx, ny] = count\n    return visited, count\n\narray2d_like.get_connected_components = get_connected_components\ndel get_connected_components\n";
    if(!py_exec(scc, "array2d.py", EXEC_MODE, mod)) {
        py_printexc();
        c11__abort("failed to execute array2d.py");
    }
}

static bool array2d_like_iterator__next__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_like_iterator* self = py_touserdata(argv);
    if(self->j >= self->array->n_rows) return StopIteration();
    py_TValue* data = py_newtuple(py_retval(), 2);
    py_newvec2i(&data[0],
                (c11_vec2i){
                    {self->i, self->j}
    });
    py_assign(&data[1], self->array->f_get(self->array, self->i, self->j));
    self->i++;
    if(self->i >= self->array->n_cols) {
        self->i = 0;
        self->j++;
    }
    return true;
}

static void register_array2d_like_iterator(py_Ref mod) {
    py_Type type = py_newtype("array2d_like_iterator", tp_object, mod, NULL);
    assert(type == tp_array2d_like_iterator);
    py_bindmagic(type, __iter__, pk_wrapper__self);
    py_bindmagic(type, __next__, array2d_like_iterator__next__);
}

static bool array2d__new__(int argc, py_Ref argv) {
    // __new__(cls, n_cols: int, n_rows: int, default: Callable[[vec2i], T] = None)
    py_Ref default_ = py_arg(3);
    PY_CHECK_ARG_TYPE(0, tp_type);
    PY_CHECK_ARG_TYPE(1, tp_int);
    PY_CHECK_ARG_TYPE(2, tp_int);
    int n_cols = argv[1]._i64;
    int n_rows = argv[2]._i64;
    if(n_cols <= 0 || n_rows <= 0) return ValueError("array2d() expected positive dimensions");
    c11_array2d* ud = py_newarray2d(py_pushtmp(), n_cols, n_rows);
    // setup initial values
    if(py_callable(default_)) {
        for(int j = 0; j < n_rows; j++) {
            for(int i = 0; i < n_cols; i++) {
                py_TValue tmp;
                py_newvec2i(&tmp,
                            (c11_vec2i){
                                {i, j}
                });
                if(!py_call(default_, 1, &tmp)) return false;
                ud->data[j * n_cols + i] = *py_retval();
            }
        }
    } else {
        for(int i = 0; i < ud->header.numel; i++) {
            ud->data[i] = *default_;
        }
    }
    py_assign(py_retval(), py_peek(-1));
    py_pop();
    return true;
}

// fromlist(data: list[list[T]]) -> array2d[T]
static bool array2d_fromlist_STATIC(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    if(!py_checktype(argv, tp_list)) return false;
    int n_rows = py_list_len(argv);
    if(n_rows == 0) return ValueError("fromlist() expected a non-empty list");
    int n_cols = -1;
    for(int j = 0; j < n_rows; j++) {
        py_Ref row_j = py_list_getitem(argv, j);
        if(!py_checktype(row_j, tp_list)) return false;
        int n_cols_j = py_list_len(row_j);
        if(n_cols == -1) {
            if(n_cols_j == 0) return ValueError("fromlist() expected a non-empty list");
            n_cols = n_cols_j;
        } else if(n_cols != n_cols_j) {
            return ValueError("fromlist() expected a list of lists with the same length");
        }
    }
    c11_array2d* res = py_newarray2d(py_retval(), n_cols, n_rows);
    for(int j = 0; j < n_rows; j++) {
        py_Ref row_j = py_list_getitem(argv, j);
        for(int i = 0; i < n_cols; i++) {
            c11_array2d__set(res, i, j, py_list_getitem(row_j, i));
        }
    }
    return true;
}

static void register_array2d(py_Ref mod) {
    py_Type type = py_newtype("array2d", tp_array2d_like, mod, NULL);
    assert(type == tp_array2d);
    py_bind(py_tpobject(type),
            "__new__(cls, n_cols: int, n_rows: int, default=None)",
            array2d__new__);
    py_bindstaticmethod(type, "fromlist", array2d_fromlist_STATIC);
}

static bool array2d_view_origin(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_array2d_view* self = py_touserdata(argv);
    py_newvec2i(py_retval(), self->origin);
    return true;
}

static void register_array2d_view(py_Ref mod) {
    py_Type type = py_newtype("array2d_view", tp_array2d_like, mod, NULL);
    assert(type == tp_array2d_view);
    py_bindproperty(type, "origin", array2d_view_origin, NULL);
}

/* chunked_array2d */
#define SMALLMAP_T__SOURCE
#define K c11_vec2i
#define V py_TValue*
#define NAME c11_chunked_array2d_chunks
#define less(a, b) (a._i64 < b._i64)
#define equal(a, b) (a._i64 == b._i64)
#if !defined(SMALLMAP_T__HEADER) && !defined(SMALLMAP_T__SOURCE)
#include "pocketpy/common/vector.h"

#define SMALLMAP_T__HEADER
#define SMALLMAP_T__SOURCE
/* Input */
#define K int
#define V float
#define NAME c11_smallmap_i2f
#endif

/* Optional Input */
#ifndef less
#define less(a, b) ((a) < (b))
#endif

#ifndef equal
#define equal(a, b) ((a) == (b))
#endif

/* Temporary macros */
#define partial_less(a, b) less((a).key, (b))
#define CONCAT(A, B) CONCAT_(A, B)
#define CONCAT_(A, B) A##B

#define KV CONCAT(NAME, _KV)
#define METHOD(name) CONCAT(NAME, CONCAT(__, name))

#ifdef SMALLMAP_T__HEADER
/* Declaration */
typedef struct {
    K key;
    V value;
} KV;

typedef c11_vector NAME;

void METHOD(ctor)(NAME* self);
void METHOD(dtor)(NAME* self);
NAME* METHOD(new)();
void METHOD(delete)(NAME* self);
void METHOD(set)(NAME* self, K key, V value);
V* METHOD(try_get)(const NAME* self, K key);
V METHOD(get)(const NAME* self, K key, V default_value);
bool METHOD(contains)(const NAME* self, K key);
bool METHOD(del)(NAME* self, K key);
void METHOD(clear)(NAME* self);

#endif

#ifdef SMALLMAP_T__SOURCE
/* Implementation */

void METHOD(ctor)(NAME* self) {
    c11_vector__ctor(self, sizeof(KV));
    c11_vector__reserve(self, 4);
}

void METHOD(dtor)(NAME* self) { c11_vector__dtor(self); }

NAME* METHOD(new)() {
    NAME* self = PK_MALLOC(sizeof(NAME));
    METHOD(ctor)(self);
    return self;
}

void METHOD(delete)(NAME* self) {
    METHOD(dtor)(self);
    PK_FREE(self);
}

void METHOD(set)(NAME* self, K key, V value) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            it->value = value;
            return;
        }
    }
    KV kv = {key, value};
    c11_vector__insert(KV, self, index, kv);
}

V* METHOD(try_get)(const NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) return &it->value;
    }
    return NULL;
}

V METHOD(get)(const NAME* self, K key, V default_value) {
    V* p = METHOD(try_get)(self, key);
    return p ? *p : default_value;
}

bool METHOD(contains)(const NAME* self, K key) { return METHOD(try_get)(self, key) != NULL; }

bool METHOD(del)(NAME* self, K key) {
    int index;
    c11__lower_bound(KV, self->data, self->length, key, partial_less, &index);
    if(index != self->length) {
        KV* it = c11__at(KV, self, index);
        if(equal(it->key, key)) {
            c11_vector__erase(KV, self, index);
            return true;
        }
    }
    return false;
}

void METHOD(clear)(NAME* self) { c11_vector__clear(self); }

#endif

/* Undefine all macros */
#undef KV
#undef METHOD
#undef CONCAT
#undef CONCAT_

#undef K
#undef V
#undef NAME
#undef less
#undef partial_less
#undef equal

#undef SMALLMAP_T__SOURCE

static py_TValue* c11_chunked_array2d__new_chunk(c11_chunked_array2d* self, c11_vec2i pos) {
#ifndef NDEBUG
    bool exists = c11_chunked_array2d_chunks__contains(&self->chunks, pos);
    assert(!exists);
#endif
    int chunk_numel = self->chunk_size * self->chunk_size + 1;
    py_TValue* data = PK_MALLOC(sizeof(py_TValue) * chunk_numel);
    if(!py_isnone(&self->context_builder)) {
        py_newvec2i(&data[0], pos);
        bool ok = py_call(&self->context_builder, 1, &data[0]);
        if(!ok) return NULL;
        data[0] = *py_retval();
    } else {
        data[0] = *py_None();
    }
    memset(&data[1], 0, sizeof(py_TValue) * (chunk_numel - 1));
    c11_chunked_array2d_chunks__set(&self->chunks, pos, data);
    self->last_visited.key = pos;
    self->last_visited.value = data;
    return data;
}

static void
    cpy11__divmod_int_uint(int a, int b_log2, int b_mask, int* restrict q, int* restrict r) {
    if(a >= 0) {
        *q = a >> b_log2;
        *r = a & b_mask;
    } else {
        *q = -1 - ((-a - 1) >> b_log2);
        *r = b_mask - ((-a - 1) & b_mask);
    }
}

static void c11_chunked_array2d__world_to_chunk(c11_chunked_array2d* self,
                                                int col,
                                                int row,
                                                c11_vec2i* restrict chunk_pos,
                                                c11_vec2i* restrict local_pos) {
    cpy11__divmod_int_uint(col,
                           self->chunk_size_log2,
                           self->chunk_size_mask,
                           &chunk_pos->x,
                           &local_pos->x);
    cpy11__divmod_int_uint(row,
                           self->chunk_size_log2,
                           self->chunk_size_mask,
                           &chunk_pos->y,
                           &local_pos->y);
}

static py_TValue* c11_chunked_array2d__parse_col_row(c11_chunked_array2d* self,
                                                     int col,
                                                     int row,
                                                     c11_vec2i* restrict chunk_pos,
                                                     c11_vec2i* restrict local_pos) {
    c11_chunked_array2d__world_to_chunk(self, col, row, chunk_pos, local_pos);
    py_TValue* data;
    if(self->last_visited.value != NULL && chunk_pos->_i64 == self->last_visited.key._i64) {
        data = self->last_visited.value;
    } else {
        data = c11_chunked_array2d_chunks__get(&self->chunks, *chunk_pos, NULL);
    }
    if(data != NULL) {
        self->last_visited.key = *chunk_pos;
        self->last_visited.value = data;
    }
    return data;
}

py_Ref c11_chunked_array2d__get(c11_chunked_array2d* self, int col, int row) {
    c11_vec2i chunk_pos, local_pos;
    py_TValue* data = c11_chunked_array2d__parse_col_row(self, col, row, &chunk_pos, &local_pos);
    if(data == NULL) return &self->default_T;
    py_Ref retval = &data[1 + local_pos.y * self->chunk_size + local_pos.x];
    if(py_isnil(retval)) return &self->default_T;
    return retval;
}

bool c11_chunked_array2d__set(c11_chunked_array2d* self, int col, int row, py_Ref value) {
    c11_vec2i chunk_pos, local_pos;
    py_TValue* data = c11_chunked_array2d__parse_col_row(self, col, row, &chunk_pos, &local_pos);
    if(data == NULL) {
        data = c11_chunked_array2d__new_chunk(self, chunk_pos);
        if(data == NULL) return false;
    }
    data[1 + local_pos.y * self->chunk_size + local_pos.x] = *value;
    return true;
}

static void c11_chunked_array2d__del(c11_chunked_array2d* self, int col, int row) {
    c11_vec2i chunk_pos, local_pos;
    py_TValue* data = c11_chunked_array2d__parse_col_row(self, col, row, &chunk_pos, &local_pos);
    if(data != NULL) data[1 + local_pos.y * self->chunk_size + local_pos.x] = *py_NIL();
}

static bool chunked_array2d__new__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(4);
    PY_CHECK_ARG_TYPE(1, tp_int);
    py_Type cls = py_totype(argv);
    c11_chunked_array2d* self = py_newobject(py_retval(), cls, 0, sizeof(c11_chunked_array2d));
    int chunk_size = py_toint(&argv[1]);
    self->default_T = argv[2];
    self->context_builder = argv[3];
    c11_chunked_array2d_chunks__ctor(&self->chunks);
    self->chunk_size = chunk_size;
    switch(chunk_size) {
        case 2: self->chunk_size_log2 = 1; break;
        case 4: self->chunk_size_log2 = 2; break;
        case 8: self->chunk_size_log2 = 3; break;
        case 16: self->chunk_size_log2 = 4; break;
        case 32: self->chunk_size_log2 = 5; break;
        case 64: self->chunk_size_log2 = 6; break;
        case 128: self->chunk_size_log2 = 7; break;
        case 256: self->chunk_size_log2 = 8; break;
        case 512: self->chunk_size_log2 = 9; break;
        case 1024: self->chunk_size_log2 = 10; break;
        case 2048: self->chunk_size_log2 = 11; break;
        case 4096: self->chunk_size_log2 = 12; break;
        default: return ValueError("invalid chunk_size: %d, not power of 2", chunk_size);
    }
    self->chunk_size_mask = chunk_size - 1;
    memset(&self->last_visited, 0, sizeof(c11_chunked_array2d_chunks_KV));
    return true;
}

static bool chunked_array2d_chunk_size(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    py_newint(py_retval(), self->chunk_size);
    return true;
}

static bool chunked_array2d_default(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    py_assign(py_retval(), &self->default_T);
    return true;
}

static bool chunked_array2d_context_builder(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    py_assign(py_retval(), &self->context_builder);
    return true;
}

static bool chunked_array2d__getitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    py_Ref res = c11_chunked_array2d__get(self, pos.x, pos.y);
    py_assign(py_retval(), res);
    return true;
}

static bool chunked_array2d__setitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    bool ok = c11_chunked_array2d__set(self, pos.x, pos.y, &argv[2]);
    if(!ok) return false;
    py_newnone(py_retval());
    return true;
}

static bool chunked_array2d__delitem__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    c11_chunked_array2d__del(self, pos.x, pos.y);
    py_newnone(py_retval());
    return true;
}

static bool chunked_array2d__iter__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    py_Ref data = py_newtuple(py_pushtmp(), self->chunks.length);
    for(int i = 0; i < self->chunks.length; i++) {
        c11_chunked_array2d_chunks_KV* kv =
            c11__at(c11_chunked_array2d_chunks_KV, &self->chunks, i);
        py_Ref p = py_newtuple(&data[i], 2);
        py_newvec2i(&p[0], kv->key);  // pos
        p[1] = kv->value[0];          // context
    }
    bool ok = py_iter(py_peek(-1));
    if(!ok) return false;
    py_pop();
    return true;
}

static bool chunked_array2d__len__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    py_newint(py_retval(), self->chunks.length);
    return true;
}

static bool chunked_array2d_clear(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_chunked_array2d_chunks__clear(&self->chunks);
    self->last_visited.value = NULL;
    py_newnone(py_retval());
    return true;
}

static bool chunked_array2d_copy(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_chunked_array2d* res =
        py_newobject(py_retval(), tp_chunked_array2d, 0, sizeof(c11_chunked_array2d));
    // copy basic data
    memcpy(res, self, sizeof(c11_chunked_array2d));
    // invalidate last_visited cache
    self->last_visited.value = NULL;
    // copy chunks
    memset(&res->chunks, 0, sizeof(c11_chunked_array2d_chunks));
    c11_chunked_array2d_chunks__ctor(&res->chunks);
    c11_vector__reserve(&res->chunks, self->chunks.capacity);
    for(int i = 0; i < self->chunks.length; i++) {
        c11_chunked_array2d_chunks_KV* kv =
            c11__at(c11_chunked_array2d_chunks_KV, &self->chunks, i);
        int chunk_numel = self->chunk_size * self->chunk_size + 1;
        py_TValue* data = PK_MALLOC(sizeof(py_TValue) * chunk_numel);
        memcpy(data, kv->value, sizeof(py_TValue) * chunk_numel);
        // construct new KV
        c11_chunked_array2d_chunks_KV new_kv;
        new_kv.key = kv->key;
        new_kv.value = data;
        c11_vector__push(c11_chunked_array2d_chunks_KV, &res->chunks, new_kv);
    }
    return true;
}

static bool chunked_array2d_world_to_chunk(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    c11_vec2i chunk_pos, local_pos;
    c11_chunked_array2d__world_to_chunk(self, pos.x, pos.y, &chunk_pos, &local_pos);
    py_TValue* p = py_newtuple(py_retval(), 2);
    py_newvec2i(&p[0], chunk_pos);
    py_newvec2i(&p[1], local_pos);
    return true;
}

static bool chunked_array2d_add_chunk(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    py_TValue* data = c11_chunked_array2d__new_chunk(self, pos);
    if(data == NULL) return false;
    py_assign(py_retval(), &data[0]);  // context
    return true;
}

static bool chunked_array2d_remove_chunk(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    bool ok = c11_chunked_array2d_chunks__del(&self->chunks, pos);
    self->last_visited.value = NULL;
    py_newbool(py_retval(), ok);
    return true;
}

static bool chunked_array2d_move_chunk(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    PY_CHECK_ARG_TYPE(2, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i src = py_tovec2i(&argv[1]);
    c11_vec2i dst = py_tovec2i(&argv[2]);
    py_TValue* src_data = c11_chunked_array2d_chunks__get(&self->chunks, src, NULL);
    py_TValue* dst_data = c11_chunked_array2d_chunks__get(&self->chunks, dst, NULL);
    if(src_data == NULL || dst_data != NULL) {
        py_newbool(py_retval(), false);
        return true;
    }
    c11_chunked_array2d_chunks__del(&self->chunks, src);
    c11_chunked_array2d_chunks__set(&self->chunks, dst, src_data);
    self->last_visited.value = NULL;
    py_newbool(py_retval(), true);
    return true;
}

static bool chunked_array2d_get_context(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(argv);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    py_TValue* data = c11_chunked_array2d_chunks__get(&self->chunks, pos, NULL);
    if(data == NULL) {
        py_newnone(py_retval());
    } else {
        py_assign(py_retval(), &data[0]);
    }
    return true;
}

void c11_chunked_array2d__dtor(c11_chunked_array2d* self) {
    c11__foreach(c11_chunked_array2d_chunks_KV, &self->chunks, p_kv) PK_FREE(p_kv->value);
    c11_chunked_array2d_chunks__dtor(&self->chunks);
}

void c11_chunked_array2d__mark(void* ud) {
    c11_chunked_array2d* self = ud;
    pk__mark_value(&self->default_T);
    pk__mark_value(&self->context_builder);
    int chunk_numel = self->chunk_size * self->chunk_size + 1;
    for(int i = 0; i < self->chunks.length; i++) {
        py_TValue* data = c11__getitem(c11_chunked_array2d_chunks_KV, &self->chunks, i).value;
        for(int j = 0; j < chunk_numel; j++) {
            pk__mark_value(data + j);
        }
    }
}

static bool chunked_array2d_view(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    c11_chunked_array2d* self = py_touserdata(&argv[0]);
    if(self->chunks.length == 0) { return ValueError("chunked_array2d is empty"); }
    int min_chunk_x = INT_MAX;
    int min_chunk_y = INT_MAX;
    int max_chunk_x = INT_MIN;
    int max_chunk_y = INT_MIN;
    for(int i = 0; i < self->chunks.length; i++) {
        c11_vec2i chunk_pos = c11__getitem(c11_chunked_array2d_chunks_KV, &self->chunks, i).key;
        min_chunk_x = c11__min(min_chunk_x, chunk_pos.x);
        min_chunk_y = c11__min(min_chunk_y, chunk_pos.y);
        max_chunk_x = c11__max(max_chunk_x, chunk_pos.x);
        max_chunk_y = c11__max(max_chunk_y, chunk_pos.y);
    }
    int start_col = min_chunk_x * self->chunk_size;
    int start_row = min_chunk_y * self->chunk_size;
    int width = (max_chunk_x - min_chunk_x + 1) * self->chunk_size;
    int height = (max_chunk_y - min_chunk_y + 1) * self->chunk_size;
    return _chunked_array2d_view(py_retval(), argv, self, start_col, start_row, width, height);
}

static bool chunked_array2d_view_rect(int argc, py_Ref argv) {
    PY_CHECK_ARGC(4);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    PY_CHECK_ARG_TYPE(2, tp_int);
    PY_CHECK_ARG_TYPE(3, tp_int);
    c11_chunked_array2d* self = py_touserdata(&argv[0]);
    c11_vec2i pos = py_tovec2i(&argv[1]);
    int width = py_toint(&argv[2]);
    int height = py_toint(&argv[3]);
    return _chunked_array2d_view(py_retval(), argv, self, pos.x, pos.y, width, height);
}

static bool chunked_array2d_view_chunk(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    c11_chunked_array2d* self = py_touserdata(&argv[0]);
    c11_vec2i chunk_pos = py_tovec2i(&argv[1]);
    int start_col = chunk_pos.x * self->chunk_size;
    int start_row = chunk_pos.y * self->chunk_size;
    return _chunked_array2d_view(py_retval(),
                                 argv,
                                 self,
                                 start_col,
                                 start_row,
                                 self->chunk_size,
                                 self->chunk_size);
}

static bool chunked_array2d_view_chunks(int argc, py_Ref argv) {
    PY_CHECK_ARGC(4);
    PY_CHECK_ARG_TYPE(1, tp_vec2i);
    PY_CHECK_ARG_TYPE(2, tp_int);
    PY_CHECK_ARG_TYPE(3, tp_int);
    c11_chunked_array2d* self = py_touserdata(&argv[0]);
    c11_vec2i chunk_pos = py_tovec2i(&argv[1]);
    int width = py_toint(&argv[2]) * self->chunk_size;
    int height = py_toint(&argv[3]) * self->chunk_size;
    int start_col = chunk_pos.x * self->chunk_size;
    int start_row = chunk_pos.y * self->chunk_size;
    return _chunked_array2d_view(py_retval(), argv, self, start_col, start_row, width, height);
}

static void register_chunked_array2d(py_Ref mod) {
    py_Type type =
        py_newtype("chunked_array2d", tp_object, mod, (py_Dtor)c11_chunked_array2d__dtor);
    assert(type == tp_chunked_array2d);

    py_bind(py_tpobject(type),
            "__new__(cls, chunk_size, default=None, context_builder=None)",
            chunked_array2d__new__);

    py_bindproperty(type, "chunk_size", chunked_array2d_chunk_size, NULL);
    py_bindproperty(type, "default", chunked_array2d_default, NULL);
    py_bindproperty(type, "context_builder", chunked_array2d_context_builder, NULL);

    py_bindmagic(type, __getitem__, chunked_array2d__getitem__);
    py_bindmagic(type, __setitem__, chunked_array2d__setitem__);
    py_bindmagic(type, __delitem__, chunked_array2d__delitem__);
    py_bindmagic(type, __iter__, chunked_array2d__iter__);
    py_bindmagic(type, __len__, chunked_array2d__len__);

    py_bindmethod(type, "clear", chunked_array2d_clear);
    py_bindmethod(type, "copy", chunked_array2d_copy);
    py_bindmethod(type, "world_to_chunk", chunked_array2d_world_to_chunk);
    py_bindmethod(type, "add_chunk", chunked_array2d_add_chunk);
    py_bindmethod(type, "remove_chunk", chunked_array2d_remove_chunk);
    py_bindmethod(type, "move_chunk", chunked_array2d_move_chunk);
    py_bindmethod(type, "get_context", chunked_array2d_get_context);

    py_bindmethod(type, "view", chunked_array2d_view);
    py_bindmethod(type, "view_rect", chunked_array2d_view_rect);
    py_bindmethod(type, "view_chunk", chunked_array2d_view_chunk);
    py_bindmethod(type, "view_chunks", chunked_array2d_view_chunks);
}

void pk__add_module_array2d() {
    py_GlobalRef mod = py_newmodule("array2d");

    register_array2d_like(mod);
    register_array2d_like_iterator(mod);
    register_array2d(mod);
    register_array2d_view(mod);
    register_chunked_array2d(mod);
}
// src/modules/easing.c
#include <math.h>

// https://easings.net/

const double kPi = 3.1415926545;

static double easeLinear(double x) { return x; }

static double easeInSine(double x) { return 1.0 - cos(x * kPi / 2); }

static double easeOutSine(double x) { return sin(x * kPi / 2); }

static double easeInOutSine(double x) { return -(cos(kPi * x) - 1) / 2; }

static double easeInQuad(double x) { return x * x; }

static double easeOutQuad(double x) { return 1 - pow(1 - x, 2); }

static double easeInOutQuad(double x) {
    if(x < 0.5) {
        return 2 * x * x;
    } else {
        return 1 - pow(-2 * x + 2, 2) / 2;
    }
}

static double easeInCubic(double x) { return x * x * x; }

static double easeOutCubic(double x) { return 1 - pow(1 - x, 3); }

static double easeInOutCubic(double x) {
    if(x < 0.5) {
        return 4 * x * x * x;
    } else {
        return 1 - pow(-2 * x + 2, 3) / 2;
    }
}

static double easeInQuart(double x) { return pow(x, 4); }

static double easeOutQuart(double x) { return 1 - pow(1 - x, 4); }

static double easeInOutQuart(double x) {
    if(x < 0.5) {
        return 8 * pow(x, 4);
    } else {
        return 1 - pow(-2 * x + 2, 4) / 2;
    }
}

static double easeInQuint(double x) { return pow(x, 5); }

static double easeOutQuint(double x) { return 1 - pow(1 - x, 5); }

static double easeInOutQuint(double x) {
    if(x < 0.5) {
        return 16 * pow(x, 5);
    } else {
        return 1 - pow(-2 * x + 2, 5) / 2;
    }
}

static double easeInExpo(double x) { return x == 0 ? 0 : pow(2, 10 * x - 10); }

static double easeOutExpo(double x) { return x == 1 ? 1 : 1 - pow(2, -10 * x); }

static double easeInOutExpo(double x) {
    if(x == 0) {
        return 0;
    } else if(x == 1) {
        return 1;
    } else if(x < 0.5) {
        return pow(2, 20 * x - 10) / 2;
    } else {
        return (2 - pow(2, -20 * x + 10)) / 2;
    }
}

static double easeInCirc(double x) { return 1 - sqrt(1 - pow(x, 2)); }

static double easeOutCirc(double x) { return sqrt(1 - pow(x - 1, 2)); }

static double easeInOutCirc(double x) {
    if(x < 0.5) {
        return (1 - sqrt(1 - pow(2 * x, 2))) / 2;
    } else {
        return (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;
    }
}

static double easeInBack(double x) {
    const double c1 = 1.70158;
    const double c3 = c1 + 1;
    return c3 * x * x * x - c1 * x * x;
}

static double easeOutBack(double x) {
    const double c1 = 1.70158;
    const double c3 = c1 + 1;
    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
}

static double easeInOutBack(double x) {
    const double c1 = 1.70158;
    const double c2 = c1 * 1.525;
    if(x < 0.5) {
        return (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2;
    } else {
        return (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
    }
}

static double easeInElastic(double x) {
    const double c4 = (2 * kPi) / 3;
    if(x == 0) {
        return 0;
    } else if(x == 1) {
        return 1;
    } else {
        return -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);
    }
}

static double easeOutElastic(double x) {
    const double c4 = (2 * kPi) / 3;
    if(x == 0) {
        return 0;
    } else if(x == 1) {
        return 1;
    } else {
        return pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;
    }
}

static double easeInOutElastic(double x) {
    const double c5 = (2 * kPi) / 4.5;
    if(x == 0) {
        return 0;
    } else if(x == 1) {
        return 1;
    } else if(x < 0.5) {
        return -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2;
    } else {
        return (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;
    }
}

static double easeOutBounce(double x) {
    const double n1 = 7.5625;
    const double d1 = 2.75;
    if(x < 1 / d1) {
        return n1 * x * x;
    } else if(x < 2 / d1) {
        x -= 1.5 / d1;
        return n1 * x * x + 0.75;
    } else if(x < 2.5 / d1) {
        x -= 2.25 / d1;
        return n1 * x * x + 0.9375;
    } else {
        x -= 2.625 / d1;
        return n1 * x * x + 0.984375;
    }
}

static double easeInBounce(double x) { return 1 - easeOutBounce(1 - x); }

static double easeInOutBounce(double x) {
    return x < 0.5 ? (1 - easeOutBounce(1 - 2 * x)) / 2 : (1 + easeOutBounce(2 * x - 1)) / 2;
}

#define DEF_EASE(name)                                                                             \
    static bool easing_##name(int argc, py_Ref argv) {                                             \
        PY_CHECK_ARGC(1);                                                                          \
        py_f64 t;                                                                                  \
        if(!py_castfloat(argv, &t)) return false;                                                  \
        py_newfloat(py_retval(), ease##name(t));                                                   \
        return true;                                                                               \
    }

DEF_EASE(Linear)
DEF_EASE(InSine)
DEF_EASE(OutSine)
DEF_EASE(InOutSine)
DEF_EASE(InQuad)
DEF_EASE(OutQuad)
DEF_EASE(InOutQuad)
DEF_EASE(InCubic)
DEF_EASE(OutCubic)
DEF_EASE(InOutCubic)
DEF_EASE(InQuart)
DEF_EASE(OutQuart)
DEF_EASE(InOutQuart)
DEF_EASE(InQuint)
DEF_EASE(OutQuint)
DEF_EASE(InOutQuint)
DEF_EASE(InExpo)
DEF_EASE(OutExpo)
DEF_EASE(InOutExpo)
DEF_EASE(InCirc)
DEF_EASE(OutCirc)
DEF_EASE(InOutCirc)
DEF_EASE(InBack)
DEF_EASE(OutBack)
DEF_EASE(InOutBack)
DEF_EASE(InElastic)
DEF_EASE(OutElastic)
DEF_EASE(InOutElastic)
DEF_EASE(InBounce)
DEF_EASE(OutBounce)
DEF_EASE(InOutBounce)

#undef DEF_EASE

void pk__add_module_easing() {
    py_GlobalRef mod = py_newmodule("easing");

    py_bindfunc(mod, "Linear", easing_Linear);
    py_bindfunc(mod, "InSine", easing_InSine);
    py_bindfunc(mod, "OutSine", easing_OutSine);
    py_bindfunc(mod, "InOutSine", easing_InOutSine);
    py_bindfunc(mod, "InQuad", easing_InQuad);
    py_bindfunc(mod, "OutQuad", easing_OutQuad);
    py_bindfunc(mod, "InOutQuad", easing_InOutQuad);
    py_bindfunc(mod, "InCubic", easing_InCubic);
    py_bindfunc(mod, "OutCubic", easing_OutCubic);
    py_bindfunc(mod, "InOutCubic", easing_InOutCubic);
    py_bindfunc(mod, "InQuart", easing_InQuart);
    py_bindfunc(mod, "OutQuart", easing_OutQuart);
    py_bindfunc(mod, "InOutQuart", easing_InOutQuart);
    py_bindfunc(mod, "InQuint", easing_InQuint);
    py_bindfunc(mod, "OutQuint", easing_OutQuint);
    py_bindfunc(mod, "InOutQuint", easing_InOutQuint);
    py_bindfunc(mod, "InExpo", easing_InExpo);
    py_bindfunc(mod, "OutExpo", easing_OutExpo);
    py_bindfunc(mod, "InOutExpo", easing_InOutExpo);
    py_bindfunc(mod, "InCirc", easing_InCirc);
    py_bindfunc(mod, "OutCirc", easing_OutCirc);
    py_bindfunc(mod, "InOutCirc", easing_InOutCirc);
    py_bindfunc(mod, "InBack", easing_InBack);
    py_bindfunc(mod, "OutBack", easing_OutBack);
    py_bindfunc(mod, "InOutBack", easing_InOutBack);
    py_bindfunc(mod, "InElastic", easing_InElastic);
    py_bindfunc(mod, "OutElastic", easing_OutElastic);
    py_bindfunc(mod, "InOutElastic", easing_InOutElastic);
    py_bindfunc(mod, "InBounce", easing_InBounce);
    py_bindfunc(mod, "OutBounce", easing_OutBounce);
    py_bindfunc(mod, "InOutBounce", easing_InOutBounce);
}

// src/modules/time.c
#include <time.h>
#include <assert.h>

#define NANOS_PER_SEC 1000000000

#ifndef __circle__
    int64_t time_ns() {
        struct timespec tms;
    #ifdef CLOCK_REALTIME
        clock_gettime(CLOCK_REALTIME, &tms);
    #else
        /* The C11 way */
        timespec_get(&tms, TIME_UTC);
    #endif
        /* seconds, multiplied with 1 billion */
        int64_t nanos = tms.tv_sec * (int64_t)NANOS_PER_SEC;
        /* Add full nanoseconds */
        nanos += tms.tv_nsec;
        return nanos;
    }
#else
    int64_t time_ns() {
        return 0;
    }
#endif

static bool time_time(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    int64_t nanos = time_ns();
    py_newfloat(py_retval(), (double)nanos / NANOS_PER_SEC);
    return true;
}

static bool time_time_ns(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    int64_t nanos = time_ns();
    py_newint(py_retval(), nanos);
    return true;
}

static bool time_sleep(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    py_f64 secs;
    if(!py_castfloat(argv, &secs)) return false;

    int64_t start = time_ns();
    const int64_t end = start + secs * 1000000000;
    while(true) {
        int64_t now = time_ns();
        if(now >= end) break;
    }
    py_newnone(py_retval());
    return true;
}

static bool time_localtime(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    py_Type tp_struct_time = py_gettype("time", py_name("struct_time"));
    assert(tp_struct_time);
    struct tm* ud = py_newobject(py_retval(), tp_struct_time, 0, sizeof(struct tm));
    time_t t = time(NULL);
    *ud = *localtime(&t);
    return true;
}

#define DEF_STRUCT_TIME__PROPERTY(name, expr)                                                      \
    static bool struct_time__##name(int argc, py_Ref argv) {                                       \
        PY_CHECK_ARGC(1);                                                                          \
        struct tm* tm = py_touserdata(argv);                                                       \
        py_newint(py_retval(), expr);                                                              \
        return true;                                                                               \
    }

DEF_STRUCT_TIME__PROPERTY(tm_year, tm->tm_year + 1900)
DEF_STRUCT_TIME__PROPERTY(tm_mon, tm->tm_mon + 1)
DEF_STRUCT_TIME__PROPERTY(tm_mday, tm->tm_mday)
DEF_STRUCT_TIME__PROPERTY(tm_hour, tm->tm_hour)
DEF_STRUCT_TIME__PROPERTY(tm_min, tm->tm_min)
DEF_STRUCT_TIME__PROPERTY(tm_sec, tm->tm_sec)
DEF_STRUCT_TIME__PROPERTY(tm_wday, (tm->tm_wday + 6) % 7)
DEF_STRUCT_TIME__PROPERTY(tm_yday, tm->tm_yday + 1)
DEF_STRUCT_TIME__PROPERTY(tm_isdst, tm->tm_isdst)

#undef DEF_STRUCT_TIME__PROPERTY

void pk__add_module_time() {
    py_Ref mod = py_newmodule("time");

    py_Type tp_struct_time = py_newtype("struct_time", tp_object, mod, NULL);

    py_bindproperty(tp_struct_time, "tm_year", struct_time__tm_year, NULL);
    py_bindproperty(tp_struct_time, "tm_mon", struct_time__tm_mon, NULL);
    py_bindproperty(tp_struct_time, "tm_mday", struct_time__tm_mday, NULL);
    py_bindproperty(tp_struct_time, "tm_hour", struct_time__tm_hour, NULL);
    py_bindproperty(tp_struct_time, "tm_min", struct_time__tm_min, NULL);
    py_bindproperty(tp_struct_time, "tm_sec", struct_time__tm_sec, NULL);
    py_bindproperty(tp_struct_time, "tm_wday", struct_time__tm_wday, NULL);
    py_bindproperty(tp_struct_time, "tm_yday", struct_time__tm_yday, NULL);
    py_bindproperty(tp_struct_time, "tm_isdst", struct_time__tm_isdst, NULL);

    py_bindfunc(mod, "time", time_time);
    py_bindfunc(mod, "time_ns", time_time_ns);
    py_bindfunc(mod, "sleep", time_sleep);
    py_bindfunc(mod, "localtime", time_localtime);
}

#undef NANOS_PER_SEC
#undef DEF_STRUCT_TIME__PROPERTY
// src/modules/enum.c
static bool Enum__wrapper_field(py_Name name, py_Ref value, void* ctx) {
    c11_sv name_sv = py_name2sv(name);
    if(name_sv.size == 0 || name_sv.data[0] == '_') return true;
    py_push(ctx);
    py_pushnil();
    py_assign(py_pushtmp(), py_name2ref(name));
    py_push(value);
    bool ok = py_vectorcall(2, 0);
    if(!ok) return false;
    py_assign(value, py_retval());
    return true;
}

static void Enum__on_end_subclass(py_TypeInfo* derived_ti) {
    derived_ti->is_sealed = true;
    py_applydict(&derived_ti->self, Enum__wrapper_field, &derived_ti->self);
}

static bool Enum__new__(int argc, py_Ref argv) {
    py_newobject(py_retval(), py_totype(argv), 2, 0);
    return true;
}

static bool Enum__init__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_str);
    py_setslot(argv, 0, py_arg(1));
    py_setslot(argv, 1, py_arg(2));
    py_newnone(py_retval());
    return true;
}

static bool Enum__str__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    // f'{type(self).__name__}.{self.name}'
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_cstr(&buf, py_tpname(argv->type));
    c11_sbuf__write_char(&buf, '.');
    c11_sbuf__write_cstr(&buf, py_tostr(py_getslot(argv, 0)));
    c11_sbuf__py_submit(&buf, py_retval());
    return true;
}

static bool Enum__repr__(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    // f'<{str(self)}: {self.value!r}>'
    if(!py_str(argv)) return false;
    py_push(py_retval());  // str(self)
    if(!py_repr(py_getslot(argv, 1))) return false;
    py_push(py_retval());  // repr(self.value)
    c11_sbuf buf;
    c11_sbuf__ctor(&buf);
    c11_sbuf__write_cstr(&buf, "<");
    c11_sbuf__write_cstr(&buf, py_tostr(py_peek(-2)));
    c11_sbuf__write_cstr(&buf, ": ");
    c11_sbuf__write_cstr(&buf, py_tostr(py_peek(-1)));
    c11_sbuf__write_cstr(&buf, ">");
    c11_sbuf__py_submit(&buf, py_retval());
    py_shrink(2);
    return true;
}

static bool Enum__name(int argc, py_Ref argv) {
    py_assign(py_retval(), py_getslot(argv, 0));
    return true;
}

static bool Enum__value(int argc, py_Ref argv) {
    py_assign(py_retval(), py_getslot(argv, 1));
    return true;
}

void pk__add_module_enum() {
    py_Ref mod = py_newmodule("enum");
    py_Type type = py_newtype("Enum", tp_object, mod, NULL);

    py_bindmagic(type, __new__, Enum__new__);
    py_bindmagic(type, __init__, Enum__init__);
    py_bindmagic(type, __str__, Enum__str__);
    py_bindmagic(type, __repr__, Enum__repr__);
    py_bindproperty(type, "name", Enum__name, NULL);
    py_bindproperty(type, "value", Enum__value, NULL);

    pk__type_info(type)->on_end_subclass = Enum__on_end_subclass;
}
// src/modules/base64.c
#include <limits.h>

// https://github.com/zhicheng/base64/blob/master/base64.c

const char BASE64_PAD = '=';
const char BASE64DE_FIRST = '+';
const char BASE64DE_LAST = 'z';

/* BASE 64 encode table */
const char base64en[] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
	'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
	'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
	'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
	'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
	'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
	'w', 'x', 'y', 'z', '0', '1', '2', '3',
	'4', '5', '6', '7', '8', '9', '+', '/',
};

/* ASCII order for BASE 64 decode, 255 in unused character */
const unsigned char base64de[] = {
	/* nul, soh, stx, etx, eot, enq, ack, bel, */
	   255, 255, 255, 255, 255, 255, 255, 255,

	/*  bs,  ht,  nl,  vt,  np,  cr,  so,  si, */
	   255, 255, 255, 255, 255, 255, 255, 255,

	/* dle, dc1, dc2, dc3, dc4, nak, syn, etb, */
	   255, 255, 255, 255, 255, 255, 255, 255,

	/* can,  em, sub, esc,  fs,  gs,  rs,  us, */
	   255, 255, 255, 255, 255, 255, 255, 255,

	/*  sp, '!', '"', '#', '$', '%', '&', ''', */
	   255, 255, 255, 255, 255, 255, 255, 255,

	/* '(', ')', '*', '+', ',', '-', '.', '/', */
	   255, 255, 255,  62, 255, 255, 255,  63,

	/* '0', '1', '2', '3', '4', '5', '6', '7', */
	    52,  53,  54,  55,  56,  57,  58,  59,

	/* '8', '9', ':', ';', '<', '=', '>', '?', */
	    60,  61, 255, 255, 255, 255, 255, 255,

	/* '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', */
	   255,   0,   1,  2,   3,   4,   5,    6,

	/* 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', */
	     7,   8,   9,  10,  11,  12,  13,  14,

	/* 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', */
	    15,  16,  17,  18,  19,  20,  21,  22,

	/* 'X', 'Y', 'Z', '[', '\', ']', '^', '_', */
	    23,  24,  25, 255, 255, 255, 255, 255,

	/* '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', */
	   255,  26,  27,  28,  29,  30,  31,  32,

	/* 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', */
	    33,  34,  35,  36,  37,  38,  39,  40,

	/* 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', */
	    41,  42,  43,  44,  45,  46,  47,  48,

	/* 'x', 'y', 'z', '{', '|', '}', '~', del, */
	    49,  50,  51, 255, 255, 255, 255, 255
};

static unsigned int
base64_encode(const unsigned char *in, unsigned int inlen, char *out)
{
	int s;
	unsigned int i;
	unsigned int j;
	unsigned char c;
	unsigned char l;

	s = 0;
	l = 0;
	for (i = j = 0; i < inlen; i++) {
		c = in[i];

		switch (s) {
		case 0:
			s = 1;
			out[j++] = base64en[(c >> 2) & 0x3F];
			break;
		case 1:
			s = 2;
			out[j++] = base64en[((l & 0x3) << 4) | ((c >> 4) & 0xF)];
			break;
		case 2:
			s = 0;
			out[j++] = base64en[((l & 0xF) << 2) | ((c >> 6) & 0x3)];
			out[j++] = base64en[c & 0x3F];
			break;
		}
		l = c;
	}

	switch (s) {
	case 1:
		out[j++] = base64en[(l & 0x3) << 4];
		out[j++] = BASE64_PAD;
		out[j++] = BASE64_PAD;
		break;
	case 2:
		out[j++] = base64en[(l & 0xF) << 2];
		out[j++] = BASE64_PAD;
		break;
	}

	out[j] = 0;

	return j;
}

static unsigned int
base64_decode(const char *in, unsigned int inlen, unsigned char *out)
{
	unsigned int i;
	unsigned int j;
	unsigned char c;

	if (inlen & 0x3) {
		return 0;
	}

	for (i = j = 0; i < inlen; i++) {
		if (in[i] == BASE64_PAD) {
			break;
		}
		if (in[i] < BASE64DE_FIRST || in[i] > BASE64DE_LAST) {
			return 0;
		}

		c = base64de[(unsigned char)in[i]];
		if (c == 255) {
			return 0;
		}

		switch (i & 0x3) {
		case 0:
			out[j] = (c << 2) & 0xFF;
			break;
		case 1:
			out[j++] |= (c >> 4) & 0x3;
			out[j] = (c & 0xF) << 4; 
			break;
		case 2:
			out[j++] |= (c >> 2) & 0xF;
			out[j] = (c & 0x3) << 6;
			break;
		case 3:
			out[j++] |= c;
			break;
		}
	}

	return j;
}

static bool base64_b64encode(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_bytes);
    int src_size;
    unsigned char* src_data = py_tobytes(argv, &src_size);
    unsigned char* dst_data = py_newbytes(py_retval(), src_size * 4 / 3 + 4);
    int size = base64_encode(src_data, src_size, (char*)dst_data);
    py_bytes_resize(py_retval(), size);
    return true;
}

static bool base64_b64decode(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    int src_size;
    void* src_data;
    if(py_istype(argv, tp_str)) {
        c11_sv sv = py_tosv(argv);
        src_data = (void*)sv.data;
        src_size = sv.size;
    } else if(py_istype(argv, tp_bytes)) {
        src_data = py_tobytes(argv, &src_size);
    } else {
        return TypeError("expect bytes or str, got %t", argv->type);
    }
    unsigned char* dst_data = py_newbytes(py_retval(), src_size);
    int size = base64_decode((const char*)src_data, src_size, dst_data);
    py_bytes_resize(py_retval(), size);
    return true;
}

void pk__add_module_base64(){
    py_GlobalRef mod = py_newmodule("base64");

    py_bindfunc(mod, "b64encode", base64_b64encode);
    py_bindfunc(mod, "b64decode", base64_b64decode);
}

// src/modules/importlib.c
static bool importlib_reload(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_module);
    return py_importlib_reload(argv);
}

void pk__add_module_importlib() {
    py_Ref mod = py_newmodule("importlib");

    py_bindfunc(mod, "reload", importlib_reload);
}
// src/modules/dis.c
#include <stdbool.h>

static bool disassemble(CodeObject* co) {
    c11_vector /*T=int*/ jumpTargets;
    c11_vector__ctor(&jumpTargets, sizeof(int));
    for(int i = 0; i < co->codes.length; i++) {
        Bytecode* bc = c11__at(Bytecode, &co->codes, i);
        if(Bytecode__is_forward_jump(bc)) {
            int target = (int16_t)bc->arg + i;
            c11_vector__push(int, &jumpTargets, target);
        }
    }

    c11_sbuf ss;
    c11_sbuf__ctor(&ss);

    int prev_line = -1;
    for(int i = 0; i < co->codes.length; i++) {
        Bytecode byte = c11__getitem(Bytecode, &co->codes, i);
        BytecodeEx ex = c11__getitem(BytecodeEx, &co->codes_ex, i);

        char line[8] = "";
        if(ex.lineno == prev_line) {
            // do nothing
        } else {
            snprintf(line, sizeof(line), "%d", ex.lineno);
            if(prev_line != -1) c11_sbuf__write_char(&ss, '\n');
            prev_line = ex.lineno;
        }

        char pointer[4] = "";
        c11__foreach(int, &jumpTargets, it) {
            if(*it == i) {
                snprintf(pointer, sizeof(pointer), "->");
                break;
            }
        }

        char buf[32];
        snprintf(buf, sizeof(buf), "%-8s%-3s%-3d ", line, pointer, i);
        c11_sbuf__write_cstr(&ss, buf);

        c11_sbuf__write_cstr(&ss, pk_opname(byte.op));
        c11_sbuf__write_char(&ss, ex.is_virtual ? '*' : ' ');
        int padding = 24 - strlen(pk_opname(byte.op));
        for(int j = 0; j < padding; j++)
            c11_sbuf__write_char(&ss, ' ');

        do {
            if(Bytecode__is_forward_jump(&byte)) {
                pk_sprintf(&ss, "%d (to %d)", (int16_t)byte.arg, (int16_t)byte.arg + i);
                break;
            }

            c11_sbuf__write_int(&ss, byte.arg);
            switch(byte.op) {
                // TODO: see `dis.py` there is a memory issue
                case OP_LOAD_CONST: {
                    py_Ref value = c11__at(py_TValue, &co->consts, byte.arg);
                    if(py_repr(value)) {
                        pk_sprintf(&ss, " (%v)", py_tosv(py_retval()));
                    } else {
                        return false;
                    }
                    break;
                }
                case OP_FORMAT_STRING:
                case OP_IMPORT_PATH: {
                    py_Ref path = c11__at(py_TValue, &co->consts, byte.arg);
                    pk_sprintf(&ss, " (%q)", py_tosv(path));
                    break;
                }
                case OP_LOAD_NAME:
                case OP_LOAD_GLOBAL:
                case OP_LOAD_NONLOCAL:
                case OP_STORE_GLOBAL:
                case OP_LOAD_ATTR:
                case OP_LOAD_METHOD:
                case OP_STORE_ATTR:
                case OP_DELETE_ATTR:
                case OP_BEGIN_CLASS:
                case OP_DELETE_GLOBAL:
                case OP_STORE_CLASS_ATTR: {
                    pk_sprintf(&ss, " (%n)", byte.arg);
                    break;
                }
                case OP_LOAD_FAST:
                case OP_STORE_FAST:
                case OP_DELETE_FAST: {
                    py_Name name = c11__getitem(py_Name, &co->varnames, byte.arg);
                    pk_sprintf(&ss, " (%n)", name);
                    break;
                }
                case OP_LOAD_FUNCTION: {
                    const FuncDecl* decl = c11__getitem(FuncDecl*, &co->func_decls, byte.arg);
                    pk_sprintf(&ss, " (%s)", decl->code.name->data);
                    break;
                }
                case OP_BINARY_OP: {
                    py_Name name = byte.arg & 0xFF;
                    pk_sprintf(&ss, " (%s)", pk_op2str(name));
                    break;
                }
            }
        } while(0);

        if(i != co->codes.length - 1) c11_sbuf__write_char(&ss, '\n');
    }

    c11_string* output = c11_sbuf__submit(&ss);
    pk_current_vm->callbacks.print(output->data);
    pk_current_vm->callbacks.print("\n");
    c11_string__delete(output);
    c11_vector__dtor(&jumpTargets);
    return true;
}

static bool dis_dis(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);

    CodeObject* code = NULL;
    if(py_istype(argv, tp_function)) {
        Function* ud = py_touserdata(argv);
        code = &ud->decl->code;
    } else if(py_istype(argv, tp_code)) {
        code = py_touserdata(argv);
    } else {
        return TypeError("dis() expected a code object");
    }
    if(!disassemble(code)) return false;
    py_newnone(py_retval());
    return true;
}

void pk__add_module_dis() {
    py_Ref mod = py_newmodule("dis");

    py_bindfunc(mod, "dis", dis_dis);
}
// src/modules/os.c
#if PK_ENABLE_OS == 1

#include <errno.h>

#if PY_SYS_PLATFORM == 0
#include <direct.h>
#include <io.h>

int platform_chdir(const char* path) { return _chdir(path); }

bool platform_getcwd(char* buf, size_t size) { return _getcwd(buf, size) != NULL; }

bool platform_path_exists(const char* path) { return _access(path, 0) == 0; }

#elif PY_SYS_PLATFORM == 3 || PY_SYS_PLATFORM == 5
#include <unistd.h>

int platform_chdir(const char* path) { return chdir(path); }

bool platform_getcwd(char* buf, size_t size) { return getcwd(buf, size) != NULL; }

bool platform_path_exists(const char* path) { return access(path, F_OK) == 0; }
#else

int platform_chdir(const char* path) { return -1; }

bool platform_getcwd(char* buf, size_t size) { return false; }

bool platform_path_exists(const char* path) { return false; }
#endif

static bool os_chdir(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    const char* path = py_tostr(py_arg(0));
    int code = platform_chdir(path);
    if(code != 0) {
        const char* msg = strerror(errno);
        return OSError("[Errno %d] %s: '%s'", errno, msg, path);
    }
    py_newnone(py_retval());
    return true;
}

static bool os_getcwd(int argc, py_Ref argv) {
    char buf[1024];
    if(!platform_getcwd(buf, sizeof(buf))) return OSError("getcwd() failed");
    py_newstr(py_retval(), buf);
    return true;
}

static bool os_system(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
#if PK_IS_DESKTOP_PLATFORM
    const char* cmd = py_tostr(py_arg(0));
    int code = system(cmd);
    py_newint(py_retval(), code);
    return true;
#else
    return OSError("system() is not supported on this platform");
#endif
}

static bool os_remove(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    const char* path = py_tostr(py_arg(0));
    int code = remove(path);
    if(code != 0) {
        const char* msg = strerror(errno);
        return OSError("[Errno %d] %s: '%s'", errno, msg, path);
    }
    py_newnone(py_retval());
    return true;
}

static bool os_path_exists(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_str);
    const char* path = py_tostr(py_arg(0));
    py_newbool(py_retval(), platform_path_exists(path));
    return true;
}

void pk__add_module_os() {
    py_Ref mod = py_newmodule("os");
    py_bindfunc(mod, "chdir", os_chdir);
    py_bindfunc(mod, "getcwd", os_getcwd);
    py_bindfunc(mod, "system", os_system);
    py_bindfunc(mod, "remove", os_remove);

    py_ItemRef path_object = py_emplacedict(mod, py_name("path"));
    py_newobject(path_object, tp_object, -1, 0);
    py_bindfunc(path_object, "exists", os_path_exists);
}

typedef struct {
    const char* path;
    const char* mode;
    FILE* file;
} io_FileIO;

static bool io_FileIO__new__(int argc, py_Ref argv) {
    // __new__(cls, file, mode)
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_str);
    PY_CHECK_ARG_TYPE(2, tp_str);
    py_Type cls = py_totype(argv);
    io_FileIO* ud = py_newobject(py_retval(), cls, 0, sizeof(io_FileIO));
    ud->path = py_tostr(py_arg(1));
    ud->mode = py_tostr(py_arg(2));
    ud->file = fopen(ud->path, ud->mode);
    if(ud->file == NULL) {
        const char* msg = strerror(errno);
        return OSError("[Errno %d] %s: '%s'", errno, msg, ud->path);
    }
    return true;
}

static bool io_FileIO__enter__(int argc, py_Ref argv) {
    py_assign(py_retval(), py_arg(0));
    return true;
}

static bool io_FileIO__exit__(int argc, py_Ref argv) {
    io_FileIO* ud = py_touserdata(py_arg(0));
    if(ud->file != NULL) {
        fclose(ud->file);
        ud->file = NULL;
    }
    py_newnone(py_retval());
    return true;
}

static bool io_FileIO_read(int argc, py_Ref argv) {
    io_FileIO* ud = py_touserdata(py_arg(0));
    bool is_binary = ud->mode[strlen(ud->mode) - 1] == 'b';
    int size;
    if(argc == 1) {
        long current = ftell(ud->file);
        fseek(ud->file, 0, SEEK_END);
        size = ftell(ud->file);
        fseek(ud->file, current, SEEK_SET);
    } else if(argc == 2) {
        PY_CHECK_ARG_TYPE(1, tp_int);
        size = py_toint(py_arg(1));
    } else {
        return TypeError("read() takes at most 2 arguments (%d given)", argc);
    }
    if(is_binary) {
        void* dst = py_newbytes(py_retval(), size);
        int actual_size = fread(dst, 1, size, ud->file);
        py_bytes_resize(py_retval(), actual_size);
    } else {
        void* dst = PK_MALLOC(size);
        int actual_size = fread(dst, 1, size, ud->file);
        py_newstrv(py_retval(), (c11_sv){dst, actual_size});
        PK_FREE(dst);
    }
    return true;
}

static bool io_FileIO_tell(int argc, py_Ref argv) {
    io_FileIO* ud = py_touserdata(py_arg(0));
    py_newint(py_retval(), ftell(ud->file));
    return true;
}

static bool io_FileIO_seek(int argc, py_Ref argv) {
    PY_CHECK_ARGC(3);
    PY_CHECK_ARG_TYPE(1, tp_int);
    PY_CHECK_ARG_TYPE(2, tp_int);
    io_FileIO* ud = py_touserdata(py_arg(0));
    long cookie = py_toint(py_arg(1));
    int whence = py_toint(py_arg(2));
    py_newint(py_retval(), fseek(ud->file, cookie, whence));
    return true;
}

static bool io_FileIO_close(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    io_FileIO* ud = py_touserdata(py_arg(0));
    if(ud->file != NULL) {
        fclose(ud->file);
        ud->file = NULL;
    }
    py_newnone(py_retval());
    return true;
}

static bool io_FileIO_write(int argc, py_Ref argv) {
    PY_CHECK_ARGC(2);
    io_FileIO* ud = py_touserdata(py_arg(0));
    size_t written_size;
    if(ud->mode[strlen(ud->mode) - 1] == 'b') {
        PY_CHECK_ARG_TYPE(1, tp_bytes);
        int filesize;
        unsigned char* data = py_tobytes(py_arg(1), &filesize);
        written_size = fwrite(data, 1, filesize, ud->file);
    } else {
        PY_CHECK_ARG_TYPE(1, tp_str);
        c11_sv sv = py_tosv(py_arg(1));
        written_size = fwrite(sv.data, 1, sv.size, ud->file);
    }
    py_newint(py_retval(), written_size);
    return true;
}

void pk__add_module_io() {
    py_Ref mod = py_newmodule("io");

    py_Type FileIO = pk_newtype("FileIO", tp_object, mod, NULL, false, true);

    py_bindmagic(FileIO, __new__, io_FileIO__new__);
    py_bindmagic(FileIO, __enter__, io_FileIO__enter__);
    py_bindmagic(FileIO, __exit__, io_FileIO__exit__);
    py_bindmethod(FileIO, "read", io_FileIO_read);
    py_bindmethod(FileIO, "write", io_FileIO_write);
    py_bindmethod(FileIO, "close", io_FileIO_close);
    py_bindmethod(FileIO, "tell", io_FileIO_tell);
    py_bindmethod(FileIO, "seek", io_FileIO_seek);

    py_newint(py_emplacedict(mod, py_name("SEEK_SET")), SEEK_SET);
    py_newint(py_emplacedict(mod, py_name("SEEK_CUR")), SEEK_CUR);
    py_newint(py_emplacedict(mod, py_name("SEEK_END")), SEEK_END);

    py_setdict(&pk_current_vm->builtins, py_name("open"), py_tpobject(FileIO));
}

#else

void pk__add_module_os() {}

void pk__add_module_io() {}

#endif

static bool sys_setrecursionlimit(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_int);
    int limit = py_toint(py_arg(0));
    if(limit <= pk_current_vm->recursion_depth) return ValueError("the limit is too low");
    pk_current_vm->max_recursion_depth = limit;
    py_newnone(py_retval());
    return true;
}

static bool sys_getrecursionlimit(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    py_newint(py_retval(), pk_current_vm->max_recursion_depth);
    return true;
}

void pk__add_module_sys() {
    py_Ref mod = py_newmodule("sys");
    py_newstr(py_emplacedict(mod, py_name("platform")), PY_SYS_PLATFORM_STRING);
    py_newstr(py_emplacedict(mod, py_name("version")), PK_VERSION);
    py_newlist(py_emplacedict(mod, py_name("argv")));

    py_bindfunc(mod, "setrecursionlimit", sys_setrecursionlimit);
    py_bindfunc(mod, "getrecursionlimit", sys_getrecursionlimit);
}

// src/modules/colorcvt.c
#include <math.h>

// https://bottosson.github.io/posts/gamutclipping/#oklab-to-linear-srgb-conversion

// clang-format off
static c11_vec3 linear_srgb_to_oklab(c11_vec3 c)
{
	float l = 0.4122214708f * c.x + 0.5363325363f * c.y + 0.0514459929f * c.z;
	float m = 0.2119034982f * c.x + 0.6806995451f * c.y + 0.1073969566f * c.z;
	float s = 0.0883024619f * c.x + 0.2817188376f * c.y + 0.6299787005f * c.z;

	float l_ = cbrtf(l);
	float m_ = cbrtf(m);
	float s_ = cbrtf(s);

	return (c11_vec3){{
		0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
		1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
		0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_,
	}};
}

static c11_vec3 oklab_to_linear_srgb(c11_vec3 c)
{
    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;
    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;
    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;

    float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;

    return (c11_vec3){{
        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s,
    }};
}

// clang-format on

static float _gamma_correct_inv(float x) {
    return (x <= 0.04045f) ? (x / 12.92f) : powf((x + 0.055f) / 1.055f, 2.4f);
}

static float _gamma_correct(float x) {
    return (x <= 0.0031308f) ? (12.92f * x) : (1.055f * powf(x, 1.0f / 2.4f) - 0.055f);
}

static c11_vec3 srgb_to_linear_srgb(c11_vec3 c) {
    c.x = _gamma_correct_inv(c.x);
    c.y = _gamma_correct_inv(c.y);
    c.z = _gamma_correct_inv(c.z);
    return c;
}

static c11_vec3 linear_srgb_to_srgb(c11_vec3 c) {
    c.x = _gamma_correct(c.x);
    c.y = _gamma_correct(c.y);
    c.z = _gamma_correct(c.z);
    return c;
}

static c11_vec3 _oklab_to_oklch(c11_vec3 c) {
    c11_vec3 res;
    res.x = c.x;
    res.y = sqrtf(c.y * c.y + c.z * c.z);
    res.z = fmodf(atan2f(c.z, c.y), 2 * (float)PK_M_PI);
    res.z = res.z * PK_M_RAD2DEG;
    return res;
}

static c11_vec3 _oklch_to_oklab(c11_vec3 c) {
    c11_vec3 res;
    res.x = c.x;
    res.y = c.y * cosf(c.z * PK_M_DEG2RAD);
    res.z = c.y * sinf(c.z * PK_M_DEG2RAD);
    return res;
}

static c11_vec3 linear_srgb_to_oklch(c11_vec3 c) {
    return _oklab_to_oklch(linear_srgb_to_oklab(c));
}

static bool _is_valid_srgb(c11_vec3 c) {
    return c.x >= 0.0f && c.x <= 1.0f && c.y >= 0.0f && c.y <= 1.0f && c.z >= 0.0f && c.z <= 1.0f;
}

static c11_vec3 oklch_to_linear_srgb(c11_vec3 c) {
    c11_vec3 candidate = oklab_to_linear_srgb(_oklch_to_oklab(c));
    if(_is_valid_srgb(candidate)) return candidate;

    // try with chroma = 0
    c11_vec3 clamped = {
        {c.x, 0.0f, c.z}
    };

    // if not even chroma = 0 is displayable
    // fall back to RGB clamping
    candidate = oklab_to_linear_srgb(_oklch_to_oklab(clamped));
    if(!_is_valid_srgb(candidate)) {
        candidate.x = fmaxf(0.0f, fminf(1.0f, candidate.x));
        candidate.y = fmaxf(0.0f, fminf(1.0f, candidate.y));
        candidate.z = fmaxf(0.0f, fminf(1.0f, candidate.z));
        return candidate;
    }

    // By this time we know chroma = 0 is displayable and our current chroma is not.
    // Find the displayable chroma through the bisection method.
    float start = 0.0f;
    float end = c.y;
    float range[2] = {0.0f, 0.4f};
    float resolution = (range[1] - range[0]) / powf(2, 13);
    float _last_good_c = clamped.y;

    while(end - start > resolution) {
        clamped.y = start + (end - start) * 0.5f;
        candidate = oklab_to_linear_srgb(_oklch_to_oklab(clamped));
        if(_is_valid_srgb(candidate)) {
            _last_good_c = clamped.y;
            start = clamped.y;
        } else {
            end = clamped.y;
        }
    }

    candidate = oklab_to_linear_srgb(_oklch_to_oklab(clamped));
    if(_is_valid_srgb(candidate)) return candidate;
    clamped.y = _last_good_c;
    return oklab_to_linear_srgb(_oklch_to_oklab(clamped));
}

// https://github.com/python/cpython/blob/3.13/Lib/colorsys.py
static c11_vec3 srgb_to_hsv(c11_vec3 c) {
    float r = c.x;
    float g = c.y;
    float b = c.z;

    float maxc = fmaxf(r, fmaxf(g, b));
    float minc = fminf(r, fminf(g, b));
    float v = maxc;
    if(minc == maxc) {
        return (c11_vec3){
            {0.0f, 0.0f, v}
        };
    }

    float s = (maxc - minc) / maxc;
    float rc = (maxc - r) / (maxc - minc);
    float gc = (maxc - g) / (maxc - minc);
    float bc = (maxc - b) / (maxc - minc);
    float h;
    if(r == maxc) {
        h = bc - gc;
    } else if(g == maxc) {
        h = 2.0f + rc - bc;
    } else {
        h = 4.0f + gc - rc;
    }
    h = fmodf(h / 6.0f, 1.0f);
    return (c11_vec3){
        {h, s, v}
    };
}

static c11_vec3 hsv_to_srgb(c11_vec3 c) {
    float h = c.x;
    float s = c.y;
    float v = c.z;

    if(s == 0.0f) {
        return (c11_vec3){
            {v, v, v}
        };
    }

    int i = (int)(h * 6.0f);
    float f = (h * 6.0f) - i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));
    i = i % 6;
    switch(i) {
        // clang-format off
        case 0: return (c11_vec3){{v, t, p}};
        case 1: return (c11_vec3){{q, v, p}};
        case 2: return (c11_vec3){{p, v, t}};
        case 3: return (c11_vec3){{p, q, v}};
        case 4: return (c11_vec3){{t, p, v}};
        case 5: return (c11_vec3){{v, p, q}};
        // clang-format on
        default: c11__unreachable();
    }
}

#define DEF_VEC3_WRAPPER(F)                                                                        \
    static bool colorcvt_##F(int argc, py_Ref argv);                                               \
    static bool colorcvt_##F(int argc, py_Ref argv) {                                              \
        PY_CHECK_ARGC(1);                                                                          \
        PY_CHECK_ARG_TYPE(0, tp_vec3);                                                             \
        c11_vec3 c = py_tovec3(argv);                                                              \
        py_newvec3(py_retval(), F(c));                                                             \
        return true;                                                                               \
    }

DEF_VEC3_WRAPPER(linear_srgb_to_srgb)
DEF_VEC3_WRAPPER(srgb_to_linear_srgb)
DEF_VEC3_WRAPPER(srgb_to_hsv)
DEF_VEC3_WRAPPER(hsv_to_srgb)
DEF_VEC3_WRAPPER(oklch_to_linear_srgb)
DEF_VEC3_WRAPPER(linear_srgb_to_oklch)

void pk__add_module_colorcvt() {
    py_Ref mod = py_newmodule("colorcvt");

    py_bindfunc(mod, "linear_srgb_to_srgb", colorcvt_linear_srgb_to_srgb);
    py_bindfunc(mod, "srgb_to_linear_srgb", colorcvt_srgb_to_linear_srgb);
    py_bindfunc(mod, "srgb_to_hsv", colorcvt_srgb_to_hsv);
    py_bindfunc(mod, "hsv_to_srgb", colorcvt_hsv_to_srgb);
    py_bindfunc(mod, "oklch_to_linear_srgb", colorcvt_oklch_to_linear_srgb);
    py_bindfunc(mod, "linear_srgb_to_oklch", colorcvt_linear_srgb_to_oklch);
}

#undef DEF_VEC3_WRAPPER
// src/modules/lz4.c
#ifdef PK_BUILD_MODULE_LZ4

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "lz4/lib/lz4.h"

static bool lz4_compress(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_bytes);
    int src_size;
    const void* src = py_tobytes(argv, &src_size);
    int dst_capacity = LZ4_compressBound(src_size);
    char* p = (char*)py_newbytes(py_retval(), sizeof(int) + dst_capacity);
    memcpy(p, &src_size, sizeof(int));
    char* dst = p + sizeof(int);
    int dst_size = LZ4_compress_default(src, dst, src_size, dst_capacity);
    if(dst_size <= 0) return ValueError("LZ4 compression failed");
    py_bytes_resize(py_retval(), sizeof(int) + dst_size);
    return true;
}

static bool lz4_decompress(int argc, py_Ref argv) {
    PY_CHECK_ARGC(1);
    PY_CHECK_ARG_TYPE(0, tp_bytes);
    int total_size;
    const int* p = (int*)py_tobytes(argv, &total_size);
    const char* src = (const char*)(p + 1);
    if(total_size < sizeof(int)) return ValueError("invalid LZ4 data");
    int uncompressed_size = *p;
    if(uncompressed_size < 0) return ValueError("invalid LZ4 data");
    char* dst = (char*)py_newbytes(py_retval(), uncompressed_size);
    int dst_size = LZ4_decompress_safe(src, dst, total_size - sizeof(int), uncompressed_size);
    if(dst_size < 0) return ValueError("LZ4 decompression failed");
    assert(dst_size == uncompressed_size);
    return true;
}

void pk__add_module_lz4() {
    py_Ref mod = py_newmodule("lz4");
    py_bindfunc(mod, "compress", lz4_compress);
    py_bindfunc(mod, "decompress", lz4_decompress);
}

#else

void pk__add_module_lz4() {}

#endif

// src/modules/conio.c
#include <stdlib.h>

#if PY_SYS_PLATFORM == 0

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <conio.h>

#elif PY_SYS_PLATFORM == 3 || PY_SYS_PLATFORM == 5

#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include <fcntl.h>
#include <string.h>

// 
static struct termios orig_termios;
static bool orig_termios_set;

// 
static void reset_terminal_mode() { tcsetattr(0, TCSANOW, &orig_termios); }

// 
static void set_conio_terminal_mode_if_needed() {
    if(orig_termios_set) return;
    struct termios new_termios;

    // 
    tcgetattr(0, &orig_termios);
    memcpy(&new_termios, &orig_termios, sizeof(new_termios));

    // 
    new_termios.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(0, TCSANOW, &new_termios);

    atexit(reset_terminal_mode);
    orig_termios_set = true;
}

// 
int _kbhit() {
    set_conio_terminal_mode_if_needed();

    struct termios term;
    int oldf;
    int ch;
    int old_flags;

    // 
    tcgetattr(0, &term);
    oldf = term.c_lflag;
    term.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(0, TCSANOW, &term);

    // 
    old_flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, old_flags | O_NONBLOCK);

    // 
    ch = getchar();

    // 
    fcntl(STDIN_FILENO, F_SETFL, old_flags);

    // 
    term.c_lflag = oldf;
    tcsetattr(0, TCSANOW, &term);

    if(ch != EOF) {
        ungetc(ch, stdin);
        return 1;
    }

    return 0;
}

// 
int _getch() {
    set_conio_terminal_mode_if_needed();

    int ch;
    struct termios oldt, newt;

    // 
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;

    // 
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);

    // 
    ch = getchar();

    // 
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);

    return ch;
}
#endif

#if PK_IS_DESKTOP_PLATFORM && PK_ENABLE_OS
static bool conio_kbhit(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    int ret = _kbhit();
    py_newint(py_retval(), ret);
    return true;
}

static bool conio_getch(int argc, py_Ref argv) {
    PY_CHECK_ARGC(0);
    int ret = _getch();
    py_newint(py_retval(), ret);
    return true;
}

void pk__add_module_conio() {
    py_Ref mod = py_newmodule("conio");
    py_bindfunc(mod, "_kbhit", conio_kbhit);
    py_bindfunc(mod, "_getch", conio_getch);
}

#else

void pk__add_module_conio() {}

#endif

// src/modules/gc.c
static bool gc_collect(int argc, py_Ref argv){
    PY_CHECK_ARGC(0);
    ManagedHeap* heap = &pk_current_vm->heap;
    int res = ManagedHeap__collect(heap);
    py_newint(py_retval(), res);
    return true;
}

static bool gc_enable(int argc, py_Ref argv){
    PY_CHECK_ARGC(0);
    ManagedHeap* heap = &pk_current_vm->heap;
    heap->gc_enabled = true;
    py_newnone(py_retval());
    return true;
}

static bool gc_disable(int argc, py_Ref argv){
    PY_CHECK_ARGC(0);
    ManagedHeap* heap = &pk_current_vm->heap;
    heap->gc_enabled = false;
    py_newnone(py_retval());
    return true;
}

static bool gc_isenabled(int argc, py_Ref argv){
    PY_CHECK_ARGC(0);
    ManagedHeap* heap = &pk_current_vm->heap;
    py_newbool(py_retval(), heap->gc_enabled);
    return true;
}

void pk__add_module_gc() {
    py_Ref mod = py_newmodule("gc");

    py_bindfunc(mod, "collect", gc_collect);
    py_bindfunc(mod, "enable", gc_enable);
    py_bindfunc(mod, "disable", gc_disable);
    py_bindfunc(mod, "isenabled", gc_isenabled);
}
// src/compiler/lexer.c
#include <ctype.h>

#define is_raw_string_used(t) ((t) == TK_ID)

typedef struct Lexer {
    SourceData_ src;
    const char* token_start;
    const char* curr_char;
    int current_line;
    int brackets_level;

    c11_vector /*T=Token*/ nexts;
    c11_vector /*T=int*/ indents;
} Lexer;

const static TokenValue EmptyTokenValue;

static Error* lex_one_token(Lexer* self, bool* eof, bool is_fstring);

static void Lexer__ctor(Lexer* self, SourceData_ src) {
    PK_INCREF(src);
    self->src = src;
    self->curr_char = self->token_start = src->source->data;
    self->current_line = 1;
    self->brackets_level = 0;
    c11_vector__ctor(&self->nexts, sizeof(Token));
    c11_vector__ctor(&self->indents, sizeof(int));
}

static void Lexer__dtor(Lexer* self) {
    PK_DECREF(self->src);
    c11_vector__dtor(&self->nexts);
    c11_vector__dtor(&self->indents);
}

static char eatchar(Lexer* self) {
    char c = *self->curr_char;
    assert(c != '\n');  // eatchar() cannot consume a newline
    self->curr_char++;
    return c;
}

static char eatchar_include_newline(Lexer* self) {
    char c = *self->curr_char;
    self->curr_char++;
    if(c == '\n') {
        self->current_line++;
        c11_vector__push(const char*, &self->src->line_starts, self->curr_char);
    }
    return c;
}

static int eat_spaces(Lexer* self) {
    int count = 0;
    while(true) {
        switch(*self->curr_char) {
            case ' ': count += 1; break;
            case '\t': count += 4; break;
            default: return count;
        }
        eatchar(self);
    }
}

static bool matchchar(Lexer* self, char c) {
    if(*self->curr_char != c) return false;
    eatchar_include_newline(self);
    return true;
}

static bool match_n_chars(Lexer* self, int n, char c0) {
    const char* c = self->curr_char;
    for(int i = 0; i < n; i++) {
        if(*c == '\0') return false;
        if(*c != c0) return false;
        c++;
    }
    for(int i = 0; i < n; i++)
        eatchar_include_newline(self);
    return true;
}

static void skip_line_comment(Lexer* self) {
    while(*self->curr_char) {
        if(*self->curr_char == '\n') return;
        eatchar(self);
    }
}

static void add_token_with_value(Lexer* self, TokenIndex type, TokenValue value) {
    switch(type) {
        case TK_LBRACE:
        case TK_LBRACKET:
        case TK_LPAREN: self->brackets_level++; break;
        case TK_RPAREN:
        case TK_RBRACKET:
        case TK_RBRACE: self->brackets_level--; break;
        default: break;
    }
    Token token = {type,
                   self->token_start,
                   (int)(self->curr_char - self->token_start),
                   self->current_line - ((type == TK_EOL) ? 1 : 0),
                   self->brackets_level,
                   value};
    // handle "not in", "is not", "yield from"
    if(self->nexts.length > 0) {
        Token* back = &c11_vector__back(Token, &self->nexts);
        if(back->type == TK_NOT_KW && type == TK_IN) {
            back->type = TK_NOT_IN;
            return;
        }
        if(back->type == TK_IS && type == TK_NOT_KW) {
            back->type = TK_IS_NOT;
            return;
        }
        if(back->type == TK_YIELD && type == TK_FROM) {
            back->type = TK_YIELD_FROM;
            return;
        }
        c11_vector__push(Token, &self->nexts, token);
    }
}

static void add_token(Lexer* self, TokenIndex type) {
    add_token_with_value(self, type, EmptyTokenValue);
}

static void add_token_2(Lexer* self, char c, TokenIndex one, TokenIndex two) {
    if(matchchar(self, c))
        add_token(self, two);
    else
        add_token(self, one);
}

static bool eat_indentation(Lexer* self) {
    if(self->brackets_level > 0) return true;
    int spaces = eat_spaces(self);
    if(*self->curr_char == '#') skip_line_comment(self);
    if(*self->curr_char == '\0' || *self->curr_char == '\n') { return true; }
    // https://docs.python.org/3/reference/lexical_analysis.html#indentation
    int indents_back = c11_vector__back(int, &self->indents);
    if(spaces > indents_back) {
        c11_vector__push(int, &self->indents, spaces);
        Token t = {TK_INDENT,
                   self->token_start,
                   0,
                   self->current_line,
                   self->brackets_level,
                   EmptyTokenValue};
        c11_vector__push(Token, &self->nexts, t);
    } else if(spaces < indents_back) {
        do {
            c11_vector__pop(&self->indents);
            Token t = {TK_DEDENT,
                       self->token_start,
                       0,
                       self->current_line,
                       self->brackets_level,
                       EmptyTokenValue};
            c11_vector__push(Token, &self->nexts, t);
            indents_back = c11_vector__back(int, &self->indents);
        } while(spaces < indents_back);
        if(spaces != indents_back) { return false; }
    }
    return true;
}

static bool is_possible_number_char(char c) {
    switch(c) {
            // clang-format off
        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
        case '.': case 'x': case 'o': case 'j':
        return true;
        default: return false;
            // clang-format on
    }
}

/******************************/
static Error* LexerError(Lexer* self, const char* fmt, ...) {
    Error* err = PK_MALLOC(sizeof(Error));
    err->src = self->src;
    PK_INCREF(self->src);
    err->lineno = self->current_line;
    if(*self->curr_char == '\n') { err->lineno--; }
    va_list args;
    va_start(args, fmt);
    vsnprintf(err->msg, sizeof(err->msg), fmt, args);
    va_end(args);
    return err;
}

static Error* eat_name(Lexer* self) {
    self->curr_char--;
    while(true) {
        unsigned char c = *self->curr_char;
        int u8bytes = c11__u8_header(c, true);
        if(u8bytes == 0) return LexerError(self, "invalid char: %c", c);
        if(u8bytes == 1) {
            if(isalnum(c) || c == '_') {
                self->curr_char++;
                continue;
            } else {
                break;
            }
        }
        int value = c11__u8_value(u8bytes, self->curr_char);
        if(c11__is_unicode_Lo_char(value)) {
            self->curr_char += u8bytes;
        } else {
            break;
        }
    }

    int length = (int)(self->curr_char - self->token_start);
    if(length == 0) return LexerError(self, "@id contains invalid char");
    c11_sv name = {self->token_start, length};

    const char** KW_BEGIN = TokenSymbols + TK_FALSE;
    int KW_COUNT = TK__COUNT__ - TK_FALSE;
#define less(a, b) (c11_sv__cmp2(b, a) > 0)
    int out;
    c11__lower_bound(const char*, KW_BEGIN, KW_COUNT, name, less, &out);
#undef less

    if(out != KW_COUNT && c11__sveq2(name, KW_BEGIN[out])) {
        add_token(self, (TokenIndex)(out + TK_FALSE));
    } else {
        add_token(self, TK_ID);
    }
    return NULL;
}

enum StringType { NORMAL_STRING, RAW_STRING, F_STRING, NORMAL_BYTES };

static Error* _eat_string(Lexer* self, c11_sbuf* buff, char quote, enum StringType type) {
    bool is_raw = type == RAW_STRING;
    bool is_fstring = type == F_STRING;

    if(is_fstring) { add_token(self, TK_FSTR_BEGIN); }

    // previous char is quote
    bool quote3 = match_n_chars(self, 2, quote);
    while(true) {
        char c = eatchar_include_newline(self);
        if(c == quote) {
            if(quote3 && !match_n_chars(self, 2, quote)) {
                c11_sbuf__write_char(buff, c);
                continue;
            }
            // end of string
            break;
        }
        if(c == '\0') { return LexerError(self, "EOL while scanning string literal"); }
        if(c == '\n') {
            if(!quote3)
                return LexerError(self, "EOL while scanning string literal");
            else {
                c11_sbuf__write_char(buff, c);
                continue;
            }
        }
        if(!is_raw && c == '\\') {
            switch(eatchar_include_newline(self)) {
                case '"': c11_sbuf__write_char(buff, '"'); break;
                case '\'': c11_sbuf__write_char(buff, '\''); break;
                case '\\': c11_sbuf__write_char(buff, '\\'); break;
                case 'n': c11_sbuf__write_char(buff, '\n'); break;
                case 'r': c11_sbuf__write_char(buff, '\r'); break;
                case 't': c11_sbuf__write_char(buff, '\t'); break;
                case 'b': c11_sbuf__write_char(buff, '\b'); break;
                case 'x': {
                    char hex[3] = {eatchar(self), eatchar(self), '\0'};
                    int code;
                    if (sscanf(hex, "%x", &code) != 1 || code > 0xFF) {
                        return LexerError(self, "invalid hex escape");
                    }
                    if (type == NORMAL_BYTES) {
                        // Bytes literals: write raw byte
                        c11_sbuf__write_char(buff, (char)code);
                    } else {
                        // Regular strings: encode as UTF-8
                        if (code <= 0x7F) {
                            c11_sbuf__write_char(buff, (char)code);
                        } else {
                            // Encode as 2-byte UTF-8 for code points 0x80-0xFF
                            c11_sbuf__write_char(buff, 0xC0 | (code >> 6));        // Leading byte
                            c11_sbuf__write_char(buff, 0x80 | (code & 0x3F));      // Continuation byte
                        }
                    }
                } break;
                default: return LexerError(self, "invalid escape char");
            }
        } else {
            if(is_fstring) {
                if(c == '{') {
                    if(matchchar(self, '{')) {
                        // '{{' -> '{'
                        c11_sbuf__write_char(buff, '{');
                    } else {
                        // submit previous string
                        c11_string* res = c11_sbuf__submit(buff);
                        if(res->size > 0) {
                            TokenValue value = {TokenValue_STR, ._str = res};
                            add_token_with_value(self, TK_FSTR_CPNT, value);
                        } else {
                            c11_string__delete(res);
                        }
                        c11_sbuf__ctor(buff);  // re-init buffer

                        // submit {expr} tokens
                        bool eof = false;
                        int token_count = self->nexts.length;
                        while(!eof) {
                            Error* err = lex_one_token(self, &eof, true);
                            if(err) return err;
                        }
                        if(self->nexts.length == token_count) {
                            // f'{}' is not allowed
                            return LexerError(self, "f-string: empty expression not allowed");
                        }
                    }
                } else if(c == '}') {
                    if(matchchar(self, '}')) {
                        // '}}' -> '}'
                        c11_sbuf__write_char(buff, '}');
                    } else {
                        return LexerError(self, "f-string: single '}' is not allowed");
                    }
                } else {
                    c11_sbuf__write_char(buff, c);
                }
            } else {
                c11_sbuf__write_char(buff, c);
            }
        }
    }

    c11_string* res = c11_sbuf__submit(buff);
    TokenValue value = {TokenValue_STR, ._str = res};

    if(is_fstring) {
        if(res->size > 0) {
            add_token_with_value(self, TK_FSTR_CPNT, value);
        } else {
            c11_string__delete(res);
        }
        add_token(self, TK_FSTR_END);
        return NULL;
    }

    if(type == NORMAL_BYTES) {
        add_token_with_value(self, TK_BYTES, value);
    } else {
        add_token_with_value(self, TK_STR, value);
    }
    return NULL;
}

static Error* eat_string(Lexer* self, char quote, enum StringType type) {
    c11_sbuf buff;
    c11_sbuf__ctor(&buff);
    Error* err = _eat_string(self, &buff, quote, type);
    c11_sbuf__dtor(&buff);
    return err;
}

static Error* eat_number(Lexer* self) {
    const char* i = self->token_start;
    while(is_possible_number_char(*i))
        i++;

    bool is_scientific_notation = false;
    if(*(i - 1) == 'e' && (*i == '+' || *i == '-')) {
        i++;
        while(isdigit(*i) || *i == 'j')
            i++;
        is_scientific_notation = true;
    }

    c11_sv text = {self->token_start, i - self->token_start};
    self->curr_char = i;

    if(text.data[0] != '.' && !is_scientific_notation) {
        // try integer
        TokenValue value = {.index = TokenValue_I64};
        switch(c11__parse_uint(text, &value._i64, -1)) {
            case IntParsing_SUCCESS: add_token_with_value(self, TK_NUM, value); return NULL;
            case IntParsing_OVERFLOW: return LexerError(self, "int literal is too large");
            case IntParsing_FAILURE: break;  // do nothing
        }
    }

    // try float
    double float_out;
    char* p_end;
    float_out = strtod(text.data, &p_end);

    if(p_end == text.data + text.size) {
        TokenValue value = {.index = TokenValue_F64, ._f64 = float_out};
        add_token_with_value(self, TK_NUM, value);
        return NULL;
    }

    if(i[-1] == 'j' && p_end == text.data + text.size - 1) {
        TokenValue value = {.index = TokenValue_F64, ._f64 = float_out};
        add_token_with_value(self, TK_IMAG, value);
        return NULL;
    }

    return LexerError(self, "invalid number literal");
}

static Error* eat_fstring_spec(Lexer* self, bool* eof) {
    while(true) {
        char c = eatchar_include_newline(self);
        if(c == '\n' || c == '\0') {
            return LexerError(self, "EOL while scanning f-string format spec");
        }
        if(c == '}') {
            add_token(self, TK_FSTR_SPEC);
            *eof = true;
            break;
        }
    }
    return NULL;
}

static Error* lex_one_token(Lexer* self, bool* eof, bool is_fstring) {
    *eof = false;
    while(*self->curr_char) {
        self->token_start = self->curr_char;
        char c = eatchar_include_newline(self);
        switch(c) {
            case '\'':
            case '"': {
                Error* err = eat_string(self, c, NORMAL_STRING);
                if(err) return err;
                return NULL;
            }
            case '#': skip_line_comment(self); break;
            case '~': add_token(self, TK_INVERT); return NULL;
            case '{': add_token(self, TK_LBRACE); return NULL;
            case '}': {
                if(is_fstring) {
                    *eof = true;
                    return NULL;
                }
                add_token(self, TK_RBRACE);
                return NULL;
            }
            case ',': add_token(self, TK_COMMA); return NULL;
            case ':': {
                if(is_fstring) {
                    // BUG: f"{stack[2:]}"
                    return eat_fstring_spec(self, eof);
                }
                add_token(self, TK_COLON);
                return NULL;
            }
            case ';': add_token(self, TK_SEMICOLON); return NULL;
            case '(': add_token(self, TK_LPAREN); return NULL;
            case ')': add_token(self, TK_RPAREN); return NULL;
            case '[': add_token(self, TK_LBRACKET); return NULL;
            case ']': add_token(self, TK_RBRACKET); return NULL;
            case '@': add_token(self, TK_DECORATOR); return NULL;
            case '\\': {
                // line continuation character
                char c = eatchar_include_newline(self);
                if(c != '\n') {
                    return LexerError(self, "expected newline after line continuation character");
                }
                eat_spaces(self);
                return NULL;
            }
            case '%': add_token_2(self, '=', TK_MOD, TK_IMOD); return NULL;
            case '&': add_token_2(self, '=', TK_AND, TK_IAND); return NULL;
            case '|': add_token_2(self, '=', TK_OR, TK_IOR); return NULL;
            case '^': add_token_2(self, '=', TK_XOR, TK_IXOR); return NULL;
            case '.': {
                if(matchchar(self, '.')) {
                    if(matchchar(self, '.')) {
                        add_token(self, TK_DOTDOTDOT);
                    } else {
                        add_token(self, TK_DOTDOT);
                    }
                } else {
                    char next_char = *self->curr_char;
                    if(next_char >= '0' && next_char <= '9') {
                        Error* err = eat_number(self);
                        if(err) return err;
                    } else {
                        add_token(self, TK_DOT);
                    }
                }
                return NULL;
            }
            case '=': add_token_2(self, '=', TK_ASSIGN, TK_EQ); return NULL;
            case '+': add_token_2(self, '=', TK_ADD, TK_IADD); return NULL;
            case '>': {
                if(matchchar(self, '='))
                    add_token(self, TK_GE);
                else if(matchchar(self, '>'))
                    add_token_2(self, '=', TK_RSHIFT, TK_IRSHIFT);
                else
                    add_token(self, TK_GT);
                return NULL;
            }
            case '<': {
                if(matchchar(self, '='))
                    add_token(self, TK_LE);
                else if(matchchar(self, '<'))
                    add_token_2(self, '=', TK_LSHIFT, TK_ILSHIFT);
                else
                    add_token(self, TK_LT);
                return NULL;
            }
            case '-': {
                if(matchchar(self, '='))
                    add_token(self, TK_ISUB);
                else if(matchchar(self, '>'))
                    add_token(self, TK_ARROW);
                else
                    add_token(self, TK_SUB);
                return NULL;
            }
            case '!':
                if(is_fstring) {
                    if(matchchar(self, 'r')) { return eat_fstring_spec(self, eof); }
                }
                if(matchchar(self, '=')) {
                    add_token(self, TK_NE);
                    return NULL;
                } else {
                    return LexerError(self, "expected '=' after '!'");
                }
            case '*':
                if(matchchar(self, '*')) {
                    add_token(self, TK_POW);  // '**'
                } else {
                    add_token_2(self, '=', TK_MUL, TK_IMUL);
                }
                return NULL;
            case '/':
                if(matchchar(self, '/')) {
                    add_token_2(self, '=', TK_FLOORDIV, TK_IFLOORDIV);
                } else {
                    add_token_2(self, '=', TK_DIV, TK_IDIV);
                }
                return NULL;
            case ' ':
            case '\t': eat_spaces(self); break;
            case '\n': {
                add_token(self, TK_EOL);
                if(!eat_indentation(self)) {
                    return LexerError(self, "unindent does not match any outer indentation level");
                }
                return NULL;
            }
            default: {
                if(c == 'f') {
                    if(matchchar(self, '\'')) return eat_string(self, '\'', F_STRING);
                    if(matchchar(self, '"')) return eat_string(self, '"', F_STRING);
                } else if(c == 'r') {
                    if(matchchar(self, '\'')) return eat_string(self, '\'', RAW_STRING);
                    if(matchchar(self, '"')) return eat_string(self, '"', RAW_STRING);
                } else if(c == 'b') {
                    if(matchchar(self, '\'')) return eat_string(self, '\'', NORMAL_BYTES);
                    if(matchchar(self, '"')) return eat_string(self, '"', NORMAL_BYTES);
                }
                if(c >= '0' && c <= '9') return eat_number(self);
                return eat_name(self);
            }
        }
    }

    if(is_fstring) return LexerError(self, "unterminated f-string expression");

    self->token_start = self->curr_char;
    while(self->indents.length > 1) {
        c11_vector__pop(&self->indents);
        add_token(self, TK_DEDENT);
        return NULL;
    }
    add_token(self, TK_EOF);
    *eof = true;
    return NULL;
}

Error* Lexer__process(SourceData_ src, Token** out_tokens, int* out_length) {
    Lexer lexer;
    Lexer__ctor(&lexer, src);

    // push initial tokens
    Token sof =
        {TK_SOF, lexer.token_start, 0, lexer.current_line, lexer.brackets_level, EmptyTokenValue};
    c11_vector__push(Token, &lexer.nexts, sof);
    c11_vector__push(int, &lexer.indents, 0);

    bool eof = false;
    while(!eof) {
        void* err = lex_one_token(&lexer, &eof, false);
        if(err) {
            Lexer__dtor(&lexer);
            return err;
        }
    }
    // set out_tokens
    *out_tokens = c11_vector__submit(&lexer.nexts, out_length);

    Lexer__dtor(&lexer);
    return NULL;
}

const char* TokenSymbols[] = {
    "@eof",
    "@eol",
    "@sof",
    "@id",
    "@num",
    "@str",
    "@fstr-begin",  // TK_FSTR_BEGIN
    "@fstr-cpnt",   // TK_FSTR_CPNT
    "@fstr-spec",   // TK_FSTR_SPEC
    "@fstr-end",    // TK_FSTR_END
    "@bytes",
    "@imag",
    "@indent",
    "@dedent",
    // These 3 are compound keywords which are generated on the fly
    "is not",
    "not in",
    "yield from",
    /*****************************************/
    "+",
    "+=",
    "-",
    "-=",  // (INPLACE_OP - 1) can get '=' removed
    "*",
    "*=",
    "/",
    "/=",
    "//",
    "//=",
    "%",
    "%=",
    "&",
    "&=",
    "|",
    "|=",
    "^",
    "^=",
    "<<",
    "<<=",
    ">>",
    ">>=",
    /*****************************************/
    "(",
    ")",
    "[",
    "]",
    "{",
    "}",
    ".",
    "..",
    "...",
    ",",
    ":",
    ";",
    "**",
    "->",
    "#",
    "@",
    ">",
    "<",
    "=",
    "==",
    "!=",
    ">=",
    "<=",
    "~",
    /** KW_BEGIN **/
    // NOTE: These keywords should be sorted in ascending order!!
    "False",
    "None",
    "True",
    "and",
    "as",
    "assert",
    "break",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield",
};

#undef is_raw_string_used
// src/compiler/compiler.c
#include <assert.h>
#include <stdbool.h>

/* expr.h */
typedef struct Expr Expr;
typedef struct Ctx Ctx;

typedef struct ExprVt {
    /* emit */
    void (*emit_)(Expr*, Ctx*);
    bool (*emit_del)(Expr*, Ctx*);
    bool (*emit_store)(Expr*, Ctx*);
    void (*emit_inplace)(Expr*, Ctx*);
    bool (*emit_istore)(Expr*, Ctx*);
    /* reflections */
    bool is_literal;
    bool is_name;     // NameExpr
    bool is_tuple;    // TupleExpr
    bool is_attrib;   // AttribExpr
    bool is_subscr;   // SubscrExpr
    bool is_starred;  // StarredExpr
    bool is_binary;   // BinaryExpr
    void (*dtor)(Expr*);
} ExprVt;

#define vtcall(f, self, ctx) ((self)->vt->f((self), (ctx)))
#define vtemit_(self, ctx) vtcall(emit_, (self), (ctx))
#define vtemit_del(self, ctx) ((self)->vt->emit_del ? vtcall(emit_del, self, ctx) : false)
#define vtemit_store(self, ctx) ((self)->vt->emit_store ? vtcall(emit_store, self, ctx) : false)
#define vtemit_inplace(self, ctx)                                                                  \
    ((self)->vt->emit_inplace ? vtcall(emit_inplace, self, ctx) : vtemit_(self, ctx))
#define vtemit_istore(self, ctx)                                                                   \
    ((self)->vt->emit_istore ? vtcall(emit_istore, self, ctx) : vtemit_store(self, ctx))
#define vtdelete(self)                                                                             \
    do {                                                                                           \
        if(self) {                                                                                 \
            if((self)->vt->dtor) (self)->vt->dtor(self);                                           \
            PK_FREE(self);                                                                         \
        }                                                                                          \
    } while(0)

#define EXPR_COMMON_HEADER                                                                         \
    const ExprVt* vt;                                                                              \
    int line;

typedef struct Expr {
    EXPR_COMMON_HEADER
} Expr;

/* context.h */
typedef struct Ctx {
    CodeObject* co;  // 1 CodeEmitContext <=> 1 CodeObject*
    FuncDecl* func;  // optional, weakref
    int level;
    int curr_iblock;
    bool is_compiling_class;
    c11_vector /*T=Expr* */ s_expr;
    c11_smallmap_n2i global_names;
    c11_smallmap_s2n co_consts_string_dedup_map;
} Ctx;

typedef struct Expr Expr;

static void Ctx__ctor(Ctx* self, CodeObject* co, FuncDecl* func, int level);
static void Ctx__dtor(Ctx* self);
static int Ctx__prepare_loop_divert(Ctx* self, int line, bool is_break);
static int Ctx__enter_block(Ctx* self, CodeBlockType type);
static void Ctx__exit_block(Ctx* self);
static int Ctx__emit_(Ctx* self, Opcode opcode, uint16_t arg, int line);
static int Ctx__emit_virtual(Ctx* self, Opcode opcode, uint16_t arg, int line, bool virtual);
static void Ctx__revert_last_emit_(Ctx* self);
static int Ctx__emit_int(Ctx* self, int64_t value, int line);
static void Ctx__patch_jump(Ctx* self, int index);
static void Ctx__emit_jump(Ctx* self, int target, int line);
static int Ctx__add_varname(Ctx* self, py_Name name);
static int Ctx__add_const(Ctx* self, py_Ref);
static int Ctx__add_const_string(Ctx* self, c11_sv);
static void Ctx__emit_store_name(Ctx* self, NameScope scope, py_Name name, int line);
static void Ctx__s_emit_top(Ctx*);     // emit top -> pop -> delete
static void Ctx__s_push(Ctx*, Expr*);  // push
static Expr* Ctx__s_top(Ctx*);         // top
static int Ctx__s_size(Ctx*);          // size
static void Ctx__s_pop(Ctx*);          // pop -> delete
static Expr* Ctx__s_popx(Ctx*);        // pop move
static void Ctx__s_emit_decorators(Ctx*, int count);

/* expr.c */
typedef struct NameExpr {
    EXPR_COMMON_HEADER
    py_Name name;
    NameScope scope;
} NameExpr;

void NameExpr__emit_(Expr* self_, Ctx* ctx) {
    NameExpr* self = (NameExpr*)self_;
    int index = c11_smallmap_n2i__get(&ctx->co->varnames_inv, self->name, -1);
    if(self->scope == NAME_LOCAL && index >= 0) {
        // we know this is a local variable
        Ctx__emit_(ctx, OP_LOAD_FAST, index, self->line);
    } else {
        Opcode op = ctx->level <= 1 ? OP_LOAD_GLOBAL : OP_LOAD_NONLOCAL;
        if(self->scope == NAME_GLOBAL) {
            if(ctx->co->src->is_dynamic) {
                op = OP_LOAD_NAME;
            } else {
                if(ctx->is_compiling_class) {
                    // if we are compiling a class, we should use `OP_LOAD_CLASS_GLOBAL`
                    // this is for @property.setter
                    op = OP_LOAD_CLASS_GLOBAL;
                }
            }
        }
        Ctx__emit_(ctx, op, self->name, self->line);
    }
}

bool NameExpr__emit_del(Expr* self_, Ctx* ctx) {
    NameExpr* self = (NameExpr*)self_;
    switch(self->scope) {
        case NAME_LOCAL:
            Ctx__emit_(ctx, OP_DELETE_FAST, Ctx__add_varname(ctx, self->name), self->line);
            break;
        case NAME_GLOBAL: {
            Opcode op = ctx->co->src->is_dynamic ? OP_DELETE_NAME : OP_DELETE_GLOBAL;
            Ctx__emit_(ctx, op, self->name, self->line);
            break;
        }
        default: c11__unreachable();
    }
    return true;
}

bool NameExpr__emit_store(Expr* self_, Ctx* ctx) {
    NameExpr* self = (NameExpr*)self_;
    if(ctx->is_compiling_class) {
        Ctx__emit_(ctx, OP_STORE_CLASS_ATTR, self->name, self->line);
        return true;
    }
    Ctx__emit_store_name(ctx, self->scope, self->name, self->line);
    return true;
}

NameExpr* NameExpr__new(int line, py_Name name, NameScope scope) {
    const static ExprVt Vt = {.emit_ = NameExpr__emit_,
                              .emit_del = NameExpr__emit_del,
                              .emit_store = NameExpr__emit_store,
                              .is_name = true};
    NameExpr* self = PK_MALLOC(sizeof(NameExpr));
    self->vt = &Vt;
    self->line = line;
    self->name = name;
    self->scope = scope;
    return self;
}

typedef struct StarredExpr {
    EXPR_COMMON_HEADER
    Expr* child;
    int level;
} StarredExpr;

void StarredExpr__emit_(Expr* self_, Ctx* ctx) {
    StarredExpr* self = (StarredExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, OP_UNARY_STAR, self->level, self->line);
}

bool StarredExpr__emit_store(Expr* self_, Ctx* ctx) {
    StarredExpr* self = (StarredExpr*)self_;
    if(self->level != 1) return false;
    // simply proxy to child
    return vtemit_store(self->child, ctx);
}

void StarredExpr__dtor(Expr* self_) {
    StarredExpr* self = (StarredExpr*)self_;
    vtdelete(self->child);
}

StarredExpr* StarredExpr__new(int line, Expr* child, int level) {
    const static ExprVt Vt = {.emit_ = StarredExpr__emit_,
                              .emit_store = StarredExpr__emit_store,
                              .is_starred = true,
                              .dtor = StarredExpr__dtor};
    StarredExpr* self = PK_MALLOC(sizeof(StarredExpr));
    self->vt = &Vt;
    self->line = line;
    self->child = child;
    self->level = level;
    return self;
}

// InvertExpr, NotExpr, NegatedExpr
// NOTE: NegatedExpr always contains a non-const child. Should not generate -1 or -0.1
typedef struct UnaryExpr {
    EXPR_COMMON_HEADER
    Expr* child;
    Opcode opcode;
} UnaryExpr;

void UnaryExpr__dtor(Expr* self_) {
    UnaryExpr* self = (UnaryExpr*)self_;
    vtdelete(self->child);
}

static void UnaryExpr__emit_(Expr* self_, Ctx* ctx) {
    UnaryExpr* self = (UnaryExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, self->opcode, BC_NOARG, self->line);
}

UnaryExpr* UnaryExpr__new(int line, Expr* child, Opcode opcode) {
    const static ExprVt Vt = {.emit_ = UnaryExpr__emit_, .dtor = UnaryExpr__dtor};
    UnaryExpr* self = PK_MALLOC(sizeof(UnaryExpr));
    self->vt = &Vt;
    self->line = line;
    self->child = child;
    self->opcode = opcode;
    return self;
}

typedef struct FStringSpecExpr {
    EXPR_COMMON_HEADER
    Expr* child;
    c11_sv spec;
} FStringSpecExpr;

void FStringSpecExpr__emit_(Expr* self_, Ctx* ctx) {
    FStringSpecExpr* self = (FStringSpecExpr*)self_;
    vtemit_(self->child, ctx);
    int index = Ctx__add_const_string(ctx, self->spec);
    Ctx__emit_(ctx, OP_FORMAT_STRING, index, self->line);
}

FStringSpecExpr* FStringSpecExpr__new(int line, Expr* child, c11_sv spec) {
    const static ExprVt Vt = {.emit_ = FStringSpecExpr__emit_, .dtor = UnaryExpr__dtor};
    FStringSpecExpr* self = PK_MALLOC(sizeof(FStringSpecExpr));
    self->vt = &Vt;
    self->line = line;
    self->child = child;
    self->spec = spec;
    return self;
}

typedef struct RawStringExpr {
    EXPR_COMMON_HEADER
    c11_sv value;
    Opcode opcode;
} RawStringExpr;

void RawStringExpr__emit_(Expr* self_, Ctx* ctx) {
    RawStringExpr* self = (RawStringExpr*)self_;
    int index = Ctx__add_const_string(ctx, self->value);
    Ctx__emit_(ctx, self->opcode, index, self->line);
}

RawStringExpr* RawStringExpr__new(int line, c11_sv value, Opcode opcode) {
    const static ExprVt Vt = {.emit_ = RawStringExpr__emit_};
    RawStringExpr* self = PK_MALLOC(sizeof(RawStringExpr));
    self->vt = &Vt;
    self->line = line;
    self->value = value;
    self->opcode = opcode;
    return self;
}

typedef struct ImagExpr {
    EXPR_COMMON_HEADER
    double value;
} ImagExpr;

void ImagExpr__emit_(Expr* self_, Ctx* ctx) {
    ImagExpr* self = (ImagExpr*)self_;
    py_TValue value;
    py_newfloat(&value, self->value);
    int index = Ctx__add_const(ctx, &value);
    Ctx__emit_(ctx, OP_LOAD_CONST, index, self->line);
    Ctx__emit_(ctx, OP_BUILD_IMAG, BC_NOARG, self->line);
}

ImagExpr* ImagExpr__new(int line, double value) {
    const static ExprVt Vt = {.emit_ = ImagExpr__emit_};
    ImagExpr* self = PK_MALLOC(sizeof(ImagExpr));
    self->vt = &Vt;
    self->line = line;
    self->value = value;
    return self;
}

typedef struct LiteralExpr {
    EXPR_COMMON_HEADER
    const TokenValue* value;
    bool negated;
} LiteralExpr;

void LiteralExpr__emit_(Expr* self_, Ctx* ctx) {
    LiteralExpr* self = (LiteralExpr*)self_;
    switch(self->value->index) {
        case TokenValue_I64: {
            py_i64 val = self->value->_i64;
            if(self->negated) val = -val;
            Ctx__emit_int(ctx, val, self->line);
            break;
        }
        case TokenValue_F64: {
            py_TValue value;
            py_f64 val = self->value->_f64;
            if(self->negated) val = -val;
            py_newfloat(&value, val);
            int index = Ctx__add_const(ctx, &value);
            Ctx__emit_(ctx, OP_LOAD_CONST, index, self->line);
            break;
        }
        case TokenValue_STR: {
            assert(!self->negated);
            c11_sv sv = c11_string__sv(self->value->_str);
            int index = Ctx__add_const_string(ctx, sv);
            Ctx__emit_(ctx, OP_LOAD_CONST, index, self->line);
            break;
        }
        default: c11__unreachable();
    }
}

LiteralExpr* LiteralExpr__new(int line, const TokenValue* value) {
    const static ExprVt Vt = {.emit_ = LiteralExpr__emit_, .is_literal = true};
    LiteralExpr* self = PK_MALLOC(sizeof(LiteralExpr));
    self->vt = &Vt;
    self->line = line;
    self->value = value;
    self->negated = false;
    return self;
}

typedef struct Literal0Expr {
    EXPR_COMMON_HEADER
    TokenIndex token;
} Literal0Expr;

void Literal0Expr__emit_(Expr* self_, Ctx* ctx) {
    Literal0Expr* self = (Literal0Expr*)self_;
    Opcode opcode;
    switch(self->token) {
        case TK_NONE: opcode = OP_LOAD_NONE; break;
        case TK_TRUE: opcode = OP_LOAD_TRUE; break;
        case TK_FALSE: opcode = OP_LOAD_FALSE; break;
        case TK_DOTDOTDOT: opcode = OP_LOAD_ELLIPSIS; break;
        default: c11__unreachable();
    }
    Ctx__emit_(ctx, opcode, BC_NOARG, self->line);
}

Literal0Expr* Literal0Expr__new(int line, TokenIndex token) {
    const static ExprVt Vt = {.emit_ = Literal0Expr__emit_};
    Literal0Expr* self = PK_MALLOC(sizeof(Literal0Expr));
    self->vt = &Vt;
    self->line = line;
    self->token = token;
    return self;
}

typedef struct SliceExpr {
    EXPR_COMMON_HEADER
    Expr* start;
    Expr* stop;
    Expr* step;
} SliceExpr;

void SliceExpr__dtor(Expr* self_) {
    SliceExpr* self = (SliceExpr*)self_;
    vtdelete(self->start);
    vtdelete(self->stop);
    vtdelete(self->step);
}

void SliceExpr__emit_(Expr* self_, Ctx* ctx) {
    SliceExpr* self = (SliceExpr*)self_;
    if(self->start)
        vtemit_(self->start, ctx);
    else
        Ctx__emit_(ctx, OP_LOAD_NONE, BC_NOARG, self->line);
    if(self->stop)
        vtemit_(self->stop, ctx);
    else
        Ctx__emit_(ctx, OP_LOAD_NONE, BC_NOARG, self->line);
    if(self->step)
        vtemit_(self->step, ctx);
    else
        Ctx__emit_(ctx, OP_LOAD_NONE, BC_NOARG, self->line);
    Ctx__emit_(ctx, OP_BUILD_SLICE, BC_NOARG, self->line);
}

SliceExpr* SliceExpr__new(int line) {
    const static ExprVt Vt = {.dtor = SliceExpr__dtor, .emit_ = SliceExpr__emit_};
    SliceExpr* self = PK_MALLOC(sizeof(SliceExpr));
    self->vt = &Vt;
    self->line = line;
    self->start = NULL;
    self->stop = NULL;
    self->step = NULL;
    return self;
}

typedef struct DictItemExpr {
    EXPR_COMMON_HEADER
    Expr* key;
    Expr* value;
} DictItemExpr;

static void DictItemExpr__dtor(Expr* self_) {
    DictItemExpr* self = (DictItemExpr*)self_;
    vtdelete(self->key);
    vtdelete(self->value);
}

static void DictItemExpr__emit_(Expr* self_, Ctx* ctx) {
    DictItemExpr* self = (DictItemExpr*)self_;
    vtemit_(self->key, ctx);
    vtemit_(self->value, ctx);
}

static DictItemExpr* DictItemExpr__new(int line) {
    const static ExprVt Vt = {.dtor = DictItemExpr__dtor, .emit_ = DictItemExpr__emit_};
    DictItemExpr* self = PK_MALLOC(sizeof(DictItemExpr));
    self->vt = &Vt;
    self->line = line;
    self->key = NULL;
    self->value = NULL;
    return self;
}

// ListExpr, DictExpr, SetExpr, TupleExpr
typedef struct SequenceExpr {
    EXPR_COMMON_HEADER
    Expr** items;
    int itemCount;
    Opcode opcode;
} SequenceExpr;

static void SequenceExpr__emit_(Expr* self_, Ctx* ctx) {
    SequenceExpr* self = (SequenceExpr*)self_;
    for(int i = 0; i < self->itemCount; i++) {
        Expr* item = self->items[i];
        vtemit_(item, ctx);
    }
    Ctx__emit_(ctx, self->opcode, self->itemCount, self->line);
}

void SequenceExpr__dtor(Expr* self_) {
    SequenceExpr* self = (SequenceExpr*)self_;
    for(int i = 0; i < self->itemCount; i++) {
        vtdelete(self->items[i]);
    }
    PK_FREE(self->items);
}

bool TupleExpr__emit_store(Expr* self_, Ctx* ctx) {
    SequenceExpr* self = (SequenceExpr*)self_;
    // TOS is an iterable
    // items may contain StarredExpr, we should check it
    int starred_i = -1;
    for(int i = 0; i < self->itemCount; i++) {
        Expr* e = self->items[i];
        if(e->vt->is_starred) {
            if(((StarredExpr*)e)->level > 0) {
                if(starred_i == -1)
                    starred_i = i;
                else
                    return false;  // multiple StarredExpr not allowed
            }
        }
    }

    if(starred_i == -1) {
        Bytecode* prev = c11__at(Bytecode, &ctx->co->codes, ctx->co->codes.length - 1);
        if(prev->op == OP_BUILD_TUPLE && prev->arg == self->itemCount) {
            // build tuple and unpack it is meaningless
            Ctx__revert_last_emit_(ctx);
        } else {
            Ctx__emit_(ctx, OP_UNPACK_SEQUENCE, self->itemCount, self->line);
        }
    } else {
        // starred assignment target must be in a tuple
        if(self->itemCount == 1) return false;
        // starred assignment target must be the last one (differ from cpython)
        if(starred_i != self->itemCount - 1) return false;
        // a,*b = [1,2,3]
        // stack is [1,2,3] -> [1,[2,3]]
        Ctx__emit_(ctx, OP_UNPACK_EX, self->itemCount - 1, self->line);
    }
    // do reverse emit
    for(int i = self->itemCount - 1; i >= 0; i--) {
        Expr* e = self->items[i];
        bool ok = vtemit_store(e, ctx);
        if(!ok) return false;
    }
    return true;
}

bool TupleExpr__emit_del(Expr* self_, Ctx* ctx) {
    SequenceExpr* self = (SequenceExpr*)self_;
    for(int i = 0; i < self->itemCount; i++) {
        Expr* e = self->items[i];
        bool ok = vtemit_del(e, ctx);
        if(!ok) return false;
    }
    return true;
}

static SequenceExpr* SequenceExpr__new(int line, const ExprVt* vt, int count, Opcode opcode) {
    SequenceExpr* self = PK_MALLOC(sizeof(SequenceExpr));
    self->vt = vt;
    self->line = line;
    self->opcode = opcode;
    self->items = PK_MALLOC(sizeof(Expr*) * count);
    self->itemCount = count;
    return self;
}

SequenceExpr* FStringExpr__new(int line, int count) {
    const static ExprVt ListExprVt = {.dtor = SequenceExpr__dtor, .emit_ = SequenceExpr__emit_};
    return SequenceExpr__new(line, &ListExprVt, count, OP_BUILD_STRING);
}

SequenceExpr* ListExpr__new(int line, int count) {
    const static ExprVt ListExprVt = {.dtor = SequenceExpr__dtor, .emit_ = SequenceExpr__emit_};
    return SequenceExpr__new(line, &ListExprVt, count, OP_BUILD_LIST);
}

SequenceExpr* DictExpr__new(int line, int count) {
    const static ExprVt DictExprVt = {.dtor = SequenceExpr__dtor, .emit_ = SequenceExpr__emit_};
    return SequenceExpr__new(line, &DictExprVt, count, OP_BUILD_DICT);
}

SequenceExpr* SetExpr__new(int line, int count) {
    const static ExprVt SetExprVt = {
        .dtor = SequenceExpr__dtor,
        .emit_ = SequenceExpr__emit_,
    };
    return SequenceExpr__new(line, &SetExprVt, count, OP_BUILD_SET);
}

SequenceExpr* TupleExpr__new(int line, int count) {
    const static ExprVt TupleExprVt = {.dtor = SequenceExpr__dtor,
                                       .emit_ = SequenceExpr__emit_,
                                       .is_tuple = true,
                                       .emit_store = TupleExpr__emit_store,
                                       .emit_del = TupleExpr__emit_del};
    return SequenceExpr__new(line, &TupleExprVt, count, OP_BUILD_TUPLE);
}

typedef struct CompExpr {
    EXPR_COMMON_HEADER
    Expr* expr;  // loop expr
    Expr* vars;  // loop vars
    Expr* iter;  // loop iter
    Expr* cond;  // optional if condition

    Opcode op0;
    Opcode op1;
} CompExpr;

void CompExpr__dtor(Expr* self_) {
    CompExpr* self = (CompExpr*)self_;
    vtdelete(self->expr);
    vtdelete(self->vars);
    vtdelete(self->iter);
    vtdelete(self->cond);
}

void CompExpr__emit_(Expr* self_, Ctx* ctx) {
    CompExpr* self = (CompExpr*)self_;
    Ctx__emit_(ctx, self->op0, 0, self->line);
    vtemit_(self->iter, ctx);
    Ctx__emit_(ctx, OP_GET_ITER, BC_NOARG, BC_KEEPLINE);
    int block = Ctx__enter_block(ctx, CodeBlockType_FOR_LOOP);
    int block_start = Ctx__emit_(ctx, OP_FOR_ITER, block, BC_KEEPLINE);
    bool ok = vtemit_store(self->vars, ctx);
    // this error occurs in `vars` instead of this line, but...nevermind
    assert(ok);  // this should raise a SyntaxError, but we just assert it
    if(self->cond) {
        vtemit_(self->cond, ctx);
        int patch = Ctx__emit_(ctx, OP_POP_JUMP_IF_FALSE, BC_NOARG, BC_KEEPLINE);
        vtemit_(self->expr, ctx);
        Ctx__emit_(ctx, self->op1, BC_NOARG, BC_KEEPLINE);
        Ctx__patch_jump(ctx, patch);
    } else {
        vtemit_(self->expr, ctx);
        Ctx__emit_(ctx, self->op1, BC_NOARG, BC_KEEPLINE);
    }
    Ctx__emit_jump(ctx, block_start, BC_KEEPLINE);
    Ctx__exit_block(ctx);
}

CompExpr* CompExpr__new(int line, Opcode op0, Opcode op1) {
    const static ExprVt Vt = {.dtor = CompExpr__dtor, .emit_ = CompExpr__emit_};
    CompExpr* self = PK_MALLOC(sizeof(CompExpr));
    self->vt = &Vt;
    self->line = line;
    self->op0 = op0;
    self->op1 = op1;
    self->expr = NULL;
    self->vars = NULL;
    self->iter = NULL;
    self->cond = NULL;
    return self;
}

typedef struct LambdaExpr {
    EXPR_COMMON_HEADER
    int index;
} LambdaExpr;

static void LambdaExpr__emit_(Expr* self_, Ctx* ctx) {
    LambdaExpr* self = (LambdaExpr*)self_;
    Ctx__emit_(ctx, OP_LOAD_FUNCTION, self->index, self->line);
}

LambdaExpr* LambdaExpr__new(int line, int index) {
    const static ExprVt Vt = {.emit_ = LambdaExpr__emit_};
    LambdaExpr* self = PK_MALLOC(sizeof(LambdaExpr));
    self->vt = &Vt;
    self->line = line;
    self->index = index;
    return self;
}

// AndExpr, OrExpr
typedef struct LogicBinaryExpr {
    EXPR_COMMON_HEADER
    Expr* lhs;
    Expr* rhs;
    Opcode opcode;
} LogicBinaryExpr;

void LogicBinaryExpr__dtor(Expr* self_) {
    LogicBinaryExpr* self = (LogicBinaryExpr*)self_;
    vtdelete(self->lhs);
    vtdelete(self->rhs);
}

void LogicBinaryExpr__emit_(Expr* self_, Ctx* ctx) {
    LogicBinaryExpr* self = (LogicBinaryExpr*)self_;
    vtemit_(self->lhs, ctx);
    int patch = Ctx__emit_(ctx, self->opcode, BC_NOARG, self->line);
    vtemit_(self->rhs, ctx);
    Ctx__patch_jump(ctx, patch);
}

LogicBinaryExpr* LogicBinaryExpr__new(int line, Opcode opcode) {
    const static ExprVt Vt = {.emit_ = LogicBinaryExpr__emit_, .dtor = LogicBinaryExpr__dtor};
    LogicBinaryExpr* self = PK_MALLOC(sizeof(LogicBinaryExpr));
    self->vt = &Vt;
    self->line = line;
    self->lhs = NULL;
    self->rhs = NULL;
    self->opcode = opcode;
    return self;
}

typedef struct GroupedExpr {
    EXPR_COMMON_HEADER
    Expr* child;
} GroupedExpr;

void GroupedExpr__dtor(Expr* self_) {
    GroupedExpr* self = (GroupedExpr*)self_;
    vtdelete(self->child);
}

void GroupedExpr__emit_(Expr* self_, Ctx* ctx) {
    GroupedExpr* self = (GroupedExpr*)self_;
    vtemit_(self->child, ctx);
}

bool GroupedExpr__emit_del(Expr* self_, Ctx* ctx) {
    GroupedExpr* self = (GroupedExpr*)self_;
    return vtemit_del(self->child, ctx);
}

bool GroupedExpr__emit_store(Expr* self_, Ctx* ctx) {
    GroupedExpr* self = (GroupedExpr*)self_;
    return vtemit_store(self->child, ctx);
}

GroupedExpr* GroupedExpr__new(int line, Expr* child) {
    const static ExprVt Vt = {.dtor = GroupedExpr__dtor,
                              .emit_ = GroupedExpr__emit_,
                              .emit_del = GroupedExpr__emit_del,
                              .emit_store = GroupedExpr__emit_store};
    GroupedExpr* self = PK_MALLOC(sizeof(GroupedExpr));
    self->vt = &Vt;
    self->line = line;
    self->child = child;
    return self;
}

typedef struct BinaryExpr {
    EXPR_COMMON_HEADER
    Expr* lhs;
    Expr* rhs;
    TokenIndex op;
    bool inplace;
} BinaryExpr;

static void BinaryExpr__dtor(Expr* self_) {
    BinaryExpr* self = (BinaryExpr*)self_;
    vtdelete(self->lhs);
    vtdelete(self->rhs);
}

static py_Name cmp_token2name(TokenIndex token) {
    switch(token) {
        case TK_LT: return __lt__;
        case TK_LE: return __le__;
        case TK_EQ: return __eq__;
        case TK_NE: return __ne__;
        case TK_GT: return __gt__;
        case TK_GE: return __ge__;
        default: return 0;
    }
}

#define is_compare_expr(e) ((e)->vt->is_binary && cmp_token2name(((BinaryExpr*)(e))->op))

static void _emit_compare(BinaryExpr* self, Ctx* ctx, c11_vector* jmps) {
    if(is_compare_expr(self->lhs)) {
        _emit_compare((BinaryExpr*)self->lhs, ctx, jmps);
    } else {
        vtemit_(self->lhs, ctx);  // [a]
    }
    vtemit_(self->rhs, ctx);                              // [a, b]
    Ctx__emit_(ctx, OP_DUP_TOP, BC_NOARG, self->line);    // [a, b, b]
    Ctx__emit_(ctx, OP_ROT_THREE, BC_NOARG, self->line);  // [b, a, b]
    Ctx__emit_(ctx, OP_BINARY_OP, cmp_token2name(self->op), self->line);
    // [b, RES]
    int index = Ctx__emit_(ctx, OP_SHORTCUT_IF_FALSE_OR_POP, BC_NOARG, self->line);
    c11_vector__push(int, jmps, index);
}

static void BinaryExpr__emit_(Expr* self_, Ctx* ctx) {
    BinaryExpr* self = (BinaryExpr*)self_;
    c11_vector /*T=int*/ jmps;
    c11_vector__ctor(&jmps, sizeof(int));
    if(cmp_token2name(self->op) && is_compare_expr(self->lhs)) {
        // (a < b) < c
        BinaryExpr* e = (BinaryExpr*)self->lhs;
        _emit_compare(e, ctx, &jmps);
        // [b, RES]
    } else {
        // (1 + 2) < c
        if(self->inplace) {
            vtemit_inplace(self->lhs, ctx);
        } else {
            vtemit_(self->lhs, ctx);
        }
    }

    vtemit_(self->rhs, ctx);

    Opcode opcode = OP_BINARY_OP;
    uint16_t arg = BC_NOARG;

    switch(self->op) {
        case TK_ADD: arg = __add__ | (__radd__ << 8); break;
        case TK_SUB: arg = __sub__ | (__rsub__ << 8); break;
        case TK_MUL: arg = __mul__ | (__rmul__ << 8); break;
        case TK_DIV: arg = __truediv__ | (__rtruediv__ << 8); break;
        case TK_FLOORDIV: arg = __floordiv__ | (__rfloordiv__ << 8); break;
        case TK_MOD: arg = __mod__ | (__rmod__ << 8); break;
        case TK_POW: arg = __pow__ | (__rpow__ << 8); break;

        case TK_LT: arg = __lt__ | (__gt__ << 8); break;
        case TK_LE: arg = __le__ | (__ge__ << 8); break;
        case TK_EQ: arg = __eq__ | (__eq__ << 8); break;
        case TK_NE: arg = __ne__ | (__ne__ << 8); break;
        case TK_GT: arg = __gt__ | (__lt__ << 8); break;
        case TK_GE: arg = __ge__ | (__le__ << 8); break;

        case TK_IN:
            opcode = OP_CONTAINS_OP;
            arg = 0;
            break;
        case TK_NOT_IN:
            opcode = OP_CONTAINS_OP;
            arg = 1;
            break;
        case TK_IS:
            opcode = OP_IS_OP;
            arg = 0;
            break;
        case TK_IS_NOT:
            opcode = OP_IS_OP;
            arg = 1;
            break;

        case TK_LSHIFT: arg = __lshift__; break;
        case TK_RSHIFT: arg = __rshift__; break;
        case TK_AND: arg = __and__; break;
        case TK_OR: arg = __or__; break;
        case TK_XOR: arg = __xor__; break;
        case TK_DECORATOR: arg = __matmul__; break;
        default: assert(false);
    }

    Ctx__emit_(ctx, opcode, arg, self->line);

    for(int i = 0; i < jmps.length; i++) {
        Ctx__patch_jump(ctx, c11__getitem(int, &jmps, i));
    }
    c11_vector__dtor(&jmps);
}

BinaryExpr* BinaryExpr__new(int line, TokenIndex op, bool inplace) {
    const static ExprVt Vt = {.emit_ = BinaryExpr__emit_,
                              .dtor = BinaryExpr__dtor,
                              .is_binary = true};
    BinaryExpr* self = PK_MALLOC(sizeof(BinaryExpr));
    self->vt = &Vt;
    self->line = line;
    self->lhs = NULL;
    self->rhs = NULL;
    self->op = op;
    self->inplace = inplace;
    return self;
}

typedef struct TernaryExpr {
    EXPR_COMMON_HEADER
    Expr* cond;
    Expr* true_expr;
    Expr* false_expr;
} TernaryExpr;

void TernaryExpr__dtor(Expr* self_) {
    TernaryExpr* self = (TernaryExpr*)self_;
    vtdelete(self->cond);
    vtdelete(self->true_expr);
    vtdelete(self->false_expr);
}

void TernaryExpr__emit_(Expr* self_, Ctx* ctx) {
    TernaryExpr* self = (TernaryExpr*)self_;
    vtemit_(self->cond, ctx);
    int patch = Ctx__emit_(ctx, OP_POP_JUMP_IF_FALSE, BC_NOARG, self->cond->line);
    vtemit_(self->true_expr, ctx);
    int patch_2 = Ctx__emit_(ctx, OP_JUMP_FORWARD, BC_NOARG, self->true_expr->line);
    Ctx__patch_jump(ctx, patch);
    vtemit_(self->false_expr, ctx);
    Ctx__patch_jump(ctx, patch_2);
}

TernaryExpr* TernaryExpr__new(int line) {
    const static ExprVt Vt = {.dtor = TernaryExpr__dtor, .emit_ = TernaryExpr__emit_};
    TernaryExpr* self = PK_MALLOC(sizeof(TernaryExpr));
    self->vt = &Vt;
    self->line = line;
    self->cond = NULL;
    self->true_expr = NULL;
    self->false_expr = NULL;
    return self;
}

typedef struct SubscrExpr {
    EXPR_COMMON_HEADER
    Expr* lhs;
    Expr* rhs;
} SubscrExpr;

void SubscrExpr__dtor(Expr* self_) {
    SubscrExpr* self = (SubscrExpr*)self_;
    vtdelete(self->lhs);
    vtdelete(self->rhs);
}

void SubscrExpr__emit_(Expr* self_, Ctx* ctx) {
    SubscrExpr* self = (SubscrExpr*)self_;
    vtemit_(self->lhs, ctx);
    vtemit_(self->rhs, ctx);
    Ctx__emit_(ctx, OP_LOAD_SUBSCR, BC_NOARG, self->line);
}

bool SubscrExpr__emit_store(Expr* self_, Ctx* ctx) {
    SubscrExpr* self = (SubscrExpr*)self_;
    vtemit_(self->lhs, ctx);
    vtemit_(self->rhs, ctx);
    Ctx__emit_(ctx, OP_STORE_SUBSCR, BC_NOARG, self->line);
    return true;
}

void SubscrExpr__emit_inplace(Expr* self_, Ctx* ctx) {
    SubscrExpr* self = (SubscrExpr*)self_;
    vtemit_(self->lhs, ctx);
    vtemit_(self->rhs, ctx);
    Ctx__emit_(ctx, OP_DUP_TOP_TWO, BC_NOARG, self->line);
    Ctx__emit_(ctx, OP_LOAD_SUBSCR, BC_NOARG, self->line);
}

bool SubscrExpr__emit_istore(Expr* self_, Ctx* ctx) {
    SubscrExpr* self = (SubscrExpr*)self_;
    // [a, b, val] -> [val, a, b]
    Ctx__emit_(ctx, OP_ROT_THREE, BC_NOARG, self->line);
    Ctx__emit_(ctx, OP_STORE_SUBSCR, BC_NOARG, self->line);
    return true;
}

bool SubscrExpr__emit_del(Expr* self_, Ctx* ctx) {
    SubscrExpr* self = (SubscrExpr*)self_;
    vtemit_(self->lhs, ctx);
    vtemit_(self->rhs, ctx);
    Ctx__emit_(ctx, OP_DELETE_SUBSCR, BC_NOARG, self->line);
    return true;
}

SubscrExpr* SubscrExpr__new(int line) {
    const static ExprVt Vt = {
        .dtor = SubscrExpr__dtor,
        .emit_ = SubscrExpr__emit_,
        .emit_store = SubscrExpr__emit_store,
        .emit_inplace = SubscrExpr__emit_inplace,
        .emit_istore = SubscrExpr__emit_istore,
        .emit_del = SubscrExpr__emit_del,
        .is_subscr = true,
    };
    SubscrExpr* self = PK_MALLOC(sizeof(SubscrExpr));
    self->vt = &Vt;
    self->line = line;
    self->lhs = NULL;
    self->rhs = NULL;
    return self;
}

typedef struct AttribExpr {
    EXPR_COMMON_HEADER
    Expr* child;
    py_Name name;
} AttribExpr;

void AttribExpr__dtor(Expr* self_) {
    AttribExpr* self = (AttribExpr*)self_;
    vtdelete(self->child);
}

void AttribExpr__emit_(Expr* self_, Ctx* ctx) {
    AttribExpr* self = (AttribExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, OP_LOAD_ATTR, self->name, self->line);
}

bool AttribExpr__emit_del(Expr* self_, Ctx* ctx) {
    AttribExpr* self = (AttribExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, OP_DELETE_ATTR, self->name, self->line);
    return true;
}

bool AttribExpr__emit_store(Expr* self_, Ctx* ctx) {
    AttribExpr* self = (AttribExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, OP_STORE_ATTR, self->name, self->line);
    return true;
}

void AttribExpr__emit_inplace(Expr* self_, Ctx* ctx) {
    AttribExpr* self = (AttribExpr*)self_;
    vtemit_(self->child, ctx);
    Ctx__emit_(ctx, OP_DUP_TOP, BC_NOARG, self->line);
    Ctx__emit_(ctx, OP_LOAD_ATTR, self->name, self->line);
}

bool AttribExpr__emit_istore(Expr* self_, Ctx* ctx) {
    // [a, val] -> [val, a]
    AttribExpr* self = (AttribExpr*)self_;
    Ctx__emit_(ctx, OP_ROT_TWO, BC_NOARG, self->line);
    Ctx__emit_(ctx, OP_STORE_ATTR, self->name, self->line);
    return true;
}

AttribExpr* AttribExpr__new(int line, Expr* child, py_Name name) {
    const static ExprVt Vt = {.emit_ = AttribExpr__emit_,
                              .emit_del = AttribExpr__emit_del,
                              .emit_store = AttribExpr__emit_store,
                              .emit_inplace = AttribExpr__emit_inplace,
                              .emit_istore = AttribExpr__emit_istore,
                              .dtor = AttribExpr__dtor,
                              .is_attrib = true};
    AttribExpr* self = PK_MALLOC(sizeof(AttribExpr));
    self->vt = &Vt;
    self->line = line;
    self->child = child;
    self->name = name;
    return self;
}

typedef struct CallExprKwArg {
    py_Name key;
    Expr* val;
} CallExprKwArg;

typedef struct CallExpr {
    EXPR_COMMON_HEADER
    Expr* callable;
    c11_vector /*T=Expr* */ args;
    // **a will be interpreted as a special keyword argument: {{0}: a}
    c11_vector /*T=CallExprKwArg */ kwargs;
} CallExpr;

void CallExpr__dtor(Expr* self_) {
    CallExpr* self = (CallExpr*)self_;
    vtdelete(self->callable);
    c11__foreach(Expr*, &self->args, e) vtdelete(*e);
    c11__foreach(CallExprKwArg, &self->kwargs, e) vtdelete(e->val);
    c11_vector__dtor(&self->args);
    c11_vector__dtor(&self->kwargs);
}

void CallExpr__emit_(Expr* self_, Ctx* ctx) {
    CallExpr* self = (CallExpr*)self_;

    bool vargs = false;    // whether there is *args as input
    bool vkwargs = false;  // whether there is **kwargs as input
    c11__foreach(Expr*, &self->args, e) {
        if((*e)->vt->is_starred) vargs = true;
    }
    c11__foreach(CallExprKwArg, &self->kwargs, e) {
        if(e->val->vt->is_starred) vkwargs = true;
    }

    // if callable is a AttrExpr, we should try to use `fast_call` instead of use `boundmethod`
    if(self->callable->vt->is_attrib) {
        AttribExpr* p = (AttribExpr*)self->callable;
        vtemit_(p->child, ctx);
        Ctx__emit_(ctx, OP_LOAD_METHOD, p->name, p->line);
    } else {
        vtemit_(self->callable, ctx);
        Ctx__emit_(ctx, OP_LOAD_NULL, BC_NOARG, BC_KEEPLINE);
    }

    Opcode opcode = OP_CALL;
    if(vargs || vkwargs) {
        // in this case, there is at least one *args or **kwargs as StarredExpr
        // OP_CALL_VARGS needs to unpack them via vectorcall_buffer
        opcode = OP_CALL_VARGS;
    }

    c11__foreach(Expr*, &self->args, e) { vtemit_(*e, ctx); }
    c11__foreach(CallExprKwArg, &self->kwargs, e) {
        Ctx__emit_int(ctx, e->key, self->line);
        vtemit_(e->val, ctx);
    }
    int KWARGC = self->kwargs.length;
    int ARGC = self->args.length;
    assert(KWARGC < 256 && ARGC < 256);
    Ctx__emit_(ctx, opcode, (KWARGC << 8) | ARGC, self->line);
}

CallExpr* CallExpr__new(int line, Expr* callable) {
    const static ExprVt Vt = {.dtor = CallExpr__dtor, .emit_ = CallExpr__emit_};
    CallExpr* self = PK_MALLOC(sizeof(CallExpr));
    self->vt = &Vt;
    self->line = line;
    self->callable = callable;
    c11_vector__ctor(&self->args, sizeof(Expr*));
    c11_vector__ctor(&self->kwargs, sizeof(CallExprKwArg));
    return self;
}

/* context.c */
static void Ctx__ctor(Ctx* self, CodeObject* co, FuncDecl* func, int level) {
    self->co = co;
    self->func = func;
    self->level = level;
    self->curr_iblock = 0;
    self->is_compiling_class = false;
    c11_vector__ctor(&self->s_expr, sizeof(Expr*));
    c11_smallmap_n2i__ctor(&self->global_names);
    c11_smallmap_s2n__ctor(&self->co_consts_string_dedup_map);
}

static void Ctx__dtor(Ctx* self) {
    // clean the expr stack
    for(int i = 0; i < self->s_expr.length; i++) {
        vtdelete(c11__getitem(Expr*, &self->s_expr, i));
    }
    c11_vector__dtor(&self->s_expr);
    c11_smallmap_n2i__dtor(&self->global_names);
    c11_smallmap_s2n__dtor(&self->co_consts_string_dedup_map);
}

static int Ctx__prepare_loop_divert(Ctx* self, int line, bool is_break) {
    int index = self->curr_iblock;
    while(index >= 0) {
        CodeBlock* block = c11__at(CodeBlock, &self->co->blocks, index);
        switch(block->type) {
            case CodeBlockType_WHILE_LOOP: return index;
            case CodeBlockType_FOR_LOOP: {
                if(is_break) Ctx__emit_(self, OP_POP_TOP, BC_NOARG, line);
                return index;
            }
            case CodeBlockType_WITH: {
                Ctx__emit_(self, OP_POP_TOP, BC_NOARG, line);
                break;
            }
            case CodeBlockType_EXCEPT: {
                Ctx__emit_(self, OP_END_EXC_HANDLING, 1, line);
                break;
            }
            case CodeBlockType_FINALLY: {
                Ctx__emit_(self, OP_END_FINALLY, 1, line);
                break;
            }
            default: break;
        }
        index = block->parent;
    }
    return index;
}

static int Ctx__enter_block(Ctx* self, CodeBlockType type) {
    CodeBlock block = {type, self->curr_iblock, self->co->codes.length, -1, -1};
    c11_vector__push(CodeBlock, &self->co->blocks, block);
    self->curr_iblock = self->co->blocks.length - 1;
    return self->curr_iblock;
}

static void Ctx__exit_block(Ctx* self) {
    CodeBlock* block = c11__at(CodeBlock, &self->co->blocks, self->curr_iblock);
    block->end = self->co->codes.length;
    self->curr_iblock = block->parent;
    assert(self->curr_iblock >= 0);
}

static void Ctx__s_emit_decorators(Ctx* self, int count) {
    if(count == 0) return;
    assert(Ctx__s_size(self) >= count);
    // [obj]
    for(int i = 0; i < count; i++) {
        Expr* deco = Ctx__s_popx(self);
        vtemit_(deco, self);                                    // [obj, f]
        Ctx__emit_(self, OP_ROT_TWO, BC_NOARG, deco->line);     // [f, obj]
        Ctx__emit_(self, OP_LOAD_NULL, BC_NOARG, BC_KEEPLINE);  // [f, obj, NULL]
        Ctx__emit_(self, OP_ROT_TWO, BC_NOARG, BC_KEEPLINE);    // [obj, NULL, f]
        Ctx__emit_(self, OP_CALL, 1, deco->line);               // [obj]
        vtdelete(deco);
    }
}

static int Ctx__emit_virtual(Ctx* self, Opcode opcode, uint16_t arg, int line, bool is_virtual) {
    Bytecode bc = {(uint8_t)opcode, arg};
    BytecodeEx bcx = {line, is_virtual, self->curr_iblock};
    c11_vector__push(Bytecode, &self->co->codes, bc);
    c11_vector__push(BytecodeEx, &self->co->codes_ex, bcx);
    int i = self->co->codes.length - 1;
    BytecodeEx* codes_ex = (BytecodeEx*)self->co->codes_ex.data;
    if(line == BC_KEEPLINE) { codes_ex[i].lineno = i >= 1 ? codes_ex[i - 1].lineno : 1; }
    return i;
}

static int Ctx__emit_(Ctx* self, Opcode opcode, uint16_t arg, int line) {
    return Ctx__emit_virtual(self, opcode, arg, line, false);
}

static void Ctx__revert_last_emit_(Ctx* self) {
    c11_vector__pop(&self->co->codes);
    c11_vector__pop(&self->co->codes_ex);
}

static int Ctx__emit_int(Ctx* self, int64_t value, int line) {
    if(INT16_MIN <= value && value <= INT16_MAX) {
        return Ctx__emit_(self, OP_LOAD_SMALL_INT, (uint16_t)value, line);
    } else {
        py_TValue tmp;
        py_newint(&tmp, value);
        return Ctx__emit_(self, OP_LOAD_CONST, Ctx__add_const(self, &tmp), line);
    }
}

static void Ctx__patch_jump(Ctx* self, int index) {
    Bytecode* co_codes = (Bytecode*)self->co->codes.data;
    int target = self->co->codes.length;
    Bytecode__set_signed_arg(&co_codes[index], target - index);
}

static void Ctx__emit_jump(Ctx* self, int target, int line) {
    int index = Ctx__emit_(self, OP_JUMP_FORWARD, BC_NOARG, line);
    // should place after Ctx__emit_ because of realloc
    Bytecode* co_codes = (Bytecode*)self->co->codes.data;
    Bytecode__set_signed_arg(&co_codes[index], target - index);
}

static int Ctx__add_varname(Ctx* self, py_Name name) {
    // PK_MAX_CO_VARNAMES will be checked when pop_context(), not here
    return CodeObject__add_varname(self->co, name);
}

static int Ctx__add_const_string(Ctx* self, c11_sv key) {
    uint16_t* val = c11_smallmap_s2n__try_get(&self->co_consts_string_dedup_map, key);
    if(val) {
        return *val;
    } else {
        py_TValue tmp;
        py_newstrv(&tmp, key);
        c11_vector__push(py_TValue, &self->co->consts, tmp);
        int index = self->co->consts.length - 1;
        c11_smallmap_s2n__set(&self->co_consts_string_dedup_map,
                              c11_string__sv(PyObject__userdata(tmp._obj)),
                              index);
        return index;
    }
}

static int Ctx__add_const(Ctx* self, py_Ref v) {
    assert(v->type != tp_str);
    c11_vector__push(py_TValue, &self->co->consts, *v);
    return self->co->consts.length - 1;
}

static void Ctx__emit_store_name(Ctx* self, NameScope scope, py_Name name, int line) {
    switch(scope) {
        case NAME_LOCAL: Ctx__emit_(self, OP_STORE_FAST, Ctx__add_varname(self, name), line); break;
        case NAME_GLOBAL: {
            Opcode op = self->co->src->is_dynamic ? OP_STORE_NAME : OP_STORE_GLOBAL;
            Ctx__emit_(self, op, name, line);
        } break;
        default: c11__unreachable();
    }
}

// emit top -> pop -> delete
static void Ctx__s_emit_top(Ctx* self) {
    assert(self->s_expr.length);
    Expr* top = c11_vector__back(Expr*, &self->s_expr);
    vtemit_(top, self);
    vtdelete(top);
    c11_vector__pop(&self->s_expr);
}

// push
static void Ctx__s_push(Ctx* self, Expr* expr) { c11_vector__push(Expr*, &self->s_expr, expr); }

// top
static Expr* Ctx__s_top(Ctx* self) {
    assert(self->s_expr.length);
    return c11_vector__back(Expr*, &self->s_expr);
}

// size
static int Ctx__s_size(Ctx* self) { return self->s_expr.length; }

// pop -> delete
static void Ctx__s_pop(Ctx* self) {
    assert(self->s_expr.length);
    Expr* top = c11_vector__back(Expr*, &self->s_expr);
    vtdelete(top);
    c11_vector__pop(&self->s_expr);
}

// pop move
static Expr* Ctx__s_popx(Ctx* self) {
    assert(self->s_expr.length);
    Expr* top = c11_vector__back(Expr*, &self->s_expr);
    c11_vector__pop(&self->s_expr);
    return top;
}

/* compiler.c */
typedef struct Compiler Compiler;
typedef Error* (*PrattCallback)(Compiler* self);

typedef struct PrattRule {
    PrattCallback prefix;
    PrattCallback infix;
    enum Precedence precedence;
} PrattRule;

const static PrattRule rules[TK__COUNT__];

typedef struct Compiler {
    SourceData_ src;  // weakref

    Token* tokens;
    int tokens_length;

    int i;  // current token index
    c11_vector /*T=CodeEmitContext*/ contexts;
} Compiler;

static void Compiler__ctor(Compiler* self, SourceData_ src, Token* tokens, int tokens_length) {
    self->src = src;
    self->tokens = tokens;
    self->tokens_length = tokens_length;
    self->i = 0;
    c11_vector__ctor(&self->contexts, sizeof(Ctx));
}

static void Compiler__dtor(Compiler* self) {
    // free tokens
    for(int i = 0; i < self->tokens_length; i++) {
        if(self->tokens[i].value.index == TokenValue_STR) {
            // PK_FREE internal string
            c11_string__delete(self->tokens[i].value._str);
        }
    }
    PK_FREE(self->tokens);
    // free contexts
    c11__foreach(Ctx, &self->contexts, ctx) Ctx__dtor(ctx);
    c11_vector__dtor(&self->contexts);
}

/**************************************/
#define tk(i) (&self->tokens[i])
#define prev() (&self->tokens[self->i - 1])
#define curr() (&self->tokens[self->i])
#define next() (&self->tokens[self->i + 1])

#define advance() self->i++
#define mode() self->src->mode
#define ctx() (&c11_vector__back(Ctx, &self->contexts))

#define match_newlines() match_newlines_impl(self)

#define consume(expected)                                                                          \
    if(!match(expected))                                                                           \
        return SyntaxError(self,                                                                   \
                           "expected '%s', got '%s'",                                              \
                           TokenSymbols[expected],                                                 \
                           TokenSymbols[curr()->type]);
#define consume_end_stmt()                                                                         \
    if(!match_end_stmt(self)) return SyntaxError(self, "expected statement end")

#define check(B)                                                                                   \
    if((err = B)) return err

static NameScope name_scope(Compiler* self) {
    return self->contexts.length > 1 ? NAME_LOCAL : NAME_GLOBAL;
}

Error* SyntaxError(Compiler* self, const char* fmt, ...) {
    Error* err = PK_MALLOC(sizeof(Error));
    err->src = self->src;
    PK_INCREF(self->src);
    Token* t = self->i == self->tokens_length ? prev() : curr();
    err->lineno = t->line;
    va_list args;
    va_start(args, fmt);
    vsnprintf(err->msg, sizeof(err->msg), fmt, args);
    va_end(args);
    return err;
}

/* Matchers */
static bool is_expression(Compiler* self, bool allow_slice) {
    PrattCallback prefix = rules[curr()->type].prefix;
    return prefix && (allow_slice || curr()->type != TK_COLON);
}

#define match(expected) (curr()->type == expected ? (++self->i) : 0)

static bool match_newlines_impl(Compiler* self) {
    bool consumed = false;
    if(curr()->type == TK_EOL) {
        while(curr()->type == TK_EOL)
            advance();
        consumed = true;
    }
    return consumed;
}

static bool match_end_stmt(Compiler* self) {
    if(match(TK_SEMICOLON)) {
        match_newlines();
        return true;
    }
    if(match_newlines() || curr()->type == TK_EOF) return true;
    if(curr()->type == TK_DEDENT) return true;
    return false;
}

/* Expression */

/// Parse an expression and push it onto the stack.
static Error* parse_expression(Compiler* self, int precedence, bool allow_slice) {
    PrattCallback prefix = rules[curr()->type].prefix;
    if(!prefix || (curr()->type == TK_COLON && !allow_slice)) {
        return SyntaxError(self, "expected an expression, got %s", TokenSymbols[curr()->type]);
    }
    advance();
    Error* err;
    check(prefix(self));
    while(rules[curr()->type].precedence >= precedence &&
          (allow_slice || curr()->type != TK_COLON)) {
        TokenIndex op = curr()->type;
        advance();
        PrattCallback infix = rules[op].infix;
        if(infix == NULL) {
            return SyntaxError(self, "expected an infix operator, got %s", TokenSymbols[op]);
        }
        check(infix(self));
    }
    return NULL;
}

static Error* EXPR_TUPLE_ALLOW_SLICE(Compiler* self, bool allow_slice) {
    Error* err;
    check(parse_expression(self, PREC_LOWEST + 1, allow_slice));
    if(!match(TK_COMMA)) return NULL;
    // tuple expression     // (a, )
    int count = 1;
    do {
        if(curr()->brackets_level) match_newlines();
        if(!is_expression(self, allow_slice)) break;
        check(parse_expression(self, PREC_LOWEST + 1, allow_slice));
        count += 1;
        if(curr()->brackets_level) match_newlines();
    } while(match(TK_COMMA));
    // pop `count` expressions from the stack and merge them into a TupleExpr
    SequenceExpr* e = TupleExpr__new(prev()->line, count);
    for(int i = count - 1; i >= 0; i--) {
        e->items[i] = Ctx__s_popx(ctx());
    }
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

/// Parse a simple expression.
static Error* EXPR(Compiler* self) { return parse_expression(self, PREC_LOWEST + 1, false); }

/// Parse a simple expression or a tuple of expressions.
static Error* EXPR_TUPLE(Compiler* self) { return EXPR_TUPLE_ALLOW_SLICE(self, false); }

// special case for `for loop` and `comp`
static Error* EXPR_VARS(Compiler* self) {
    int count = 0;
    do {
        consume(TK_ID);
        py_Name name = py_namev(Token__sv(prev()));
        NameExpr* e = NameExpr__new(prev()->line, name, name_scope(self));
        Ctx__s_push(ctx(), (Expr*)e);
        count += 1;
    } while(match(TK_COMMA));
    if(count > 1) {
        SequenceExpr* e = TupleExpr__new(prev()->line, count);
        for(int i = count - 1; i >= 0; i--) {
            e->items[i] = Ctx__s_popx(ctx());
        }
        Ctx__s_push(ctx(), (Expr*)e);
    }
    return NULL;
}

/* Misc */
static void push_global_context(Compiler* self, CodeObject* co) {
    co->start_line = self->i == 0 ? 1 : prev()->line;
    Ctx* ctx = c11_vector__emplace(&self->contexts);
    Ctx__ctor(ctx, co, NULL, self->contexts.length);
}

static Error* pop_context(Compiler* self) {
    // add a `return None` in the end as a guard
    // previously, we only do this if the last opcode is not a return
    // however, this is buggy...since there may be a jump to the end (out of bound) even if the last
    // opcode is a return
    Ctx__emit_virtual(ctx(), OP_RETURN_VALUE, 1, BC_KEEPLINE, true);

    CodeObject* co = ctx()->co;
    // find the last valid token
    int j = self->i - 1;
    while(tk(j)->type == TK_EOL || tk(j)->type == TK_DEDENT || tk(j)->type == TK_EOF)
        j--;
    co->end_line = tk(j)->line;

    // some check here
    c11_vector* codes = &co->codes;
    if(co->nlocals > PK_MAX_CO_VARNAMES) {
        return SyntaxError(self, "maximum number of local variables exceeded");
    }
    if(co->consts.length > 65530) {
        return SyntaxError(self, "maximum number of constants exceeded");
    }
    // pre-compute block.end or block.end2
    for(int i = 0; i < codes->length; i++) {
        Bytecode* bc = c11__at(Bytecode, codes, i);
        if(bc->op == OP_LOOP_CONTINUE) {
            CodeBlock* block = c11__at(CodeBlock, &ctx()->co->blocks, bc->arg);
            Bytecode__set_signed_arg(bc, block->start - i);
        } else if(bc->op == OP_LOOP_BREAK) {
            CodeBlock* block = c11__at(CodeBlock, &ctx()->co->blocks, bc->arg);
            Bytecode__set_signed_arg(bc, (block->end2 != -1 ? block->end2 : block->end) - i);
        } else if(bc->op == OP_FOR_ITER || bc->op == OP_FOR_ITER_YIELD_VALUE) {
            CodeBlock* block = c11__at(CodeBlock, &ctx()->co->blocks, bc->arg);
            Bytecode__set_signed_arg(bc, block->end - i);
        }
    }
    // pre-compute func->is_simple
    FuncDecl* func = ctx()->func;
    if(func) {
        // check generator
        Bytecode* codes = func->code.codes.data;
        int codes_length = func->code.codes.length;

        for(int i = 0; i < codes_length; i++) {
            if(codes[i].op == OP_YIELD_VALUE || codes[i].op == OP_FOR_ITER_YIELD_VALUE) {
                func->type = FuncType_GENERATOR;
                break;
            }
        }

        if(func->type == FuncType_UNSET) {
            bool is_simple = true;
            if(func->kwargs.length > 0) is_simple = false;
            if(func->starred_arg >= 0) is_simple = false;
            if(func->starred_kwarg >= 0) is_simple = false;

            if(is_simple) {
                func->type = FuncType_SIMPLE;
            } else {
                func->type = FuncType_NORMAL;
            }
        }

        assert(func->type != FuncType_UNSET);
    }
    Ctx__dtor(ctx());
    c11_vector__pop(&self->contexts);
    return NULL;
}

/* Expression Callbacks */
static Error* exprLiteral(Compiler* self) {
    LiteralExpr* e = LiteralExpr__new(prev()->line, &prev()->value);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprBytes(Compiler* self) {
    c11_sv sv = c11_string__sv(prev()->value._str);
    Ctx__s_push(ctx(), (Expr*)RawStringExpr__new(prev()->line, sv, OP_BUILD_BYTES));
    return NULL;
}

static Error* exprFString(Compiler* self) {
    // @fstr-begin, [@fstr-cpnt | <expr>]*, @fstr-end
    int count = 0;
    int line = prev()->line;
    while(true) {
        if(match(TK_FSTR_END)) {
            SequenceExpr* e = FStringExpr__new(line, count);
            for(int i = count - 1; i >= 0; i--) {
                e->items[i] = Ctx__s_popx(ctx());
            }
            Ctx__s_push(ctx(), (Expr*)e);
            return NULL;
        } else if(match(TK_FSTR_CPNT)) {
            // OP_LOAD_CONST
            LiteralExpr* e = LiteralExpr__new(prev()->line, &prev()->value);
            Ctx__s_push(ctx(), (Expr*)e);
            count++;
        } else {
            // {a!r:.2f}
            Error* err = EXPR(self);
            if(err) return err;
            count++;

            if(match(TK_FSTR_SPEC)) {
                c11_sv spec = Token__sv(prev());
                // ':.2f}' -> ':.2f'
                spec.size--;
                Expr* child = Ctx__s_popx(ctx());
                FStringSpecExpr* e = FStringSpecExpr__new(prev()->line, child, spec);
                Ctx__s_push(ctx(), (Expr*)e);
            }
        }
    }
}

static Error* exprImag(Compiler* self) {
    Ctx__s_push(ctx(), (Expr*)ImagExpr__new(prev()->line, prev()->value._f64));
    return NULL;
}

static FuncDecl_ push_f_context(Compiler* self, c11_sv name, int* out_index);
static Error* _compile_f_args(Compiler* self, FuncDecl* decl, bool is_lambda);

static Error* exprLambda(Compiler* self) {
    Error* err;
    int line = prev()->line;
    int decl_index;
    FuncDecl_ decl = push_f_context(self, (c11_sv){"<lambda>", 8}, &decl_index);
    if(!match(TK_COLON)) {
        check(_compile_f_args(self, decl, true));
        consume(TK_COLON);
    }
    // https://github.com/pocketpy/pocketpy/issues/37
    check(parse_expression(self, PREC_LAMBDA + 1, false));
    Ctx__s_emit_top(ctx());
    Ctx__emit_(ctx(), OP_RETURN_VALUE, BC_NOARG, BC_KEEPLINE);
    check(pop_context(self));
    LambdaExpr* e = LambdaExpr__new(line, decl_index);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprOr(Compiler* self) {
    Error* err;
    int line = prev()->line;
    check(parse_expression(self, PREC_LOGICAL_OR + 1, false));
    LogicBinaryExpr* e = LogicBinaryExpr__new(line, OP_JUMP_IF_TRUE_OR_POP);
    e->rhs = Ctx__s_popx(ctx());
    e->lhs = Ctx__s_popx(ctx());
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprAnd(Compiler* self) {
    Error* err;
    int line = prev()->line;
    check(parse_expression(self, PREC_LOGICAL_AND + 1, false));
    LogicBinaryExpr* e = LogicBinaryExpr__new(line, OP_JUMP_IF_FALSE_OR_POP);
    e->rhs = Ctx__s_popx(ctx());
    e->lhs = Ctx__s_popx(ctx());
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprTernary(Compiler* self) {
    // [true_expr]
    Error* err;
    int line = prev()->line;
    check(parse_expression(self, PREC_TERNARY + 1, false));  // [true_expr, cond]
    consume(TK_ELSE);
    check(parse_expression(self, PREC_TERNARY + 1, false));  // [true_expr, cond, false_expr]
    TernaryExpr* e = TernaryExpr__new(line);
    e->false_expr = Ctx__s_popx(ctx());
    e->cond = Ctx__s_popx(ctx());
    e->true_expr = Ctx__s_popx(ctx());
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprBinaryOp(Compiler* self) {
    Error* err;
    int line = prev()->line;
    TokenIndex op = prev()->type;
    int precedence = rules[op].precedence;
    if(op != TK_POW) {
        // if not right associative, increase precedence
        precedence += 1;
    }
    check(parse_expression(self, precedence, false));
    BinaryExpr* e = BinaryExpr__new(line, op, false);
    if(op == TK_IN || op == TK_NOT_IN) {
        e->lhs = Ctx__s_popx(ctx());
        e->rhs = Ctx__s_popx(ctx());
    } else {
        e->rhs = Ctx__s_popx(ctx());
        e->lhs = Ctx__s_popx(ctx());
    }
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprNot(Compiler* self) {
    Error* err;
    int line = prev()->line;
    check(parse_expression(self, PREC_LOGICAL_NOT + 1, false));
    UnaryExpr* e = UnaryExpr__new(line, Ctx__s_popx(ctx()), OP_UNARY_NOT);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprUnaryOp(Compiler* self) {
    Error* err;
    int line = prev()->line;
    TokenIndex op = prev()->type;
    check(parse_expression(self, PREC_UNARY + 1, false));
    Expr* e = Ctx__s_popx(ctx());
    switch(op) {
        case TK_SUB: {
            // constant fold
            if(e->vt->is_literal) {
                LiteralExpr* le = (LiteralExpr*)e;
                if(le->value->index == TokenValue_I64 || le->value->index == TokenValue_F64) {
                    le->negated = true;
                }
                Ctx__s_push(ctx(), e);
            } else {
                Ctx__s_push(ctx(), (Expr*)UnaryExpr__new(line, e, OP_UNARY_NEGATIVE));
            }
            break;
        }
        case TK_INVERT: Ctx__s_push(ctx(), (Expr*)UnaryExpr__new(line, e, OP_UNARY_INVERT)); break;
        case TK_MUL: Ctx__s_push(ctx(), (Expr*)StarredExpr__new(line, e, 1)); break;
        case TK_POW: Ctx__s_push(ctx(), (Expr*)StarredExpr__new(line, e, 2)); break;
        default: assert(false);
    }
    return NULL;
}

static Error* exprGroup(Compiler* self) {
    Error* err;
    int line = prev()->line;
    if(match(TK_RPAREN)) {
        // empty tuple
        Ctx__s_push(ctx(), (Expr*)TupleExpr__new(line, 0));
        return NULL;
    }
    match_newlines();
    check(EXPR_TUPLE(self));  // () is just for change precedence
    match_newlines();
    consume(TK_RPAREN);
    if(Ctx__s_top(ctx())->vt->is_tuple) return NULL;
    GroupedExpr* g = GroupedExpr__new(line, Ctx__s_popx(ctx()));
    Ctx__s_push(ctx(), (Expr*)g);
    return NULL;
}

static Error* exprName(Compiler* self) {
    py_Name name = py_namev(Token__sv(prev()));
    NameScope scope = name_scope(self);
    // promote this name to global scope if needed
    if(c11_smallmap_n2i__contains(&ctx()->global_names, name)) {
        if(self->src->is_dynamic) return SyntaxError(self, "cannot use global keyword here");
        scope = NAME_GLOBAL;
    }
    NameExpr* e = NameExpr__new(prev()->line, name, scope);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprAttrib(Compiler* self) {
    consume(TK_ID);
    py_Name name = py_namev(Token__sv(prev()));
    AttribExpr* e = AttribExpr__new(prev()->line, Ctx__s_popx(ctx()), name);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprLiteral0(Compiler* self) {
    Literal0Expr* e = Literal0Expr__new(prev()->line, prev()->type);
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* consume_comp(Compiler* self, Opcode op0, Opcode op1) {
    // [expr]
    Error* err;
    int line = prev()->line;
    bool has_cond = false;
    check(EXPR_VARS(self));  // [expr, vars]
    consume(TK_IN);
    check(parse_expression(self, PREC_TERNARY + 1, false));  // [expr, vars, iter]
    match_newlines();
    if(match(TK_IF)) {
        check(parse_expression(self, PREC_TERNARY + 1, false));  // [expr, vars, iter, cond]
        has_cond = true;
    }
    CompExpr* ce = CompExpr__new(line, op0, op1);
    if(has_cond) ce->cond = Ctx__s_popx(ctx());
    ce->iter = Ctx__s_popx(ctx());
    ce->vars = Ctx__s_popx(ctx());
    ce->expr = Ctx__s_popx(ctx());
    Ctx__s_push(ctx(), (Expr*)ce);
    match_newlines();
    return NULL;
}

static Error* exprList(Compiler* self) {
    Error* err;
    int line = prev()->line;
    int count = 0;
    do {
        match_newlines();
        if(curr()->type == TK_RBRACKET) break;
        check(EXPR(self));
        count += 1;
        match_newlines();
        if(count == 1 && match(TK_FOR)) {
            check(consume_comp(self, OP_BUILD_LIST, OP_LIST_APPEND));
            consume(TK_RBRACKET);
            return NULL;
        }
        match_newlines();
    } while(match(TK_COMMA));
    consume(TK_RBRACKET);
    SequenceExpr* e = ListExpr__new(line, count);
    for(int i = count - 1; i >= 0; i--) {
        e->items[i] = Ctx__s_popx(ctx());
    }
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

static Error* exprMap(Compiler* self) {
    Error* err;
    int line = prev()->line;
    bool parsing_dict = false;  // {...} may be dict or set
    int count = 0;
    do {
        match_newlines();
        if(curr()->type == TK_RBRACE) break;
        check(EXPR(self));  // [key]
        if(curr()->type == TK_COLON) { parsing_dict = true; }
        if(parsing_dict) {
            consume(TK_COLON);
            check(EXPR(self));  // [key, value] -> [item]
            DictItemExpr* item = DictItemExpr__new(prev()->line);
            item->value = Ctx__s_popx(ctx());
            item->key = Ctx__s_popx(ctx());
            Ctx__s_push(ctx(), (Expr*)item);
        }
        count += 1;  // key-value pair count
        match_newlines();
        if(count == 1 && match(TK_FOR)) {
            if(parsing_dict) {
                check(consume_comp(self, OP_BUILD_DICT, OP_DICT_ADD));
            } else {
                check(consume_comp(self, OP_BUILD_SET, OP_SET_ADD));
            }
            consume(TK_RBRACE);
            return NULL;
        }
        match_newlines();
    } while(match(TK_COMMA));
    consume(TK_RBRACE);

    SequenceExpr* se;
    if(count == 0 || parsing_dict) {
        se = DictExpr__new(line, count);
    } else {
        se = SetExpr__new(line, count);
    }
    for(int i = count - 1; i >= 0; i--) {
        se->items[i] = Ctx__s_popx(ctx());
    }
    Ctx__s_push(ctx(), (Expr*)se);
    return NULL;
}

static Error* exprCall(Compiler* self) {
    Error* err;
    CallExpr* e = CallExpr__new(prev()->line, Ctx__s_popx(ctx()));
    Ctx__s_push(ctx(), (Expr*)e);  // push onto the stack in advance
    do {
        match_newlines();
        if(curr()->type == TK_RPAREN) break;
        if(curr()->type == TK_ID && next()->type == TK_ASSIGN) {
            consume(TK_ID);
            py_Name key = py_namev(Token__sv(prev()));
            consume(TK_ASSIGN);
            check(EXPR(self));
            CallExprKwArg kw = {key, Ctx__s_popx(ctx())};
            c11_vector__push(CallExprKwArg, &e->kwargs, kw);
        } else {
            check(EXPR(self));
            int star_level = 0;
            Expr* top = Ctx__s_top(ctx());
            if(top->vt->is_starred) star_level = ((StarredExpr*)top)->level;
            if(star_level == 2) {
                // **kwargs
                CallExprKwArg kw = {0, Ctx__s_popx(ctx())};
                c11_vector__push(CallExprKwArg, &e->kwargs, kw);
            } else {
                // positional argument
                if(e->kwargs.length > 0) {
                    return SyntaxError(self, "positional argument follows keyword argument");
                }
                c11_vector__push(Expr*, &e->args, Ctx__s_popx(ctx()));
            }
        }
        match_newlines();
    } while(match(TK_COMMA));
    consume(TK_RPAREN);
    return NULL;
}

static Error* exprSlice0(Compiler* self) {
    Error* err;
    SliceExpr* slice = SliceExpr__new(prev()->line);
    Ctx__s_push(ctx(), (Expr*)slice);  // push onto the stack in advance
    if(is_expression(self, false)) {   // :<stop>
        check(EXPR(self));
        slice->stop = Ctx__s_popx(ctx());
        // try optional step
        if(match(TK_COLON)) {  // :<stop>:<step>
            check(EXPR(self));
            slice->step = Ctx__s_popx(ctx());
        }
    } else if(match(TK_COLON)) {
        if(is_expression(self, false)) {  // ::<step>
            check(EXPR(self));
            slice->step = Ctx__s_popx(ctx());
        }  // else ::
    }      // else :
    return NULL;
}

static Error* exprSlice1(Compiler* self) {
    Error* err;
    SliceExpr* slice = SliceExpr__new(prev()->line);
    slice->start = Ctx__s_popx(ctx());
    Ctx__s_push(ctx(), (Expr*)slice);  // push onto the stack in advance
    if(is_expression(self, false)) {   // <start>:<stop>
        check(EXPR(self));
        slice->stop = Ctx__s_popx(ctx());
        // try optional step
        if(match(TK_COLON)) {  // <start>:<stop>:<step>
            check(EXPR(self));
            slice->step = Ctx__s_popx(ctx());
        }
    } else if(match(TK_COLON)) {  // <start>::<step>
        check(EXPR(self));
        slice->step = Ctx__s_popx(ctx());
    }  // else <start>:
    return NULL;
}

static Error* exprSubscr(Compiler* self) {
    Error* err;
    int line = prev()->line;
    match_newlines();
    check(EXPR_TUPLE_ALLOW_SLICE(self, true));
    match_newlines();
    consume(TK_RBRACKET);  // [lhs, rhs]
    SubscrExpr* e = SubscrExpr__new(line);
    e->rhs = Ctx__s_popx(ctx());  // [lhs]
    e->lhs = Ctx__s_popx(ctx());  // []
    Ctx__s_push(ctx(), (Expr*)e);
    return NULL;
}

////////////////
static Error* consume_type_hints(Compiler* self) {
    Error* err;
    check(EXPR(self));
    Ctx__s_pop(ctx());
    return NULL;
}

static Error* consume_type_hints_sv(Compiler* self, c11_sv* out) {
    Error* err;
    const char* start = curr()->start;
    check(EXPR(self));
    const char* end = prev()->start + prev()->length;
    *out = (c11_sv){start, end - start};
    Ctx__s_pop(ctx());
    return NULL;
}

static Error* compile_stmt(Compiler* self);

static Error* compile_block_body(Compiler* self, PrattCallback callback) {
    Error* err;
    assert(callback != NULL);
    consume(TK_COLON);
    if(curr()->type != TK_EOL && curr()->type != TK_EOF) {
        while(true) {
            check(compile_stmt(self));
            bool possible = curr()->type != TK_EOL && curr()->type != TK_EOF;
            if(prev()->type != TK_SEMICOLON || !possible) break;
        }
        return NULL;
    }

    bool consumed = match_newlines();
    if(!consumed) return SyntaxError(self, "expected a new line after ':'");

    consume(TK_INDENT);
    while(curr()->type != TK_DEDENT) {
        match_newlines();
        check(callback(self));
        match_newlines();
    }
    consume(TK_DEDENT);
    return NULL;
}

static Error* compile_if_stmt(Compiler* self) {
    Error* err;
    check(EXPR(self));  // condition
    Ctx__s_emit_top(ctx());
    int patch = Ctx__emit_(ctx(), OP_POP_JUMP_IF_FALSE, BC_NOARG, prev()->line);
    err = compile_block_body(self, compile_stmt);
    if(err) return err;
    if(match(TK_ELIF)) {
        int exit_patch = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, prev()->line);
        Ctx__patch_jump(ctx(), patch);
        check(compile_if_stmt(self));
        Ctx__patch_jump(ctx(), exit_patch);
    } else if(match(TK_ELSE)) {
        int exit_patch = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, prev()->line);
        Ctx__patch_jump(ctx(), patch);
        check(compile_block_body(self, compile_stmt));
        Ctx__patch_jump(ctx(), exit_patch);
    } else {
        Ctx__patch_jump(ctx(), patch);
    }
    return NULL;
}

static Error* compile_while_loop(Compiler* self) {
    Error* err;
    int block = Ctx__enter_block(ctx(), CodeBlockType_WHILE_LOOP);
    int block_start = c11__at(CodeBlock, &ctx()->co->blocks, block)->start;
    check(EXPR(self));  // condition
    Ctx__s_emit_top(ctx());
    int patch = Ctx__emit_(ctx(), OP_POP_JUMP_IF_FALSE, BC_NOARG, prev()->line);
    check(compile_block_body(self, compile_stmt));
    Ctx__emit_jump(ctx(), block_start, BC_KEEPLINE);
    Ctx__patch_jump(ctx(), patch);
    Ctx__exit_block(ctx());
    // optional else clause
    if(match(TK_ELSE)) {
        check(compile_block_body(self, compile_stmt));
        CodeBlock* p_block = c11__at(CodeBlock, &ctx()->co->blocks, block);
        p_block->end2 = ctx()->co->codes.length;
    }
    return NULL;
}

static Error* compile_for_loop(Compiler* self) {
    Error* err;
    check(EXPR_VARS(self));  // [vars]
    consume(TK_IN);
    check(EXPR_TUPLE(self));  // [vars, iter]
    Ctx__s_emit_top(ctx());   // [vars]
    Ctx__emit_(ctx(), OP_GET_ITER, BC_NOARG, BC_KEEPLINE);
    int block = Ctx__enter_block(ctx(), CodeBlockType_FOR_LOOP);
    int block_start = Ctx__emit_(ctx(), OP_FOR_ITER, block, BC_KEEPLINE);
    Expr* vars = Ctx__s_popx(ctx());
    bool ok = vtemit_store(vars, ctx());
    vtdelete(vars);
    if(!ok) {
        // this error occurs in `vars` instead of this line, but...nevermind
        return SyntaxError(self, "invalid syntax");
    }
    check(compile_block_body(self, compile_stmt));
    Ctx__emit_jump(ctx(), block_start, BC_KEEPLINE);
    Ctx__exit_block(ctx());
    // optional else clause
    if(match(TK_ELSE)) {
        check(compile_block_body(self, compile_stmt));
        CodeBlock* p_block = c11__at(CodeBlock, &ctx()->co->blocks, block);
        p_block->end2 = ctx()->co->codes.length;
    }
    return NULL;
}

static Error* compile_yield_from(Compiler* self, int kw_line) {
    Error* err;
    if(self->contexts.length <= 1) return SyntaxError(self, "'yield from' outside function");
    check(EXPR_TUPLE(self));
    Ctx__s_emit_top(ctx());
    Ctx__emit_(ctx(), OP_GET_ITER, BC_NOARG, kw_line);
    int block = Ctx__enter_block(ctx(), CodeBlockType_FOR_LOOP);
    int block_start = Ctx__emit_(ctx(), OP_FOR_ITER_YIELD_VALUE, block, kw_line);
    Ctx__emit_jump(ctx(), block_start, BC_KEEPLINE);
    Ctx__exit_block(ctx());
    // StopIteration.value will be pushed onto the stack
    return NULL;
}

Error* try_compile_assignment(Compiler* self, bool* is_assign) {
    Error* err;
    switch(curr()->type) {
        case TK_IADD:
        case TK_ISUB:
        case TK_IMUL:
        case TK_IDIV:
        case TK_IFLOORDIV:
        case TK_IMOD:
        case TK_ILSHIFT:
        case TK_IRSHIFT:
        case TK_IAND:
        case TK_IOR:
        case TK_IXOR: {
            if(Ctx__s_top(ctx())->vt->is_starred)
                return SyntaxError(self, "can't use inplace operator with starred expression");
            if(ctx()->is_compiling_class)
                return SyntaxError(self, "can't use inplace operator in class definition");
            advance();
            // a[x] += 1;   a and x should be evaluated only once
            // a.x += 1;    a should be evaluated only once
            // -1 to remove =; inplace=true
            int line = prev()->line;
            TokenIndex op = (TokenIndex)(prev()->type - 1);
            // [lhs]
            check(EXPR_TUPLE(self));  // [lhs, rhs]
            if(Ctx__s_top(ctx())->vt->is_starred)
                return SyntaxError(self, "can't use starred expression here");
            BinaryExpr* e = BinaryExpr__new(line, op, true);
            e->rhs = Ctx__s_popx(ctx());  // [lhs]
            e->lhs = Ctx__s_popx(ctx());  // []
            vtemit_((Expr*)e, ctx());
            bool ok = vtemit_istore(e->lhs, ctx());
            vtdelete((Expr*)e);
            if(!ok) return SyntaxError(self, "invalid syntax");
            *is_assign = true;
            return NULL;
        }
        case TK_ASSIGN: {
            consume(TK_ASSIGN);
            int n = 0;

            if(match(TK_YIELD_FROM)) {
                check(compile_yield_from(self, prev()->line));
                n = 1;
            } else {
                do {
                    check(EXPR_TUPLE(self));
                    n += 1;
                } while(match(TK_ASSIGN));

                // stack size is n+1
                Ctx__s_emit_top(ctx());
                for(int j = 1; j < n; j++)
                    Ctx__emit_(ctx(), OP_DUP_TOP, BC_NOARG, BC_KEEPLINE);
            }

            for(int j = 0; j < n; j++) {
                if(Ctx__s_top(ctx())->vt->is_starred)
                    return SyntaxError(self, "can't use starred expression here");
                Expr* e = Ctx__s_top(ctx());
                bool ok = vtemit_store(e, ctx());
                Ctx__s_pop(ctx());
                if(!ok) return SyntaxError(self, "invalid syntax");
            }
            *is_assign = true;
            return NULL;
        }
        default: *is_assign = false;
    }
    return NULL;
}

static FuncDecl_ push_f_context(Compiler* self, c11_sv name, int* out_index) {
    FuncDecl_ decl = FuncDecl__rcnew(self->src, name);
    decl->code.start_line = self->i == 0 ? 1 : prev()->line;
    decl->nested = name_scope(self) == NAME_LOCAL;
    // add_func_decl
    Ctx* top_ctx = ctx();
    c11_vector__push(FuncDecl_, &top_ctx->co->func_decls, decl);
    *out_index = top_ctx->co->func_decls.length - 1;
    // push new context
    top_ctx = c11_vector__emplace(&self->contexts);
    Ctx__ctor(top_ctx, &decl->code, decl, self->contexts.length);
    return decl;
}

static Error* read_literal(Compiler* self, py_Ref out) {
    Error* err;
    advance();
    const TokenValue* value = &prev()->value;
    bool negated = false;
    switch(prev()->type) {
        case TK_SUB:
            consume(TK_NUM);
            value = &prev()->value;
            negated = true;
        case TK_NUM: {
            if(value->index == TokenValue_I64) {
                py_newint(out, negated ? -value->_i64 : value->_i64);
            } else if(value->index == TokenValue_F64) {
                py_newfloat(out, negated ? -value->_f64 : value->_f64);
            } else {
                c11__unreachable();
            }
            return NULL;
        }
        case TK_STR: py_newstr(out, value->_str->data); return NULL;
        case TK_TRUE: py_newbool(out, true); return NULL;
        case TK_FALSE: py_newbool(out, false); return NULL;
        case TK_NONE: py_newnone(out); return NULL;
        case TK_DOTDOTDOT: py_newellipsis(out); return NULL;
        case TK_LPAREN: {
            py_TValue cpnts[4];
            int count = 0;
            while(true) {
                if(count == 4)
                    return SyntaxError(self, "default argument tuple exceeds 4 elements");
                check(read_literal(self, &cpnts[count]));
                count += 1;
                if(curr()->type == TK_RPAREN) break;
                consume(TK_COMMA);
                if(curr()->type == TK_RPAREN) break;
            }
            consume(TK_RPAREN);
            py_Ref p = py_newtuple(out, count);
            for(int i = 0; i < count; i++) {
                p[i] = cpnts[i];
            }
            return NULL;
        }
        default: py_newnil(out); return NULL;
    }
}

static Error* _compile_f_args(Compiler* self, FuncDecl* decl, bool is_lambda) {
    int state = 0;  // 0 for args, 1 for *args, 2 for k=v, 3 for **kwargs
    Error* err;
    do {
        if(!is_lambda) match_newlines();
        if(state >= 3) return SyntaxError(self, "**kwargs should be the last argument");
        if(match(TK_MUL)) {
            if(state < 1)
                state = 1;
            else
                return SyntaxError(self, "*args should be placed before **kwargs");
        } else if(match(TK_POW)) {
            state = 3;
        }
        consume(TK_ID);
        py_Name name = py_namev(Token__sv(prev()));

        // check duplicate argument name
        if(FuncDecl__is_duplicated_arg(decl, name)) {
            return SyntaxError(self, "duplicate argument name");
        }

        // eat type hints
        if(!is_lambda && match(TK_COLON)) check(consume_type_hints(self));
        if(state == 0 && curr()->type == TK_ASSIGN) state = 2;
        switch(state) {
            case 0: FuncDecl__add_arg(decl, name); break;
            case 1:
                FuncDecl__add_starred_arg(decl, name);
                state += 1;
                break;
            case 2: {
                consume(TK_ASSIGN);
                py_TValue value;
                check(read_literal(self, &value));
                if(py_isnil(&value)) return SyntaxError(self, "default argument must be a literal");
                FuncDecl__add_kwarg(decl, name, &value);
            } break;
            case 3:
                FuncDecl__add_starred_kwarg(decl, name);
                state += 1;
                break;
        }
    } while(match(TK_COMMA));
    if(!is_lambda) match_newlines();
    return NULL;
}

static Error* consume_pep695_py312(Compiler* self) {
    // https://peps.python.org/pep-0695/
    Error* err;
    if(match(TK_LBRACKET)) {
        do {
            consume(TK_ID);
            if(match(TK_COLON)) check(consume_type_hints(self));
        } while(match(TK_COMMA));
        consume(TK_RBRACKET);
    }
    return NULL;
}

static Error* compile_function(Compiler* self, int decorators) {
    Error* err;
    consume(TK_ID);
    c11_sv decl_name_sv = Token__sv(prev());
    int decl_index;
    FuncDecl_ decl = push_f_context(self, decl_name_sv, &decl_index);
    consume_pep695_py312(self);
    consume(TK_LPAREN);
    if(!match(TK_RPAREN)) {
        check(_compile_f_args(self, decl, false));
        consume(TK_RPAREN);
    }
    if(match(TK_ARROW)) check(consume_type_hints(self));
    check(compile_block_body(self, compile_stmt));
    check(pop_context(self));

    if(decl->code.codes.length >= 2) {
        Bytecode* codes = (Bytecode*)decl->code.codes.data;

        if(codes[0].op == OP_LOAD_CONST && codes[1].op == OP_POP_TOP) {
            // handle optional docstring
            py_TValue* consts = decl->code.consts.data;
            py_TValue* c = &consts[codes[0].arg];
            if(py_isstr(c)) {
                decl->docstring = py_tostr(c);
                codes[0].op = OP_NO_OP;
                codes[1].op = OP_NO_OP;
            }
        }
    }

    Ctx__emit_(ctx(), OP_LOAD_FUNCTION, decl_index, prev()->line);
    Ctx__s_emit_decorators(ctx(), decorators);

    py_Name decl_name = py_namev(decl_name_sv);
    if(ctx()->is_compiling_class) {
        if(decl_name == __new__ || decl_name == __init__) {
            if(decl->args.length == 0) {
                return SyntaxError(self,
                                   "%s() should have at least one positional argument",
                                   py_name2str(decl_name));
            }
        }

        Ctx__emit_(ctx(), OP_STORE_CLASS_ATTR, decl_name, prev()->line);
    } else {
        NameExpr* e = NameExpr__new(prev()->line, decl_name, name_scope(self));
        vtemit_store((Expr*)e, ctx());
        vtdelete((Expr*)e);
    }
    return NULL;
}

static Error* compile_class(Compiler* self, int decorators) {
    Error* err;
    if(ctx()->level > 1) return SyntaxError(self, "class definition not allowed here");
    consume(TK_ID);
    py_Name name = py_namev(Token__sv(prev()));
    bool has_base = false;
    consume_pep695_py312(self);
    if(match(TK_LPAREN)) {
        if(is_expression(self, false)) {
            check(EXPR(self));
            has_base = true;  // [base]
        }
        consume(TK_RPAREN);
    }
    if(!has_base) {
        Ctx__emit_(ctx(), OP_LOAD_NONE, BC_NOARG, prev()->line);
    } else {
        Ctx__s_emit_top(ctx());  // []
    }
    Ctx__emit_(ctx(), OP_BEGIN_CLASS, name, BC_KEEPLINE);

    c11__foreach(Ctx, &self->contexts, it) {
        if(it->is_compiling_class) return SyntaxError(self, "nested class is not allowed");
    }
    ctx()->is_compiling_class = true;
    check(compile_block_body(self, compile_stmt));
    ctx()->is_compiling_class = false;

    Ctx__s_emit_decorators(ctx(), decorators);
    Ctx__emit_(ctx(), OP_END_CLASS, name, BC_KEEPLINE);
    return NULL;
}

static Error* compile_decorated(Compiler* self) {
    Error* err;
    int count = 0;
    do {
        check(EXPR(self));
        count += 1;
        if(!match_newlines()) return SyntaxError(self, "expected a newline after '@'");
    } while(match(TK_DECORATOR));

    if(match(TK_CLASS)) {
        check(compile_class(self, count));
    } else {
        consume(TK_DEF);
        check(compile_function(self, count));
    }
    return NULL;
}

// import a [as b]
// import a [as b], c [as d]
static Error* compile_normal_import(Compiler* self) {
    do {
        consume(TK_ID);
        c11_sv name = Token__sv(prev());
        int index = Ctx__add_const_string(ctx(), name);
        Ctx__emit_(ctx(), OP_IMPORT_PATH, index, prev()->line);
        if(match(TK_AS)) {
            consume(TK_ID);
            name = Token__sv(prev());
        }
        Ctx__emit_store_name(ctx(), name_scope(self), py_namev(name), prev()->line);
    } while(match(TK_COMMA));
    consume_end_stmt();
    return NULL;
}

// from a import b [as c], d [as e]
// from a.b import c [as d]
// from . import a [as b]
// from .a import b [as c]
// from ..a import b [as c]
// from .a.b import c [as d]
// from xxx import *
static Error* compile_from_import(c11_sbuf* buf, Compiler* self) {
    int dots = 0;

    while(true) {
        switch(curr()->type) {
            case TK_DOT: dots += 1; break;
            case TK_DOTDOT: dots += 2; break;
            case TK_DOTDOTDOT: dots += 3; break;
            default: goto __EAT_DOTS_END;
        }
        advance();
    }
__EAT_DOTS_END:
    for(int i = 0; i < dots; i++) {
        c11_sbuf__write_char(buf, '.');
    }

    if(dots > 0) {
        // @id is optional if dots > 0
        if(match(TK_ID)) {
            c11_sbuf__write_sv(buf, Token__sv(prev()));
            while(match(TK_DOT)) {
                consume(TK_ID);
                c11_sbuf__write_char(buf, '.');
                c11_sbuf__write_sv(buf, Token__sv(prev()));
            }
        }
    } else {
        // @id is required if dots == 0
        consume(TK_ID);
        c11_sbuf__write_sv(buf, Token__sv(prev()));
        while(match(TK_DOT)) {
            consume(TK_ID);
            c11_sbuf__write_char(buf, '.');
            c11_sbuf__write_sv(buf, Token__sv(prev()));
        }
    }

    c11_string* path = c11_sbuf__submit(buf);
    Ctx__emit_(ctx(),
               OP_IMPORT_PATH,
               Ctx__add_const_string(ctx(), c11_string__sv(path)),
               prev()->line);
    c11_string__delete(path);
    consume(TK_IMPORT);

    if(match(TK_MUL)) {
        if(name_scope(self) != NAME_GLOBAL)
            return SyntaxError(self, "from <module> import * can only be used in global scope");
        // pop the module and import __all__
        Ctx__emit_(ctx(), OP_POP_IMPORT_STAR, BC_NOARG, prev()->line);
        consume_end_stmt();
        return NULL;
    }

    bool has_bracket = match(TK_LPAREN);
    do {
        if(has_bracket) match_newlines();
        Ctx__emit_(ctx(), OP_DUP_TOP, BC_NOARG, BC_KEEPLINE);
        consume(TK_ID);
        c11_sv name = Token__sv(prev());
        Ctx__emit_(ctx(), OP_LOAD_ATTR, py_namev(name), prev()->line);
        if(match(TK_AS)) {
            consume(TK_ID);
            name = Token__sv(prev());
        }
        Ctx__emit_store_name(ctx(), name_scope(self), py_namev(name), prev()->line);
    } while(match(TK_COMMA));
    if(has_bracket) {
        match_newlines();
        consume(TK_RPAREN);
    }
    Ctx__emit_(ctx(), OP_POP_TOP, BC_NOARG, BC_KEEPLINE);
    consume_end_stmt();
    return NULL;
}

static Error* compile_try_except(Compiler* self) {
    Error* err;
    int patches[8];
    int patches_length = 0;

    Ctx__enter_block(ctx(), CodeBlockType_TRY);
    Ctx__emit_(ctx(), OP_TRY_ENTER, BC_NOARG, prev()->line);
    check(compile_block_body(self, compile_stmt));

    // https://docs.python.org/3/reference/compound_stmts.html#finally-clause
    /* If finally is present, it specifies a cleanup handler. The try clause is executed,
     * including any except and else clauses. If an exception occurs in any of the clauses and is
     * not handled, the exception is temporarily saved. The finally clause is executed. If there is
     * a saved exception it is re-raised at the end of the finally clause. If the finally clause
     * raises another exception, the saved exception is set as the context of the new exception. If
     * the finally clause executes a return, break or continue statement, the saved exception is
     * discarded.
     */

    // known issue:
    // A return, break, continue in try/except block will make the finally block not executed

    bool has_finally = curr()->type == TK_FINALLY;
    if(!has_finally) {
        patches[patches_length++] = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, BC_KEEPLINE);
    }
    Ctx__exit_block(ctx());

    if(has_finally) {
        consume(TK_FINALLY);
        Ctx__emit_(ctx(), OP_BEGIN_FINALLY, BC_NOARG, prev()->line);
        // finally only, no except block
        Ctx__enter_block(ctx(), CodeBlockType_FINALLY);
        check(compile_block_body(self, compile_stmt));
        Ctx__exit_block(ctx());
        Ctx__emit_(ctx(), OP_END_FINALLY, BC_NOARG, BC_KEEPLINE);
        // re-raise if needed
        Ctx__emit_(ctx(), OP_RE_RAISE, BC_NOARG, BC_KEEPLINE);
        return NULL;
    }

    do {
        if(patches_length == 8) {
            return SyntaxError(self, "maximum number of except clauses reached");
        }
        py_Name as_name = 0;
        consume(TK_EXCEPT);
        if(is_expression(self, false)) {
            // except <expr>:
            check(EXPR(self));
            Ctx__s_emit_top(ctx());
            Ctx__emit_(ctx(), OP_EXCEPTION_MATCH, BC_NOARG, prev()->line);
            if(match(TK_AS)) {
                // except <expr> as <name>:
                consume(TK_ID);
                as_name = py_namev(Token__sv(prev()));
            }
        } else {
            // except:
            Ctx__emit_(ctx(), OP_LOAD_TRUE, BC_NOARG, BC_KEEPLINE);
        }
        int patch = Ctx__emit_(ctx(), OP_POP_JUMP_IF_FALSE, BC_NOARG, BC_KEEPLINE);
        // on match
        Ctx__emit_(ctx(), OP_BEGIN_EXC_HANDLING, BC_NOARG, BC_KEEPLINE);
        if(as_name) {
            Ctx__emit_(ctx(), OP_PUSH_EXCEPTION, BC_NOARG, BC_KEEPLINE);
            Ctx__emit_store_name(ctx(), name_scope(self), as_name, BC_KEEPLINE);
        }
        Ctx__enter_block(ctx(), CodeBlockType_EXCEPT);
        check(compile_block_body(self, compile_stmt));
        Ctx__exit_block(ctx());
        Ctx__emit_(ctx(), OP_END_EXC_HANDLING, BC_NOARG, BC_KEEPLINE);
        patches[patches_length++] = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, BC_KEEPLINE);
        Ctx__patch_jump(ctx(), patch);
    } while(curr()->type == TK_EXCEPT);

    // no match, re-raise
    // ...

    // match one & handled, jump to the end
    for(int i = 0; i < patches_length; i++)
        Ctx__patch_jump(ctx(), patches[i]);

    if(match(TK_FINALLY)) {
        Ctx__emit_(ctx(), OP_BEGIN_FINALLY, BC_NOARG, prev()->line);
        Ctx__enter_block(ctx(), CodeBlockType_FINALLY);
        check(compile_block_body(self, compile_stmt));
        Ctx__exit_block(ctx());
        Ctx__emit_(ctx(), OP_END_FINALLY, BC_NOARG, BC_KEEPLINE);
    }
    // re-raise if needed
    Ctx__emit_(ctx(), OP_RE_RAISE, BC_NOARG, BC_KEEPLINE);
    return NULL;
}

static Error* compile_stmt(Compiler* self) {
    Error* err;
    if(match(TK_CLASS)) {
        check(compile_class(self, 0));
        return NULL;
    }
    advance();
    int kw_line = prev()->line;  // backup line number
    switch(prev()->type) {
        case TK_BREAK: {
            int curr_loop_block = Ctx__prepare_loop_divert(ctx(), kw_line, true);
            if(curr_loop_block < 0) return SyntaxError(self, "'break' outside loop");
            Ctx__emit_(ctx(), OP_LOOP_BREAK, curr_loop_block, kw_line);
            consume_end_stmt();
            break;
        }
        case TK_CONTINUE: {
            int curr_loop_block = Ctx__prepare_loop_divert(ctx(), kw_line, false);
            if(curr_loop_block < 0) return SyntaxError(self, "'continue' not properly in loop");
            Ctx__emit_(ctx(), OP_LOOP_CONTINUE, curr_loop_block, kw_line);
            consume_end_stmt();
            break;
        }
        case TK_YIELD:
            if(self->contexts.length <= 1) return SyntaxError(self, "'yield' outside function");
            if(match_end_stmt(self)) {
                Ctx__emit_(ctx(), OP_YIELD_VALUE, 1, kw_line);
            } else {
                check(EXPR_TUPLE(self));
                Ctx__s_emit_top(ctx());
                Ctx__emit_(ctx(), OP_YIELD_VALUE, BC_NOARG, kw_line);
                consume_end_stmt();
            }
            break;
        case TK_YIELD_FROM:
            check(compile_yield_from(self, kw_line));
            Ctx__emit_(ctx(), OP_POP_TOP, BC_NOARG, kw_line);
            consume_end_stmt();
            break;
        case TK_RETURN:
            if(self->contexts.length <= 1) return SyntaxError(self, "'return' outside function");
            if(match_end_stmt(self)) {
                Ctx__emit_(ctx(), OP_RETURN_VALUE, 1, kw_line);
            } else {
                check(EXPR_TUPLE(self));
                Ctx__s_emit_top(ctx());
                consume_end_stmt();
                Ctx__emit_(ctx(), OP_RETURN_VALUE, BC_NOARG, kw_line);
            }
            break;
        /*************************************************/
        case TK_IF: check(compile_if_stmt(self)); break;
        case TK_WHILE: check(compile_while_loop(self)); break;
        case TK_FOR: check(compile_for_loop(self)); break;
        case TK_IMPORT: check(compile_normal_import(self)); break;
        case TK_FROM: {
            c11_sbuf buf;
            c11_sbuf__ctor(&buf);
            err = compile_from_import(&buf, self);
            c11_sbuf__dtor(&buf);
            if(err) return err;
            break;
        }
        case TK_DEF: check(compile_function(self, 0)); break;
        case TK_DECORATOR: check(compile_decorated(self)); break;
        case TK_TRY: check(compile_try_except(self)); break;
        case TK_PASS: consume_end_stmt(); break;
        /*************************************************/
        case TK_ASSERT: {
            check(EXPR(self));  // condition
            Ctx__s_emit_top(ctx());
            int index = Ctx__emit_(ctx(), OP_POP_JUMP_IF_TRUE, BC_NOARG, kw_line);
            int has_msg = 0;
            if(match(TK_COMMA)) {
                check(EXPR(self));  // message
                Ctx__s_emit_top(ctx());
                has_msg = 1;
            }
            Ctx__emit_(ctx(), OP_RAISE_ASSERT, has_msg, kw_line);
            Ctx__patch_jump(ctx(), index);
            consume_end_stmt();
            break;
        }
        case TK_GLOBAL:
            do {
                consume(TK_ID);
                py_Name name = py_namev(Token__sv(prev()));
                c11_smallmap_n2i__set(&ctx()->global_names, name, 0);
            } while(match(TK_COMMA));
            consume_end_stmt();
            break;
        case TK_RAISE: {
            check(EXPR(self));
            Ctx__s_emit_top(ctx());
            Ctx__emit_(ctx(), OP_RAISE, BC_NOARG, kw_line);
            consume_end_stmt();
        } break;
        case TK_DEL: {
            check(EXPR_TUPLE(self));
            Expr* e = Ctx__s_top(ctx());
            if(!vtemit_del(e, ctx())) return SyntaxError(self, "invalid syntax");
            Ctx__s_pop(ctx());
            consume_end_stmt();
        } break;
        case TK_WITH: {
            check(EXPR(self));  // [ <expr> ]
            Ctx__s_emit_top(ctx());
            Ctx__enter_block(ctx(), CodeBlockType_WITH);
            NameExpr* as_name = NULL;
            if(match(TK_AS)) {
                consume(TK_ID);
                py_Name name = py_namev(Token__sv(prev()));
                as_name = NameExpr__new(prev()->line, name, name_scope(self));
            }
            Ctx__emit_(ctx(), OP_WITH_ENTER, BC_NOARG, prev()->line);
            // [ <expr> <expr>.__enter__() ]
            if(as_name) {
                bool ok = vtemit_store((Expr*)as_name, ctx());
                vtdelete((Expr*)as_name);
                if(!ok) return SyntaxError(self, "invalid syntax");
            } else {
                // discard `__enter__()`'s return value
                Ctx__emit_(ctx(), OP_POP_TOP, BC_NOARG, BC_KEEPLINE);
            }
            check(compile_block_body(self, compile_stmt));
            Ctx__emit_(ctx(), OP_WITH_EXIT, BC_NOARG, prev()->line);
            Ctx__exit_block(ctx());
        } break;
        /*************************************************/
        // handle dangling expression or assignment
        default: {
            // do revert since we have pre-called advance() at the beginning
            --self->i;

            check(EXPR_TUPLE(self));

            bool is_typed_name = false;  // e.g. x: int
            // eat variable's type hint if it is a single name
            if(Ctx__s_top(ctx())->vt->is_name) {
                if(match(TK_COLON)) {
                    c11_sv type_hint;
                    check(consume_type_hints_sv(self, &type_hint));
                    is_typed_name = true;

                    if(ctx()->is_compiling_class) {
                        NameExpr* ne = (NameExpr*)Ctx__s_top(ctx());
                        int index = Ctx__add_const_string(ctx(), type_hint);
                        Ctx__emit_(ctx(), OP_LOAD_CONST, index, BC_KEEPLINE);
                        Ctx__emit_(ctx(), OP_ADD_CLASS_ANNOTATION, ne->name, BC_KEEPLINE);
                    }
                }
            }
            bool is_assign = false;
            check(try_compile_assignment(self, &is_assign));
            if(!is_assign) {
                if(Ctx__s_size(ctx()) > 0 && Ctx__s_top(ctx())->vt->is_starred) {
                    return SyntaxError(self, "can't use starred expression here");
                }
                if(!is_typed_name) {
                    Ctx__s_emit_top(ctx());
                    if((mode() == SINGLE_MODE) && name_scope(self) == NAME_GLOBAL) {
                        Ctx__emit_(ctx(), OP_PRINT_EXPR, BC_NOARG, BC_KEEPLINE);
                    } else {
                        Ctx__emit_(ctx(), OP_POP_TOP, BC_NOARG, BC_KEEPLINE);
                    }
                } else {
                    Ctx__s_pop(ctx());
                }
            }
            consume_end_stmt();
            break;
        }
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////

Error* Compiler__compile(Compiler* self, CodeObject* out) {
    // make sure it is the first time to compile
    assert(self->i == 0);
    // make sure the first token is @sof
    assert(tk(0)->type == TK_SOF);

    push_global_context(self, out);

    advance();         // skip @sof, so prev() is always valid
    match_newlines();  // skip possible leading '\n'

    Error* err;
    if(mode() == EVAL_MODE) {
        check(EXPR_TUPLE(self));
        Ctx__s_emit_top(ctx());
        consume(TK_EOF);
        Ctx__emit_(ctx(), OP_RETURN_VALUE, BC_NOARG, BC_KEEPLINE);
        check(pop_context(self));
        return NULL;
    }

    while(!match(TK_EOF)) {
        check(compile_stmt(self));
        match_newlines();
    }
    check(pop_context(self));
    return NULL;
}

Error* pk_compile(SourceData_ src, CodeObject* out) {
    Token* tokens;
    int tokens_length;
    Error* err = Lexer__process(src, &tokens, &tokens_length);
    if(err) return err;

#if 0
    Token* data = (Token*)tokens.data;
    printf("%s\n", src->filename->data);
    for(int i = 0; i < tokens.length; i++) {
        Token* t = data + i;
        c11_string* tmp = c11_string__new2(t->start, t->length);
        if(t->value.index == TokenValue_STR) {
            const char* value_str = t->value._str->data;
            printf("[%d] %s: %s (value._str=%s)\n",
                   t->line,
                   TokenSymbols[t->type],
                   tmp->data,
                   value_str);
        } else {
            printf("[%d] %s: %s\n", t->line, TokenSymbols[t->type], tmp->data);
        }
        c11_string__delete(tmp);
    }
#endif

    Compiler compiler;
    Compiler__ctor(&compiler, src, tokens, tokens_length);
    CodeObject__ctor(out, src, c11_string__sv(src->filename));
    err = Compiler__compile(&compiler, out);
    if(err) {
        // dispose the code object if error occurs
        CodeObject__dtor(out);
    }
    Compiler__dtor(&compiler);
    return err;
}

// clang-format off
const static PrattRule rules[TK__COUNT__] = {
// http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
    [TK_DOT] =         { NULL,          exprAttrib,         PREC_PRIMARY    },
    [TK_LPAREN] =      { exprGroup,     exprCall,           PREC_PRIMARY    },
    [TK_LBRACKET] =    { exprList,      exprSubscr,         PREC_PRIMARY    },
    [TK_MOD] =         { NULL,          exprBinaryOp,       PREC_FACTOR     },
    [TK_ADD] =         { NULL,          exprBinaryOp,       PREC_TERM       },
    [TK_SUB] =         { exprUnaryOp,   exprBinaryOp,       PREC_TERM       },
    [TK_MUL] =         { exprUnaryOp,   exprBinaryOp,       PREC_FACTOR     },
    [TK_INVERT] =      { exprUnaryOp,   NULL,               PREC_UNARY      },
    [TK_DIV] =         { NULL,          exprBinaryOp,       PREC_FACTOR     },
    [TK_FLOORDIV] =    { NULL,          exprBinaryOp,       PREC_FACTOR     },
    [TK_POW] =         { exprUnaryOp,   exprBinaryOp,       PREC_EXPONENT   },
    [TK_GT] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_LT] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_EQ] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_NE] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_GE] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_LE] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_IN] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_IS] =          { NULL,          exprBinaryOp,       PREC_COMPARISION },
    [TK_LSHIFT] =      { NULL,          exprBinaryOp,       PREC_BITWISE_SHIFT },
    [TK_RSHIFT] =      { NULL,          exprBinaryOp,       PREC_BITWISE_SHIFT },
    [TK_AND] =         { NULL,          exprBinaryOp,       PREC_BITWISE_AND   },
    [TK_OR] =          { NULL,          exprBinaryOp,       PREC_BITWISE_OR    },
    [TK_XOR] =         { NULL,          exprBinaryOp,       PREC_BITWISE_XOR   },
    [TK_DECORATOR] =   { NULL,          exprBinaryOp,       PREC_FACTOR        },
    [TK_IF] =          { NULL,          exprTernary,        PREC_TERNARY       },
    [TK_NOT_IN] =      { NULL,          exprBinaryOp,       PREC_COMPARISION   },
    [TK_IS_NOT] =      { NULL,          exprBinaryOp,       PREC_COMPARISION   },
    [TK_AND_KW ] =     { NULL,          exprAnd,            PREC_LOGICAL_AND   },
    [TK_OR_KW] =       { NULL,          exprOr,             PREC_LOGICAL_OR    },
    [TK_NOT_KW] =      { exprNot,       NULL,               PREC_LOGICAL_NOT   },
    [TK_TRUE] =        { exprLiteral0 },
    [TK_FALSE] =       { exprLiteral0 },
    [TK_NONE] =        { exprLiteral0 },
    [TK_DOTDOTDOT] =   { exprLiteral0 },
    [TK_LAMBDA] =      { exprLambda,  },
    [TK_ID] =          { exprName,    },
    [TK_NUM] =         { exprLiteral, },
    [TK_STR] =         { exprLiteral, },
    [TK_FSTR_BEGIN] =  { exprFString, },
    [TK_IMAG] =        { exprImag,    },
    [TK_BYTES] =       { exprBytes,   },
    [TK_LBRACE] =      { exprMap      },
    [TK_COLON] =       { exprSlice0,    exprSlice1,      PREC_PRIMARY }
};
// clang-format on

#undef vtcall
#undef vtemit_
#undef vtemit_del
#undef vtemit_store
#undef vtemit_inplace
#undef vtemit_istore
#undef vtdelete
#undef EXPR_COMMON_HEADER
#undef is_compare_expr
#undef tk
#undef prev
#undef curr
#undef next
#undef advance
#undef mode
#undef ctx
#undef match_newlines
#undef consume
#undef consume_end_stmt
#undef check
#undef match
