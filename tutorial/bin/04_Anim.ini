; orx - Tutorial config file
; Should be used with orx v.1.4+

[Display]
ScreenWidth   = 800
ScreenHeight  = 600
Title         = Anim Tutorial
Smoothing     = false; <= Deactivates smoothing (no blur when zooming)

[Resource]
Texture = ../data/object # ../data/anim

[Input]
SetList = MainInput

[MainInput]
KEY_ESCAPE = Quit

KEY_LEFT   = GoLeft
KEY_RIGHT  = GoRight
KEY_UP     = ScaleUp
KEY_DOWN   = ScaleDown

[Viewport]
Camera = Camera

[Camera]
; We use the same size for the camera than our display on screen so as to obtain a 1:1 ratio
FrustumWidth  = @Display.ScreenWidth
FrustumHeight = @Display.ScreenHeight
FrustumFar    = 1.0
FrustumNear   = 0.0
Position      = (0.0, 0.0, -1.0)

[Pivot]
; This define the pivot we will use for all our animation frames
Pivot = (15.0, 31.0, 0.0)

[Graphic@Pivot]
; This is the main graphic object, used when no animation is played
Texture = soldier.png

[Soldier]
Graphic             = Graphic
AnimationSet        = AnimSet
Scale               = 4.0
;AnimationFrequency  = 2.0f

[AnimSet]
; This is the starting point of the animation graph itself (all other animations will be discovered from this one)
; This will also be the first animation that's going to be played
StartAnim   = IdleRight
; This defines the default duration for a single frame
; It can be overridden at the animation level or even at the frame level, using the same property name
KeyDuration = 0.1
; This says how many digits should be used as a suffix for animation frames
; Ie. for the animation SoldierWalkRight, the frames will be SoldierWalkRight1, SoldierWalkRight2, etc...
Digits      = 1

; This defines the texture used by the animations for their frames
; We can of course use different textures per frame, but this tutorial shows how it's done
; with a single texture (aka atlas) containing all the frames
Texture     = soldier_full.png ; <= This property will be inherited by all the frames
Pivot       = @Pivot ; <= This property will be inherited by all the frames

; This defines the actual animation content and the properties of its frames
; IdleRight, IdleLeft, WalkRight and WalkLeft will always be the animation names visible to the user
; And those can be re-used between different animation graphs
; However SoldierIdleRight, etc... defines the specific content for this soldier
; The second config value is a vector whose (x, y) components defines the default size of a frame
; The z component says how many frames we expect to create
; if z > 0, that will be the maximum frames that will be created for the animation
; if z = 0, frames will stop being created when no matching config section exists
; if z < 0, frames will be created as long as there's space to create them in the texture (aka atlas) itself, from left to right, then top to bottom

IdleRight   = SoldierIdleRight # (32, 32, 1) ; <= We only want one frame of 32x32 pixels
IdleLeft    = SoldierIdleLeft # (32, 32, 1)
WalkRight   = SoldierWalkRight # (32, 32, -1) ; <= We want as many frames of 32x32 pixels that can fit in the texture defined by SoldierWalkRight
WalkLeft    = SoldierWalkLeft # (32, 32, -1)

; Here we set all the animation links, this will define the whole animation graph
; Properties can be added to any link by adding special markers in front of the name of the destination animation, as follow:
; - a '.' means the link will be immediate (ie. not waiting for the current animation to finish)
; - a '!' means the current target property will be cleared when this link is used
; - a '+' means this link as a higher priority than normal, ie. without any animation target set, it will be used instead of any other lower priority animation link
; - a '-' means this link as a lower priority than normal, ie. without any animation target set, it won't be used unless there no higher priority animation link

IdleRight-> = IdleRight # .IdleLeft # WalkRight ; <= When going from IdleRight to IdleLeft, the IdleRight animation will be interrupted
IdleLeft->  = IdleLeft # .IdleRight # WalkLeft
WalkRight-> = WalkRight # .+IdleRight ; <= When going from WalkRight to IdleRight, the WalkRight animation will be interrupted and if no animation target is defined, WalkRight will always lead to IdleRight
WalkLeft->  = WalkLeft # .+IdleLeft

; !!! NB: We should *NOT* be using inheritance when defining animations as it will be replaced at runtime to inherit parameters defined at the animation set level
[SoldierIdleLeft]
; Here we're using the same settings as for SoldierIdleRight but the graphic will be flipped horizontally
Flip        = x

; !!! NB: We should *NOT* be using inheritance when defining animations as it will be replaced at runtime to inherit parameters defined at the animation set level
[SoldierWalkLeft]
Flip        = x

; Here's we're overriding the TextureOrigin parameter of the first frame of the SoldierIdleRight animation
; !!! NB: We should *NOT* be using inheritance when defining frames as it will be replaced at runtime to inherit parameters defined at the animation level
[SoldierIdleRight1]
TextureOrigin = (64, 32, 0)

; Here's we're overriding the TextureOrigin parameter of the first frame of the SoldierIdleRight animation
; !!! NB: We should *NOT* be using inheritance when defining frames as it will be replaced at runtime to inherit parameters defined at the animation level
[SoldierIdleLeft1]
TextureOrigin = (64, 32, 0)

; Adds left foot event on 1st frame of SoldierWalkRight
[SoldierWalkRight1]
KeyEvent    = !!Left!!

; Adds right foot event on 4th frame of SoldierWalkRight
[SoldierWalkRight4]
KeyEvent    = !!Right!!

; Adds right foot event on 1st frame of SoldierWalkRight
[SoldierWalkLeft1]
KeyEvent    = !!Right!!

; Adds left foot event on 4th frame of SoldierWalkLeft
[SoldierWalkLeft4]
KeyEvent    = !!Left!!
