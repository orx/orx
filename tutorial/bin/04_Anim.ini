; orx-Tutorial config file
; Should be used with orx v.0.9.0+

[Main]
GameFile=04_Anim; NB: It defines the game file when using the default main executable;

[Display]
Smoothing=false; <= Deactivates smoothing for no blur when zooming

[Viewport]
Camera=Camera;

[Camera]
FrustumWidth=800.0;
FrustumHeight=600.0;
FrustumFar=1.0;
FrustumNear=0.0;
Position={0.0, 0.0, -1.0};

[Pivot]
; This define the pivot we will use for all our animation frames
Pivot={15.0, 31.0, 0.0};

[Graphic@Pivot]
; This is the main graphic object, used when no animation is played
Texture=../../data/object/soldier.png;

[Soldier]
Graphic=Graphic;
AnimationSet=AnimSet;
;AnimationFrequency=2.0f;

[AnimSet]
; Here we defines an animation set which contains a group of animation and all the possible transitions
; This will be unique in memory, no matter how many objects use it

; First we define the complete set of animation
Animation1=IdleRight;
Animation2=WalkRight;
Animation3=IdleLeft;
Animation4=WalkLeft;

; Then we define all the links to form the animation graph

; Here we say that we can loop on idle right, but also go to walk right or idle left at once
Link1=IdleRight-IdleRight; <= NB: No space is currently allowed in links between two animation names
Link2=IdleRight-IdleLeft;
LinkProperty2=immediate;
Link3=IdleRight-WalkRight;
LinkProperty3=immediate;

; Here we say we can loop on walk right, but we can also go back to idle right as soone as it's requested
; If no destination animation is specified, we'll follow the highest priority link. The default priority for a link is 8
; So in our case, if we're walking and we stop having this desire, we'll automatically go back to idle right
Link4=WalkRight-WalkRight;
Link5=WalkRight-IdleRight;
LinkProperty5=immediate; <= If you remove this property, the animation won't be cut to go back to idle
LinkPriority5=9;

;We do the exact same thing on the left side
Link6=IdleLeft-IdleLeft;
Link7=IdleLeft-IdleRight;
LinkProperty7=immediate;
Link8=IdleLeft-WalkLeft;
LinkProperty8=immediate;

Link9=WalkLeft-WalkLeft;
Link10=WalkLeft-IdleLeft;
LinkProperty10=immediate; <= If you remove this property, the animation won't be cut to go back to idle
LinkPriority10=9;

; Having defined an animation set, we can easily ask for a specific animation in code, all the transitions will
; be made by the engine without having to bother chaining them manually
; With a more complex graph, we could have our soldier sitting and asking him to run
; He would then automatically stand up, begin to run, then run without having to write any code for this to happen
; Events are sent when animations start, end or are cut so you can act accordingly if needed

[IdleRight]
; Our idle animation is only one frame here, that lasts for 0.05s
KeyData1=AnimRight6;
KeyDuration1=0.1;

[IdleLeft]
; Our idle animation is only one frame here, that lasts for 0.05s
KeyData1=AnimLeft6;
KeyDuration1=0.1;

[WalkRight]
; We have 6 frames in our walk animation
DefaultKeyDuration=0.1; <= This defines the duration for all our frames unless locally specified differently
KeyData1=AnimRight1;
KeyData2=AnimRight2;
KeyData3=AnimRight3;
KeyData4=AnimRight4;
KeyData5=AnimRight5;
KeyData6=AnimRight6;

[WalkLeft]
; We have 6 frames in our walk animation
DefaultKeyDuration=0.1; <= This defines the duration for all our frames unless locally specified differently
KeyData1=AnimLeft1;
KeyData2=AnimLeft2;
KeyData3=AnimLeft3;
KeyData4=AnimLeft4;
KeyData5=AnimLeft5;
KeyData6=AnimLeft6;

; Below are the frame data for our animations

[FullGraphic@Pivot]
; This define the graphic object used by animation for their frames
; We will just need to define locally the specific area of the texture that we'll use
; We can of course use one image per frame, but this tutorial shows how to do it
; with a single image containing many frames
Texture=../../data/anim/soldier_full.png;

[AnimRight1@FullGraphic]
; First animation frame, we use a generic naming as the frames amy here be used in different animations
TextureTL={0, 0, 0};
TextureBR={32, 32, 0};

[AnimRight2@FullGraphic]
TextureTL={0, 32, 0};
TextureBR={32, 64, 0};

[AnimRight3@FullGraphic]
TextureTL={0, 64, 0};
TextureBR={32, 96, 0};

[AnimRight4@FullGraphic]
TextureTL={32, 0, 0};
TextureBR={64, 32, 0};

[AnimRight5@FullGraphic]
TextureTL={32, 32, 0};
TextureBR={64, 64, 0};

[AnimRight6@FullGraphic]
TextureTL={32, 64, 0};
TextureBR={64, 96, 0};

[AnimLeft1@AnimRight1]
; We just flip this frame on x axis
Flip=x;

[AnimLeft2@AnimRight2]
; We just flip this frame on x axis
Flip=x;

[AnimLeft3@AnimRight3]
; We just flip this frame on x axis
Flip=x;

[AnimLeft4@AnimRight4]
; We just flip this frame on x axis
Flip=x;

[AnimLeft5@AnimRight5]
; We just flip this frame on x axis
Flip=x;

[AnimLeft6@AnimRight6]
; We just flip this frame on x axis
Flip=x;

