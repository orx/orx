; Orx settings template / UTF-8 unicode support

; Sections are defined using [ ]
; Example:
; [My section]

; Everything after a ';' is considered as comment

; Key/value pairs are written like this:
; MyKey = MyValue
; Warning! If you want to add comments, use the ';' separator
; Example:
; MyKey = MyValue; Everything I wrote now is part of comments and not of the value

; If you want to use a ';' in a non-numerical value, use a block assignation delimited with '"'
; Example:
; MyKey = "MyValuePart1 ; MyValuePart2"
; Blocks are also useful for assigning multi-line values
; Example:
; MyKey = "This value
; spans
; on multiple lines"

; If you double the first '"', the value won't be considered as a block but as a regular one. It'll still contain a '"' at the start of the string value;
; Example:
; MyKey = ""MyQuotedValue"
; The string <"MyQuotedValue">, including the quotes, will be stored as a value

; All sections can inherit from any other one using the inheritance marker '@'
; Example:
; [Template]
; MyKey1 = MyValue1;
; MyKey2 = MyValue2;
; [Object@Template] <= This section will contains all values defined in the section 'Template';

; A parent can be removed when overriding a section and using no name after '@'.
; The implicit default parent section can be forced to be ignored by using the specific '@@' syntax
; Example:
; [Object] <= This section doesn't use any explicit parent but will use the implicit default parent if defined (see SettingsTemplate.ini, section [Config])
; [Object@Template] <= This section now uses 'Template' as an explicit parent section;
; [Object@] <= This section now has removed any explicit parent but is still using the implicit default parent if defined (see SettingsTemplate.ini, section [Config]))
; [Object@@] <= This section now has removed any parent and will not use the implicit default parent section either

; All values can be locally inherited from another section using the inheritance marker '@', with the optional use of '.' if we want to specify another key
; Example:
; [Template]
; MyKey = MyValue;
; MyOtherKey = MyOtherValue;
; [Object]
; MyKey = @Template; <= The value for 'MyKey' will be inherited from the one in the section 'Template', with the same key. This inheritance can be chained;
; My2ndKey = @Template.MyKey; <= The value for 'My2ndKey' will be inherited from the section 'Template' using the key 'MyKey'. This inheritance can also be chained;
; MyLastKey = @.MyKey; <= The value for 'MyLastKey' will be inherited from the current section ('Object') using the key 'MyKey'. This inheritance can also be chained;
; NB: MyOtherKey isn't inherited at all in this case.

; All values can implicitly refer to their own section using the inheritance marker '@' by itself. Its value will be dynamic and carry any inheritance to always result in the name of the child section;
; Example:
; [Template]
; MyKey = @; <= The value for 'MyKey' will be 'Template', the name of this section
; MyOtherKey = @; <= Same here, the value for 'MyOtherKey' will also be the name of this section: 'Template'
; [Object@Template]
; MyNewKey = @; <= The value for 'MyNewKey' will be 'Object'
; MyKey = @Template; <= The value for 'MyKey' will be inherited from the section 'Template' using the same key and its value will be 'Object', ie. this section, not the parent one, 'Template'
; NB: MyOtherKey will use the section inheritance and its value will be 'Object', ie. this section, not the parent one, 'Template'

; In the case of the in-section/nameless inheritance (@.Key), the "nameless" section used will also be dynamic;
; [Parent]
; MyKey = MyValue
; MyOtherKey = @.MyKey
; [Child@Parent]
; MyKey = MyLastValue
; Querying Child.MyOtherKey will result in 'MyLastValue': Child.MyOtherKey -> Parent.MyOtherKey -> <nameless>.Mykey -> Child.MyKey -> MyLastValue

; When a newly defined section had some previous content, the default behavior is to extend/override what is already present.
; If we'd rather clean all previous content of that section instead of extending/overriding it, we can add a '!' in front of the section definition.
; Example:
; [FirstSection]
; Key1 = 1
; [SecondSection]
; Key2 = 2
; [FirstSection] ; <= Here we're keeping what is already in this section
; NewKey1 = 3
; ![SecondSection] ; <= Here all the previous content of this section gets wiped
; NewKey2 = 4
; 2 values are present in FirstSection (Key1 = 1 and NewKey1 = 3) whereas only one value is present in SecondSection (NewKey2 = 4)

; If you want to load another file, you need to write this on an empty line:
; @path/to/MyOtherFile@
; Loading will happen instantly in the parsing, which can override previously defined values
; Also, values defined in the "included" file can be overridden afterward
; Lastly, after loading an "included" file, parsing will continue in the same section as before
; Example:
; [MySection]
; Key1 = Var1;
; @IncludeFile@
; Key2 = Var2; <= this will be added to the 'MySection' section
; If you want to conditionally load another file, you can use a command as condition:
; @condition_command?IncludeFile@ ; <= IncludeFile will only be loaded if executing condition_command returns non empty/false
; You can also optionally load another file based on a system config variable:
; @sysvar?IncludeFile@ ; <= IncludeFile will only be loaded if sysvar is set (ie. if executing the command Config.GetSystem sysvar returns non empty/false)
; Example:
; @windows?IncludeFile@ ; <= IncludeFile will only be loaded when running on Windows
; @debug?IncludeFile@ ; <= IncludeFile will only be loaded when running in debug
; @get MySection MyVar?IncludeFile@ ; <= IncludeFile will only be loaded if MyVar is set in the section MySection and doesn't equal false

; FLOAT values are expressed with a '.' as decimal separator.
; INT values can be expressed using different prefixes (not case sensitive):
; - decimal without any prefix: 16
; - hexadecimal with prefix '0x': 0x10
; - octal with prefix '0': 020
; - binary with prefix '0b': 0b10000
; VECTOR values are expressed this way:
; MyVector = (1.0, 2.0, 3.0); NB: { } can be used in place of ( ). Components can be (x, y, z) most of the time, or (r, g, b)/(h, s, l)/(h, s, v) for color
; When the last component of a vector is not specified, 0 will be used for it.
; Example:
; MyOtherVector = (4, 5); This is equivalent to MyOtherVector = (4, 5, 0)

; Wherever numerical values are used (Ints, Floats and Vectors), a random generated value can be obtained using the separator ~.
; Example:
; Value1 = 0.5 ~ 1.0;
; Value2 = (0.0, 0.0, 0.0) ~ (1.0, 1.0, 1.0);
; Random values can be constrained to steps/increments using the syntax v1 ~step~ v2.
; Example:
; Value3 = 0 ~2~ 10; This will produce an even value between 0 and 10 (ie. step = 2).
; Note that if the value is retrieved as a float, the upper bound cannot be reached, however it can be reached for all integer types.

; When using vector values, one can set a component to 0 to get an unconstrained value for that component.
; Example:
; MyRandomVector = (1, 3, 5) ~(0, 0.1)~ (2, 4, 6); X will be unconstrained between 1 and 2 (step = 0), Y will be between 3 and 4 with a step of 0.1 and Z will be unconstrained between 5 and 6 (no Z component -> Z = 0).

; You can specify lists of values using the separator #.
; The default behavior will be to select randomly a value from a list *EXCEPT* if a list item index is provided in the code.
; For all properties defined in this template, values will be taken randomly if a list is provided for any field that doesn't explicitly accept one.
; Lists can contain random values.
; Example:
; Key1 = Var1 # Var2 # RandVar3 ~ RandVar4 # Var5;
; Lists can span multiple lines when using # at the end of the line (line ending comments are allowed).
; If you want to define an empty element at the end of a list, use ##
; Example:
; Key2 = Var1 # Var2 #
;        Var3 #; This list still continues on next line and this comment is valid.
;        Var4  ; This list is now complete and contains 4 elements.
; Key3 = Var1 # Var2 ##; This list will not span on the next line but will contain a 3rd (and last) empty element.

; You can also append items to properties using the assignment operator '+='. Append values to a property that doesn't exist is a valid behavior:
; in this case a regular value will be created, ie. the '+' is ignored.
; Example:
; Key1  = Item1 # Item2;
; Key1 += Item3;
; Key2 += NewItem1 # NewItem2;
; Key1 now contains 3 items: Item1, Item2 and Item3. Key2 only contains 2 items: NewItem1 and NewItem2.

; Commands can be used in order to get more dynamic contents, they'll be prefixed by `%`.
; A sequence of multiple commands can be expressed by separating them with `,`.
; There are two ways to define embedded commands:
; - Commands evaluated at load time, not tied to any specific property. These will be evaluated once, when the file is loaded. Example:
;   % > Get OtherSection BaseValue, + < 1, Set NewSection ValuePlusOne <
; - Commands that are lazily evaluated every time the value of a property is retrieved. Example:
;   Key = % MyOwnCommand 42
; In this second case, when more than a single command is defined, the property's value will be the result returned by the last one.
; Example:
; MyOtherKey = % log "Fetching dynamic content of MyOtherKey", * 21 2; Fetching MyOtherKey will return 42
; Lazy commands can also be embedded inside lists.
; Example:
; Key = 1 # % + 2 3 # 10; Fetching Key will return either 1, 5 or 10


[ObjectTemplate]
Graphic                       = GraphicTemplate;
AnimationSet                  = AnimationSetTemplate;
AnimationFrequency            = [Float];
Body                          = BodyTemplate;
Group                         = [String]; NB: Defaults to default group;
Clock                         = ClockTemplate; NB: If no clock is specified the main clock (core) will be used for update calculations;
LifeTime                      = anim|child|fx|sound|spawn|track|[Float]; NB: Multiple literals can be defined at once, in which case the object will be deleted when all of their associated conditions are fulfilled. If the value is numeric, the object will be deleted after that duration (in seconds). If not defined or negative value, infinite life is granted;
Age                           = [Float]; NB: If defined, object will seem to be [Age] old upon creation, in seconds;
Color                         = [Vector]|[WebColor]; NB: Values are RGB from 0 to 255. Official HTML web color names are also supported (this list can be extended through the Color config section);
RGB                           = [Vector]|[WebColor]; NB: Values are RGB from 0.0 to 1.0; Will be used only if Color isn't defined;
HSL                           = [Vector]|[WebColor]; NB: Values are HSL from 0.0 to 1.0; Will be used only if Color and RGB aren't defined;
HSV                           = [Vector]|[WebColor]; NB: Values are HSV from 0.0 to 1.0; Will be used only if Color, RGB and HSL aren't defined;
Alpha                         = [Float];
AutoScroll                    = x|y|both;
Flip                          = x|y|both; NB: Flipping only affects the visual. Properties like physics body won't be affected;
DepthScale                    = [Bool];
Position                      = ((center (truncate|round)) (left|right) (top|bottom)|[Vector] ->) (center (truncate|round)) (left|right) (top|bottom) ([Vector]|[Float])|[Vector]|[Float]; NB: An optional placement pivot "override" (literals or vector) can be provided at the beginning, followed by '->'. If a parent is available, the position (literals with optional offset or vector) can be expressed in the parent space with UseParentSpace, ie. [0-1] map to the parent's size on each axis;
SphericalPosition             = [Vector]; NB: Theta & Phi components are in degrees; Will be used only if Position isn't defined;
Speed                         = [Vector];
Pivot                         = (center (truncate|round)) (left|right) (top|bottom)|[Vector]; NB: Overrides graphic's value if present; truncate and round will adjust pivot values if they are not integers; z is ignored for 2D graphics;
Origin                        = [Vector]; NB: Overrides graphic's value if present;
Size                          = [Vector]; NB: Overrides graphic's value if present;
UseRelativeSpeed              = [Bool]; NB: If true, the initial speed will be applied relatively to current object rotation & scale. Defaults to false;
Rotation                      = [Float]; NB: Angle in degrees around z axis;
AngularVelocity               = [Float]; NB: Velocity in degrees/second around z axis;
Scale                         = [Vector]|[Float]; NB: z is ignored for 2D objects. If it has a valid parent and use its space, this value will be considered in parent's space, ie. [0-1] defines parent size on each axis;
Smoothing                     = [Bool]; NB: no value will defaults to the global display settings;
BlendMode                     = alpha|multiply|add|premul|none; NB: Default value is alpha;
Repeat                        = [Vector]; NB: z is ignored and other values must be strictly positive. This will be ignored for text objects;
FXList                        = FXTemplate1 # ... # FXTemplateN; NB: FX will be played immediately. Up to 8 FXs can be defined;
FXRecursiveList               = [Bool]1 # ... # [Bool]N; NB: Should the corresponding FXs in FXList be applied recursively (defaults to false for each of them);
FXFrequency                   = [Float];
SoundList                     = SoundTemplate1 # ... # SoundTemplateN; NB: FX will be played immediately. Up to 4 sounds can be defined;
ShaderList                    = ShaderTemplate1 # ... # ShaderTemplateN; NB: Shader will be activated immediately. Up to 4 shaders can be defined;
TrackList                     = TimeLineTrackTemplate1 # ... # TimeLineTrackTemplateN; NB: Timeline tracks will be played immediately. Up to 16 timeline tracks can be defined;
TriggerList                   = TriggerTemplate1 # ... # TriggerTemplateN; NB: Up to 16 triggers can be defined;
Spawner                       = SpawnerTemplate;
ChildList                     = ObjectTemplate1 # ... # ObjectTemplateN; NB: Children will get deleted automatically when the current object will be deleted;
ChildJointList                = JointTemplate1 # ... # JointTemplateN; NB: Indices match those of the ChildList;
ParentCamera                  = CameraTemplate; NB: This will set the object as a child of the specified camera. Ex: Allows easy creation of UI objects;
UseParentSpace                = true|false|both|position|scale|none; NB: If set to true/both and has a parent at creation (camera, object or spawner), its position and scale will be considered in parent's space, ie. [0-1] defines parent size on each axis using its pivot as origin. It can be applied individually to only position or scale. Defaults to true if ParentCamera is defined, false otherwise;
IgnoreFromParent              = none|all|rotation|scale[.xyz]|position|position.rotation|position.scale[.xyz]|position.position[.xyz]; NB: Defines which parts of the parent's transformation will be ignored when transmitted to the object. Defaults to none;
OnPrepare                     = [Command]; NB: Command run when preparing an object for creation. If the command returns false or empty, the object will not be created;
OnCreate                      = [Command]; NB: Command run when an object has been created;
OnDelete                      = [Command]; NB: Command run when an object will get deleted. If the command returns false or empty, the object will not be deleted, but only deactivated;

[GraphicTemplate]
Texture                       = path/to/ImageFile.ext; NB: If provided, text data will be ignored. If set to 'pixel', a 1x1 opaque white bitmap will be used. If set to 'transparent', a 1x1 transparent black bitmap will be used. If it begins with the character '$', it will be used as a locale key instead of as a plain texture. It will then be automatically updated upon a new language selection;
TextureOrigin                 = [Vector]; NB: Top left corner, z is ignored. This will be ignored for text data;
TextureSize                   = [Vector]; NB: Texture size, z is ignored. This will be ignored for text data;
KeepInCache                   = [Bool]; NB: If true, the associated texture will always stay in cache. This value is ignored for a text. Defaults to false;
Text                          = TextTemplate; NB: Will be ignored if a valid texture is provided;
Pivot                         = (center (truncate|round)) (left|right) (top|bottom)|[Vector]; NB: Truncate and round will adjust pivot values if they are not integers; z is ignored for 2D graphics;
Repeat                        = [Vector]; NB: z is ignored and other values must be strictly positive. This will be ignored for text data;
Flip                          = x|y|both;
Color                         = [Vector]|[WebColor]; NB: Values are RGB from 0 to 255. Official HTML web color names are also supported (this list can be extended through the Color config section);
RGB                           = [Vector]|[WebColor]; NB: Values are RGB from 0.0 to 1.0; Will be used only if Color isn't defined;
HSL                           = [Vector]|[WebColor]; NB: Values are HSL from 0.0 to 1.0; Will be used only if Color and RGB aren't defined;
HSV                           = [Vector]|[WebColor]; NB: Values are HSV from 0.0 to 1.0; Will be used only if Color, RGB and HSL aren't defined;
Alpha                         = [Float];
BlendMode                     = alpha|multiply|add|premul|none; NB: Default value is alpha;
Smoothing                     = [Bool]; NB: no value will defaults to the object settings. This will be ignored for text data;
Stasis                        = [Bool]; NB: If true and holding a texture, its texture will be released when its owner is disabled and reacquired when its owner is re-enabled. Defaults to false;

[TextTemplate]
String                        = "string to display"; NB: If this string begins with the character '$', it will be used as a locale key instead of as a plain text. It will then be automatically updated upon a new language selection;
Font                          = FontTemplate; NB: If none is provided or 'default' is used, orx's default font will be used; If it begins with the character '$', it will be used as a locale key instead of as a plain section name. It will then be automatically updated upon a new language selection;

[FontTemplate]
Texture                       = path/to/ImageFile.ext;
TextureOrigin                 = [Vector]; NB: Top left corner, z is ignored; Defaults to (0, 0, 0);
TextureSize                   = [Vector]; NB: Texture size for the character definition area, z is ignored; Defaults to texture's width & height;
KeepInCache                   = [Bool]; NB: If true, the associated texture will always stay in cache. Defaults to false;
CharacterList                 = "ordered list of character"; NB: All characters with a glyph in the texture file have to be specified in order of appearance; Supports ASCII or UTF-8 strings (*NOT* ISO-Latin-1!)
CharacterSize                 = [Vector]; NB: If defined, CharacterHeight & CharacterWidthList will be ignored. z value is ignored;
CharacterHeight               = [Float]; NB: This is only used for non-monospaced fonts, ie. when CharacterSize isn't defined;
CharacterWidthList            = [Float]1 # ... # [Float]N; NB: This is only used for non-monospaced fonts, ie. when CharacterSize isn't defined. There should be exactly one value per character defined in CharacterList;
CharacterSpacing              = [Vector]; NB: Empty space between characters, z is ignored. Defaults to (0, 0, 0);

[BodyTemplate]
Inertia                       = [Float];
Mass                          = [Float];
LinearDamping                 = [Float];
AngularDamping                = [Float];
FixedRotation                 = [Bool]; NB: Defaults to false;
HighSpeed                     = [Bool]; NB: Defaults to false;
Dynamic                       = [Bool]; NB: Defaults to false;
CustomGravity                 = [Vector]; NB: If none is provided, world's gravity will be applied to the body;
AllowSleep                    = [Bool]; NB: Defaults to true;
AllowMoving                   = [Bool]; NB: This is only used by static bodies. If set to true, the static body can be moved via its speed/angular velocity accessors. Defaults to true;
PartList                      = BodyPartTemplate1 # ... # BodyPartTemplateN;

[BodyPartSphereTemplate]
Type                          = sphere;
Center                        = [Vector]|full;
Radius                        = [Float]|full;
Friction                      = [Float];
Restitution                   = [Float];
Density                       = [Float];
SelfFlags                     = flags;
CheckMask                     = flags;
Solid                         = [Bool];

[BodyPartBoxTemplate]
Type                          = box;
TopLeft                       = [Vector]|full;
BottomRight                   = [Vector]|full;
Friction                      = [Float];
Restitution                   = [Float];
Density                       = [Float];
SelfFlags                     = flags;
CheckMask                     = flags;
Solid                         = [Bool];

[BodyPartMeshTemplate]
Type                          = mesh;
VertexList                    = [Vector]1 # ... # [Vector]N; NB: There is a maximum of 8 vertices and they *HAVE* to be entered clockwise;
Friction                      = [Float];
Restitution                   = [Float];
Density                       = [Float];
SelfFlags                     = flags;
CheckMask                     = flags;
Solid                         = [Bool];

[BodyPartEdgeTemplate]
Type                          = edge;
VertexList                    = [Vector] # [Vector]; NB: This should contain exactly 2 vectors;
PreviousVertex                = [Vector]; NB: Optional previous ghost vertex;
NextVertex                    = [Vector]; NB: Optional next ghost vertex;
Friction                      = [Float];
Restitution                   = [Float];
Density                       = [Float];
SelfFlags                     = flags;
CheckMask                     = flags;
Solid                         = [Bool];

[BodyPartChainTemplate]
Type                          = chain;
VertexList                    = [Vector]1 # ... # [Vector]N; NB: This should contain at least 2 vectors;
PreviousVertex                = [Vector]; NB: Optional previous ghost vertex;
NextVertex                    = [Vector]; NB: Optional next ghost vertex;
Loop                          = [Bool]; NB: If true, the chain will be treated as a closed loop. Defaults to false;
Friction                      = [Float];
Restitution                   = [Float];
Density                       = [Float];
SelfFlags                     = flags;
CheckMask                     = flags;
Solid                         = [Bool];

[RevoluteJoint]
Type                          = revolute;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
Rotation                      = [Float]; NB: Default rotation between parent and child bodies, in degrees. If none is provided, the current rotation difference between both bodies will be used;
MinRotation                   = [Float]; NB: Only used if MaxRotation is also defined;
MaxRotation                   = [Float]; NB: Only used if MinRotation is also defined;
MotorSpeed                    = [Float]; NB: Only used if MaxMotorTorque is also defined. In degrees / seconds;
MaxMotorTorque                = [Float]; NB: Only used if MotorSpeed is also defined;

[PrismaticJoint]
Type                          = prismatic;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
Rotation                      = [Float]; NB: Default rotation between parent and child bodies, in degrees. If none is provided, the current rotation difference between both bodies will be used;
TranslationAxis               = [Vector]; NB: Should be normalized;
MinTranslation                = [Float]; NB: Only used if MaxTranslation is also defined;
MaxTranslation                = [Float]; NB: Only used if MinTranslation is also defined;
MotorSpeed                    = [Float]; NB: Only used if MaxMotorForce is also defined. In units / seconds;
MaxMotorForce                 = [Float]; NB: Only used if MotorSpeed is also defined;

[SpringJoint]
Type                          = spring;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
Length                        = [Float]; NB: If not defined, the current distance between parent and child bodies will be used;
Frequency                     = [Float]; NB: In hertz;
Damping                       = [Float]; NB: 0 for no damping, 1 for max damping;

[RopeJoint]
Type                          = rope;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
Length                        = [Float]; NB: If not defined, the current distance between parent and child bodies will be used;

[PulleyJoint]
Type                          = pulley;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
ParentGroundAnchor            = [Vector];
ChildGroundAnchor             = [Vector];
ParentLength                  = [Float]; NB: If not defined, the current distance between parent and its ground anchor will be used;
MaxParentLength               = [Float]; NB: If not defined ParentLength + LengthRatio * ChildLength will be used;
ChildLength                   = [Float]; NB: If not defined, the current distance between child and its ground anchor will be used;
MaxChildLength                = [Float]; NB: If not defined ParentLength + LengthRatio * ChildLength will be used;
LengthRatio                   = [Float];

[SuspensionJoint]
Type                          = suspension;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
TranslationAxis               = [Vector]; NB: Should be normalized;
Frequency                     = [Float]; NB: In hertz, 0 for no suspension;
Damping                       = [Float]; NB: 0 for no damping, 1 for max damping;
MotorSpeed                    = [Float]; NB: Only used if MaxMotorForce is also defined. In units / seconds;
MaxMotorForce                 = [Float]; NB: Only used if MotorSpeed is also defined;

[WeldJoint]
Type                          = weld;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
Rotation                      = [Float]; NB: Default rotation between parent and child bodies, in degrees. If none is provided, the current rotation difference between both bodies will be used;

[FrictionJoint]
Type                          = friction;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
MaxForce                      = [Float];
MaxTorque                     = [Float];

[GearJoint]
Type                          = gear;
ParentAnchor                  = [Vector]; NB: In local parent's space;
ChildAnchor                   = [Vector]; NB: In local child's space;
Collide                       = [Bool]; NB: Allows collision between joint's parent and child bodies. Defaults to false;
ParentJoint                   = [String]; NB: Should be a revolute or prismatic joint already existing on the parent.
ChildJoint                    = [String]; NB: Should be a revolute or prismatic joint already existing on the child.
JointRatio                    = [Float];

[AnimationSetTemplate]
; NB: This section will become the parent of any animation section used by it, so any common properties to all the animations or animation frames, such as FrameSize, Texture, KeyDuration or Direction can be defined here;
Frequency                     = [Float]; NB: Relative frequency to which the animations will be played. Defaults to 1;
KeepInCache                   = [Bool]; NB: If true, the animation set will always stay in cache, even if not currently used by any objects. Can save time but costs memory. Defaults to false;
StartAnim                     = Animation; NB: Entry point of the animation graph, first animation to be played by default. If this StartAnim is defined, StartAnimList will be ignored;
StartAnimList                 = Animation1 # ... # AnimationN; NB: Multiple entry points for disjointed animation graphs. The first animation in the list will be played by default. Ignored if StartAnim is defined;
Prefix                        = [String]; NB: Prefix that will used in front of all animation names and frames. Defaults to empty string;
Digits                        = [Int]; NB: How many digits will be used for the animation frame suffixes. Defaults to 0 (ie. as many digits as needed, without any prefixed 0);
Animation                     = [String] # [Int]; NB: The first value, optional, defines a name for the animation config template to use, defaults to the key itself. The second value, optional, specifies how many frames should be created: >0 => maximum frames to be loaded, -1 => as many frames as can fit inside the whole texture, 0 => as many frames as are defined in config, defaults to -1;
Animation                     = [String] # [String]; NB: In this mode, separate texture files are expected for all the frames. The first value defines the animation base file name, the second one defines the file extension;
Animation                     = empty; NB: In this mode, an empty animation (with no keys) will be created;
Animation->                   = {.!+-}Animation1 # ... # {.!+-}AnimationN; NB: Defines all the possible transitions (ie. links) coming from Animation. The optional prefixes are properties for the link: . => immediate, ! => clear target, + => high priority, - => low priority; Defaults to looping onto itself if not defined;

[AnimationTemplate]
; NB: The animation set section will become the parent of this section's current top-most parent;
Texture                       = path/to/ImageFile.ext; NB: cf. GraphicTemplate for more details on this property. If provided, Text property will be ignored;
TextureOrigin                 = [Vector]; NB: Defines the origin of the texture from which to get the frames. Defaults to top left corner, ie. (0, 0, 0). Unused in the case of Text animation;
TextureSize                   = [Vector]; NB: Defines the size of the texture from which to get the frames. Defaults to the actual physical size of the texture. Unused in the case of Text animation;
Text                          = TextTemplate ; NB: Text animations are supported provided that a Text property is defined at the animation level (here) and no Texture is defined. In this case, the animation should be defined with a value of 0 in the animation set (ie. retrieve frame data from config);
Direction                     = left|right|down|up # left|right|down|up; NB: Defines how the frames are read inside the texture. First value defines the direction of the rows, second one the direction of the columns. Defaults to right # down (ie. western writing direction);
FrameSize                     = [Vector]; NB: Default size of all the frames of this animation. Unused in the case of Text animation; If not defined in the case of a single frame animation, defaults to the same value as TextureSize;
KeyDuration                   = [Float]; NB: Default key duration for all the frames of this animation;

[AnimationTemplate1]
; NB: The animation section will become the parent of this section's current top-most parent;
KeyEvent                      = [String] # [Float]; NB: Optional. Defines a custom event that will be sent when this key is played. The first value is the event's name, the second one, the event's numerical value, is optional and defaults to 0.0;
TextureOrigin                 = [Vector]; NB: Optional. Overrides the computed origin of the frame. Only define it for manual override; If this is defined, FrameIndex will be ignored;
TextureSize                   = [Vector]; NB: Optional. Overrides the default size of the frame (the FrameSize attribute in the animation/Animation Set). Only define it for manual override;
FrameIndex                    = [Int]; NB: Optional. Overrides the current frame's texture origin based on the animation's FrameSize and Direction. Only define it for manual override; Ignored if TextureOrigin is defined for this frame;
String                        = "string to display"; NB: Optional. Only used for Text animations;
KeyDuration                   = [Float]; NB: Optional. Overrides the default key duration of the frame;
; NB: Any other Graphic property like Pivot or Flip can be used here;

[ViewportTemplate]
TextureList                   = Texture1 # ... # TextureN; NB: Textures used as destination when rendering that viewport; If the specified name doesn't refer to an existing texture, a texture of that name will be automatically created, matching the viewport's dimensions; Defaults to screen when not defined.
KeepInCache                   = [Bool]; NB: If true, the associated textures will always stay in cache. Defaults to false;
Position                      = (center) (left|right) (top|bottom)|[Vector]; NB: Literal position (example: top left) or position in pixels, from the top left corner. Defaults to top left;
Size                          = [Vector]; NB: Size in pixels;
UseRelativeSize               = [Bool]; NB: If true, the viewport size will be interpreted as relative to the underlying texture, using the [0.0 - 1.0] range on both x/y axes. Defaults to false;
BackgroundColor               = [Vector]|[WebColor]; NB: Values are RGB from 0 to 255. Official HTML web color names are also supported. If not set, the viewport won't erase any part of other overlapping viewports that were previously rendered this frame;
BackgroundAlpha               = [Float]; NB: If BackgroundColor is set, this value will be used as alpha; Defaults to 1.0;
Camera                        = CameraTemplate;
FixedRatio                    = [Float]; NB: Only used when no camera is linked, otherwise the aspect ratio of the camera will act as ratio for the viewport; Defaults to none, ie. no fixed ratio is enforced;
ShaderList                    = ShaderTemplate1 # ... # ShaderTemplateN; NB: Shader will be activated immediately. Up to 4 shaders can be defined;
BlendMode                     = alpha|multiply|add|premul|none; NB: Default value is none, used only when active shaders are attached;
AutoResize                    = [Bool]; NB: Default value is true if no fixed size is given, false otherwise. It's only applicable to viewports with linked textures. If true, viewport's dimension, position and linked textures will be resized/updated upon video mode changes;
NoDebug                       = [Bool]; NB: When set, no debug rendering will happen in this viewport; Defaults to false;

[CameraTemplate]
GroupList                     = Group1 # ... # GroupN; NB: Groups (of objects) will be rendered in the order of declaration. Up to 16 groups can be associated to a camera. Defaults to "default" group;
GroupValue                    = sort|raw; NB: If a group is set to "raw", objects assigned to it will not be sorted before rendering, which allows for rendering very large amounts of objects at high performance *when* sorting isn't required. Defaults to "sort";
Zoom                          = [Float];
Position                      = [Vector]|[Float];
Rotation                      = [Float]; NB: Angle in degrees around z axis;
FrustumNear                   = [Float];
FrustumFar                    = [Float];
FrustumWidth                  = [Float];
FrustumHeight                 = [Float];
ParentCamera                  = CameraTemplate; NB: This will set this camera as a child of the specified camera;
IgnoreFromParent              = none|all|rotation|scale[.xyz]|position|position.rotation|position.scale[.xyz]|position.position[.xyz]; NB: Defines which parts of the parent's transformation will be ignored when transmitted to the object. Defaults to none;

[ClockTemplate]
Frequency                     = [Float]|display; NB: Use 'display' to sync the clock with the display refresh rate. Use 0 to run the clock as fast as possible. Defaults to 'display';
ModifierList                  = [fixed|multiply|maxed|average] [Float]; NB: Core clock property. Each entry is a modifier followed by its value. A value of 0 will disable that modifier. Maxed: value will be used as a max DT, fixed: -1 will match exactly the frequency, average: value is the number of past updates to use for average. Defaults to: fixed -1;

[SoundTemplate]
Sound                         = path/to/SoundFile.ext; NB: If defined, Music will be ignored. Use it for short sound effects; If it begins with the character '$', it will be used as a locale key instead of as a plain sound. It will then be automatically updated upon a new language selection;
Music                         = path/to/MusicFile.ext|[empty|white|pink|brownian|sine|square|triangle|sawtooth] [channels] [samplerate]; NB: If Sound is not defined, it'll be used to load a buffered stream of sound in memory. If empty is used, an empty stream will be generated; If white/pink/brownian is used, a noise of the requested type will be generated; If sine/square/triangle/sawtooth is used, a wave of the requested type at the A4 (440Hz) frequency will be generated; If it begins with the character '$', it will be used as a locale key instead of as a plain music. It will then be automatically updated upon a new language selection;
Bus                           = [String]; NB: Defaults to 'master' bus;
Loop                          = [Bool];
Pitch                         = [Float]; NB: The default pitch is 1.0, which corresponds to the original recording frequency. 2.0 will be a pitch twice as high, 0.5 is a pitch twice as low. 0.0 is ignored;
Volume                        = [Float]; NB: Volume is in [0.0-1.0]. Defaults to 1.0;
Panning                       = [Float]; NB: Panning control. -1.0 for full left & 1.0 for full right. Defaults to 0.0 (center);
Mix                           = [Bool]; NB: Defines the Panning mode. True for mixing channels based on their position and false to act like a regular balance; Defaults to false;
DistanceList                  = [Float] (# [Float]); NB: Minimum (mandatory) and maximum (optional) distances for sound spatialization, in units. If any of them is negative, sound spatialization will be disabled for this sound. Defaults to -1.0 # FLT_MAX;
GainList                      = [Float] (# [Float]); NB: Minimum (mandatory) and maximum (optional) gain, used to clamp computed gain during sound spatialization, if enabled with DistanceList. Should be within [0.0f - 1.0f]. Defaults to 0.0 # 1.0;
RollOff                       = [Float]; NB: RollOff factor used to compute sound spatialization, if enabled with DistanceList. Defaults to 1.0;
FilterList                    = FilterTemplate1 # ... # FilterTemplateN; NB: Filters will be chained in their declaration order;
KeepInCache                   = [Bool]; NB: If true, the sound data (ie. the sample itself) will always stay in cache. This value is ignored for a music. Defaults to false;

[BiquadFilter]
Type                          = biquad;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
A0                            = [Float];
A1                            = [Float];
A2                            = [Float];
B0                            = [Float];
B1                            = [Float];
B2                            = [Float];

[LowPassFilter]
Type                          = lowpass;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Cutoff frequency;
Order                         = [Int]; NB: Should be between 1 and 8. Cannot be overridden at runtime with UseCustomParam. Defaults to 2;

[HighPassFilter]
Type                          = highpass;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Cutoff frequency;
Order                         = [Int]; NB: Should be between 1 and 8. Cannot be overridden at runtime with UseCustomParam. Defaults to 2;

[BandPassFilter]
Type                          = bandpass;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Cutoff frequency;
Order                         = [Int]; NB: Should be between 2 and 8. Cannot be overridden at runtime with UseCustomParam. Defaults to 2;

[LowShelfFilter]
Type                          = lowshelf;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Center frequency;
Q                             = [Float]; NB: Defines the filter's slope in ]0.0-1.0], the higher, the steeper. Defaults to ~0.707107 (1/sqrt(2.0));
Gain                          = [Float]; NB: In dB. Positive for amplification, negative for damping. Defaults to 0 (no change);

[HighShelfFilter]
Type                          = highshelf;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Center frequency;
Q                             = [Float]; NB: Defines the filter's slope in ]0.0-1.0], the higher, the steeper. Defaults to ~0.707107 (1/sqrt(2.0));
Gain                          = [Float]; NB: In dB. Positive for amplification, negative for damping. Defaults to 0 (no change);

[NotchFilter]
Type                          = notch;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Center frequency;
Q                             = [Float]; NB: Defines the filter's slope in ]0.0-1.0], the higher, the steeper. Defaults to ~0.707107 (1/sqrt(2.0));

[PeakingFilter]
Type                          = peaking;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Frequency                     = [Float]; NB: Center frequency;
Q                             = [Float]; NB: Defines the filter's slope in ]0.0-1.0], the higher, the steeper. Defaults to ~0.707107 (1/sqrt(2.0));
Gain                          = [Float]; NB: In dB. Positive for amplification, negative for damping. Defaults to 0 (no change);

[DelayFilter]
Type                          = delay;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime. Defaults to false, ie. no runtime override;
Delay                         = [Float]; NB: In seconds. Cannot be overridden at runtime with UseCustomParam. Should be > 0.0;
Decay                         = [Float]; NB: Amount of the "repeat" part, in [0.0-1.0]. 0.0 to deactivate the echo entirely and only introduce delay. Defaults to 0.0;

[FXTemplate]
SlotList                      = FXSlotTemplate1 # ... # FXSlotTemplateN; NB: There is a maximum of 8 slots;
Loop                          = [Bool];
Stagger                       = [Bool] # [Float]; If the first value is true, this FX will be added after all already existing FXs. Defaults to false. The second value, optional, is an additional signed time offset, in seconds, which helps define when the FX will start, staggered or not. Defaults to 0.0f;
DoNotCache                    = [Bool]; NB: If true, the FX won't get cached and will be recreated from config every time, which allows random values & variations but is more expensive. Defaults to false;
KeepInCache                   = [Bool]; NB: If true , the FX will always stay in cache, even if no FX of this type is currently in use. Can save time but costs memory. Ignored if DoNotCache is set to true. Defaults to false;

[FXSlotTemplate]
Type                          = alpha|color|rgb|hsl|hsv|scale|rotation|position|speed|volume|pitch|size|origin|float (add|multiply)|vector (add|multiply); NB: The float|vector types are not directly applied to objects: their final FX value can be obtained by calling orxFX_GetFloat()/orxFX_GetVector();
Curve                         = linear|triangle|square|sine|smooth|smoother|ease*|bezier (# [Vector] # [Vector]); All 30 usual web easings functions are supported, albeit not extensively listed here. The optional two vectors are the control points of the cubic Bezier curve. NB: Defaults to linear;
StartTime                     = [Float]; NB: Start time in seconds; Defaults to 0.0;
EndTime                       = [Float]; NB: End time in seconds; Defaults to 0.0;
StartValue                    = [Float]|[Vector]|[WebColor]; NB: Vectors are only used for anisotropic scale, position, speed and color/rgb/hsl/hsv slots. Web colors are only used for color slots. Defaults to the neutral value for the current type;
EndValue                      = [Float]|[Vector]|[WebColor]; NB: Vectors are only used for anisotropic scale, position, speed and color/rgb/hsl/hsv slots. Web colors are only used for color slots. Defaults to the neutral value for the current type;
Absolute                      = [Bool]; NB: The curve coefficient will be used as an absolute value. Defaults to false (=relative);
Stagger                       = [Bool]; If true, this slot will be added after all already existing slots. Defaults to false;
Period                        = [Float]; NB: Cycle period is in seconds. 0.0 means the whole length will be used as a period; Defaults to 0.0;
Phase                         = [Float]; NB: Cycle phase is [0.0-1.0]; Defaults to 0.0;
Amplification                 = [Float]; NB: Curve amplification coef over time. < 1.0 => attenuation, = 1.0 => constant, > 1.0 => amplification. Defaults to 1.0;
Acceleration                  = [Float]; NB: Curve acceleration over time. < 1.0 => deceleration, = 1.0 => constant, > 1.0 => acceleration. Defaults to 1.0;
Pow                           = [Float]; NB: 1.0 is the default value and will result in a regular curve;
UseRotation                   = [Bool]; NB: Only used for position & speed types, ignored otherwise. FX uses the object's rotation to compute values. Defaults to false;
UseScale                      = [Bool]; NB: Only used for position & speed types, ignored otherwise. FX uses the object's scale to compute values. Defaults to false;

[SpawnerTemplate]
Object                        = ObjectTemplate; NB: This can be a randomized value;
TotalObject                   = [Int]; NB: 0 or no value means unlimited total objects;
ActiveObject                  = [Int]; NB: 0 or no value means unlimited active objects;
Position                      = [Vector]|[Float];
Rotation                      = [Float]; NB: Angle in degrees around z axis;
Scale                         = [Vector]|[Float]; NB: z is ignored for 2D objects;
Interpolate                   = [Bool]; NB: When interpolate is set to true, sub-frame precision spawning will be emulated if needed. Defaults to false;
AutoReset                     = [Bool]; NB: If true, spawner will auto reset when emptied;
UseAlpha                      = [Bool]; NB: Will only work if the spawner is linked to a parent object, from which it'll take the alpha;
UseColor                      = [Bool]; NB: Will only work if the spawner is linked to a parent object, from which it'll take the color;
UseRotation                   = [Bool]; NB: If true, spawner's rotation will be transmitted to the spawned object. Defaults to true;
UseScale                      = [Bool]; NB: If true, spawner's scale will be transmitted to the spawned object. Defaults to true;
WaveSize                      = Int; NB: Number of object to spawn in every wave. 0 or no value means no automated wave spawning. This can be a randomized value;
WaveDelay                     = Float; NB: elapsed time between two spawned waves, in seconds. 0 means all the objects spawned at once. This can be a randomized value;
Immediate                     = [Bool]; NB: If set, the delay will be ignored for the first wave after creation or reset; Defaults to false;
ObjectSpeed                   = [Vector]; NB: If specified, this speed will be applied to spawned object. This can be a randomized value;
UseRelativeSpeed              = true|false|both|object|spawner|none; NB: If true/both, the speed will be applied relatively to the current combined rotation & scale of the spawner and the object. It can also be set to only consider the spawner's or the object's rotation & scale. Defaults to false;
UseSelfAsParent               = [Bool]; NB: If set to true, the created object's parent will be the spawner, and will be always relative to the spawner's position, scale and rotation. Defaults to false;
CleanOnDelete                 = [Bool]; NB: If set to true, all the live spawned objects will be deleted when the spawner gets deleted. Defaults to false;
IgnoreFromParent              = none|all|rotation|scale[.xyz]|position|position.rotation|position.scale[.xyz]|position.position[.xyz]; NB: Defines which parts of the parent's transformation will be ignored when transmitted to the object. Defaults to none;
OnSpawn                       = [Command]; NB: Command to run on an object after it has been spawned. Defaults to none;

[ShaderTemplate]
Code                          = "Your shader code block" ; NB: Used to declare a monolithic shader; Will be ignored if CodeList is defined;
CodeList                      = CodeKey1 # ... # CodeKeyN ; NB: The values of this list will be used as config keys from this section to reconstruct, in the given order, a multi-part shader; If not defined, Code will be used instead;
ParamList                     = Param1 # ... # ParamN; NB: Define all the parameters your shader code needs. Defined params then must have a default value to guess their type: textures, vectors and floats are supported. If none is provided, type defaults to texture and will use shader's owner texture as value;
ParamFloat                    = [Float]|time ([float]) (FXTemplate); NB: If a list is explicitly defined here, orx will create an array of floats of the same size as shader parameter; Use 'time' to get the 'active time' of the owner (will force UseCustomParam to true), followed by an optional float value if you want it to wrap around after that amount of seconds and an optional float FX for advanced transformation;
ParamVector                   = [Vector]; NB: If a list is explicitly defined here, orx will create an array of vectors of the same size as shader parameter;
ParamTexture                  = path/to/texture; NB: If an invalid path is given, or nothing is specified, the owner's texture will be used by default. If a list is explicitly defined here, orx will create an array of textures of the same size as shader parameter;
UseCustomParam                = [Bool]; NB: When set to true, an event will be sent to override params values at runtime as well as the automated "time" value. Defaults to false, ie. no runtime override unless "time" is used for a float param;
KeepInCache                   = [Bool]; NB: If true, the shader will always stay in cache, even if no shader of this type is currently in use. Can save time but costs memory. Defaults to false;

[TimeLineTrackTemplate]
FloatValue                    = "Your 1st event/command" # ... # "Your Nth event/command"; NB: FloatValue is a time in second (>= 0) after which the timeline events (ie. the values of the property) are going to be triggered, in the order of their definition. If an event is a valid command, it'll get executed;
Loop                          = [Bool];
Immediate                     = [Bool]; NB: If true, track will be executed immediately after being added to a timeline as opposed to during the next object update. Defaults to false;
KeepInCache                   = [Bool]; NB: If true, the timeline track will always stay in cache, even if no track of this type is currently in use. Can save time but costs memory. Defaults to false;

[TriggerTemplate]
Event:Ref1:...:RefN           = [CommandList]; NB: Event can have optional refinements, separated by ':'. `!` Is used to defined when the even propagation should stop, otherwise refinements will be processed in reverse order. If an event is a valid command, it'll get executed;
Event:Src:Dst                 = [CommandList]; NB: If Event:Src:Dst is fired, this handler (Event:Src:Dst) will be processed first, followed by Event:Src if present and finally Event;
Event:!Src:Dst                = [CommandList]; NB: '!' is used to stop the propagation through refinements. If Event:Src:Dst is fired, this handler (Event:Src:Dst) will be processed first, followed by Event:Src, then stop.
OnCreate                      = [CommandList]; NB: Triggered when object is created, after Object.OnCreate has been handled;
OnDelete                      = [CommandList]; NB: Triggered when object is deleted, after Object.OnDelete has been handled;
OnCollide:<Other>             = [CommandList]; NB: Triggered when physics contact matching the refinements have been added. Other is the other object's name;
OnSeparate:<Other>            = [CommandList]; NB: Triggered when physics contact matching the refinements have been removed. Other is the other object's name;
OnPartCollide:<Mine>:<Theirs> = [CommandList]; NB: Triggered when physics contact matching the refinements have been added. Mine & Theirs are the respective part names;
OnPartSeparate:<Mine>:<Theirs>= [CommandList]; NB: Triggered when physics contact matching the refinements have been removed. Mine & Theirs are the respective part names;
