; orx - Tutorial config file
; Should be used with orx v.1.0+

[Main]
GameFile = 08_Physics; NB: It defines the game file when using the default main executable

[Input]
SetList = TutorialInput

[TutorialInput]
KEY_LEFT    = RotateLeft
KEY_RIGHT   = RotateRight
MOUSE_LEFT  = RotateLeft
MOUSE_RIGHT = RotateRight

[Mouse]
ShowCursor = false

[Tutorial]
BoxNumber = 100; <= Nuber of boxes to create

[Viewport]
Camera          = Camera
BackgroundColor = (40, 40, 100)

[Camera]
; We use the same size for the camera than our display on screen so as to obtain a 1:1 ratio
FrustumWidth  = @Display.ScreenWidth
FrustumHeight = @Display.ScreenHeight
FrustumFar    = 2.0
Position      = (400.0, 300.0, -1.0)

[FullBoxPart]
Type        = box
Restitution = 0.0
Friction    = 1.0
SelfFlags   = 0x0001; <= This defines our collision flags
CheckMask   = 0xFFFF; <= This defines the collision mask that will be testing on other objects
Solid       = true; <= If it's not solid, we'll still have the collision info with the callback, but no physical collision will happen
Density     = 1.0; <= This will be used only by dynamic bodies (boxes) and not static ones (walls)
; As we don't specify TopLeft and BottomRight value, the part will use the full size of the body/object that's using it

[WallBody]
PartList = FullBoxPart

[BoxBody]
PartList    = FullBoxPart
Dynamic     = true; <= We use the same physical body than ground, except we are dynamic and not static
; As boxes will come to sleep if we stop moving the camera and we're not waking them up in code, no sleep allowed for them
AllowSleep  = false

[BoxGraphic]
Texture = ../../data/object/box.png
Pivot   = center

[Box]
Graphic   = BoxGraphic
Position  = (50.0, 50.0, 0.0) ~ (750.0, 550.0, 0.0)
Body      = BoxBody
Scale     = 2.0

[WallGraphic]
Texture = ../../data/scenery/ground.png

[HorizontalWallGraphic@WallGraphic]
Repeat = (25, 1, 1); <= This tiles the graphic 25 times on its X axis

[VerticalWallGraphic@WallGraphic]
Repeat = (1, 17, 1); <= This tiles the graphic 17 times on its Y axis

[WallTemplate]
Body = WallBody; <= Same body for all the wall objects

[VerticalWall@WallTemplate]
; Here we defined all properties for a vertical wall
Graphic = VerticalWallGraphic; <= We use the vertical wall graphic (that uses the tiling we need)
Scale   = @VerticalWallGraphic.Repeat; <=  We scale it to match our vertical screen size

[HorizontalWall@WallTemplate]
; Here we defined all properties for an horizontal wall
Graphic = HorizontalWallGraphic; <= We use the horizontal wall graphic (that uses the tiling we need)
Scale   = @HorizontalWallGraphic.Repeat; <= We scale it to match our vertical screen size

[Walls]
ChildList = Wall1 # Wall2 # Wall3 # Wall4

[Wall1@VerticalWall]
Position = (0, 24, 0); <= We place our first vertical wall

[Wall2@VerticalWall]
Position = (768, 24, 0); <= We place our second vertical wall

[Wall3@HorizontalWall]
Position = (0, -8, 0); <= We place our first horizontal wall

[Wall4@HorizontalWall]
Position = (0, 568, 0); <= We place our second horizontal wall

[Wall5@VerticalWall]
Position = (384, 24, 0); <= We place our third vertical wall

[Wall6@HorizontalWall]
Position = (0, 284, 0); <= We place our third horizontal wall

[SkyGraphic]
Texture = ../../data/scenery/sky.png

[Sky]
Graphic       = SkyGraphic
Scale         = (390.0, 2.45, 1.0); <= We scale to match the camera size
Position      = (0.0, 0.0, 1.0);
Smoothing     = true; <= No aliasing in our sky! =)

[Bump]
SlotList = ColorFlash

[ColorFlash]
Type        = color
StartTime   = 0.0
EndTime     = 0.2
Curve       = sine
Absolute    = true
StartValue  = (255, 255, 255)
EndValue    = (0, 0, 0) ~ (255, 255, 255)
